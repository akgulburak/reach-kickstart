{"ast":null,"code":"// XXX: use @types/algosdk when we can\nimport algosdk from 'algosdk';\nimport base32 from 'hi-base32';\nimport ethers from 'ethers';\nimport Timeout from 'await-timeout';\nimport buffer from 'buffer';\nimport msgpack from '@msgpack/msgpack'; // DEBUG: uncomment this for debugging in browser\n// @ts-ignore\n// import algosdk__src__transaction from 'algosdk/src/transaction';\n\nconst {\n  Buffer\n} = buffer;\nimport { getViewsHelper, deferContract, debug, assert, envDefault, isBigNumber, bigNumberify, bigNumberToNumber, argsSlice, makeRandom } from './shared.mjs';\nimport waitPort from './waitPort.mjs';\nimport { replaceableThunk } from './shared_impl.mjs';\nimport { addressToHex, stdlib as compiledStdlib, typeDefs } from './ALGO_compiled.mjs';\nimport { process, window } from './shim.mjs';\nexport * from './shared.mjs'; // Helpers\n\nfunction uint8ArrayToStr(a, enc = 'utf8') {\n  if (!(a instanceof Uint8Array)) {\n    console.log(a);\n    throw Error(`Expected Uint8Array, got ${a}`);\n  }\n\n  return Buffer.from(a).toString(enc);\n}\n\nconst [getWaitPort, setWaitPort] = replaceableThunk(() => true);\nexport { setWaitPort };\n\nasync function wait1port(server, port) {\n  if (!getWaitPort()) return;\n  return await waitPort(server, port);\n}\n\nconst [getSignStrategy, setSignStrategy] = replaceableThunk(() => 'mnemonic');\nexport { getSignStrategy, setSignStrategy };\nconst [getAlgoSigner, setAlgoSigner] = replaceableThunk(async () => {\n  if (window.AlgoSigner) {\n    const AlgoSigner = window.AlgoSigner;\n    await AlgoSigner.connect();\n    return AlgoSigner;\n  } else {\n    // TODO: wait for a few seconds and try again before giving up\n    throw Error(`Can't find AlgoSigner. Please refresh the page and try again.`);\n  }\n});\nexport { setAlgoSigner };\n\nif (process.env.REACH_CONNECTOR_MODE == 'ALGO-browser' // Yes, this is dumb. TODO something better\n|| process.env.REACH_CONNECTOR_MODE === 'ETH-browser') {\n  setWaitPort(false);\n}\n\nconst rawDefaultToken = 'c87f5580d7a866317b4bfe9e8b8d1dda955636ccebfa88c12b414db208dd9705';\nconst rawDefaultItoken = 'reach-devnet';\n\nconst getLastRound = async () => (await (await getAlgodClient()).status().do())['last-round'];\n\nexport const waitForConfirmation = async (txId, untilRound) => {\n  const algodClient = await getAlgodClient();\n  let lastRound = null;\n\n  do {\n    const lastRoundAfterCall = lastRound ? algodClient.statusAfterBlock(lastRound) : algodClient.status();\n    lastRound = (await lastRoundAfterCall.do())['last-round'];\n    const pendingInfo = await algodClient.pendingTransactionInformation(txId).do();\n    const confirmedRound = pendingInfo['confirmed-round'];\n\n    if (confirmedRound && confirmedRound > 0) {\n      return pendingInfo;\n    }\n  } while (!untilRound || lastRound < untilRound);\n\n  throw {\n    type: 'waitForConfirmation',\n    txId,\n    untilRound,\n    lastRound\n  };\n};\n\nconst sendAndConfirm = async stx_or_stxs => {\n  // @ts-ignore\n  let {\n    lastRound,\n    txID,\n    tx\n  } = stx_or_stxs;\n  let sendme = tx;\n\n  if (Array.isArray(stx_or_stxs)) {\n    if (stx_or_stxs.length === 0) {\n      debug(`Sending nothing... why...?`); // @ts-ignore\n\n      return null;\n    }\n\n    debug(`Sending multiple...`);\n    lastRound = stx_or_stxs[0].lastRound;\n    txID = stx_or_stxs[0].txID;\n    sendme = stx_or_stxs.map(stx => stx.tx);\n  }\n\n  const untilRound = lastRound;\n  const req = (await getAlgodClient()).sendRawTransaction(sendme); // @ts-ignore\n\n  debug('sendAndConfirm:', base64ify(req.txnBytesToPost));\n\n  try {\n    await req.do();\n  } catch (e) {\n    throw {\n      type: 'sendRawTransaction',\n      e\n    };\n  }\n\n  return await waitForConfirmation(txID, untilRound);\n}; // Backend\n\n\nconst compileTEAL = async (label, code) => {\n  debug('compile', label);\n  let s, r;\n\n  try {\n    r = await (await getAlgodClient()).compile(code).do();\n    s = 200;\n  } catch (e) {\n    s = typeof e === 'object' ? e.statusCode : 'not object';\n    r = e;\n  }\n\n  if (s == 200) {\n    debug('compile', label, 'succeeded:', r);\n    r.src = code;\n    r.result = base64ToUI8A(r.result); // debug('compile transformed:', r);\n\n    return r;\n  } else {\n    throw Error(`compile ${label} failed: ${s}: ${JSON.stringify(r)}`);\n  }\n};\n\nexport const getTxnParams = async () => {\n  debug(`fillTxn: getting params`);\n\n  while (true) {\n    const params = await (await getAlgodClient()).getTransactionParams().do();\n    debug('fillTxn: got params:', params);\n\n    if (params.firstRound !== 0) {\n      return params;\n    }\n\n    debug(`...but firstRound is 0, so let's wait and try again.`); // Assumption: firstRound will move past 0 on its own.\n\n    await Timeout.set(1000);\n  }\n};\n\nfunction regroup(thisAcc, txns) {\n  // Sorry this is so dumb.\n  // Basically, if these go thru AlgoSigner,\n  // it will mangle them,\n  //  so we need to recalculate the group hash.\n  if (thisAcc.AlgoSigner) {\n    const roundtrip_txns = txns.map(x => clean_for_AlgoSigner(x)).map(x => unclean_for_AlgoSigner(x)); // console.log(`deployP: group`);\n    // console.log(txns[0].group);\n    // console.log(Buffer.from(txns[0].group, 'base64').toString('base64'));\n    // console.log({...txns[0]});\n\n    algosdk.assignGroupID(roundtrip_txns); // console.log(`deploy: roundtrip group`);\n    // console.log(Buffer.from(roundtrip_txns[0].group, 'base64').toString('base64'));\n\n    const group = roundtrip_txns[0].group; // The same thing, but more paranoid:\n    // const group = Buffer.from(roundtrip_txns[0].group, 'base64').toString('base64');\n\n    for (const txn of txns) {\n      txn.group = group;\n    } // console.log({...txns[0]});\n\n\n    return roundtrip_txns;\n  } else {\n    return txns;\n  }\n} // A copy/paste of some logic from AlgoSigner\n// packages/extension/src/background/messaging/task.ts\n\n\nfunction unclean_for_AlgoSigner(txnOrig) {\n  const txn = { ...txnOrig\n  };\n  Object.keys({ ...txnOrig\n  }).forEach(key => {\n    if (txn[key] === undefined || txn[key] === null) {\n      delete txn[key];\n    }\n  }); // Modify base64 encoded fields\n\n  if ('note' in txn && txn.note !== undefined) {\n    txn.note = new Uint8Array(Buffer.from(txn.note));\n  } // Application transactions only\n\n\n  if (txn && txn.type === 'appl') {\n    if ('appApprovalProgram' in txn) {\n      txn.appApprovalProgram = base64ToUI8A(txn.appApprovalProgram);\n    }\n\n    if ('appClearProgram' in txn) {\n      txn.appClearProgram = base64ToUI8A(txn.appClearProgram);\n    }\n\n    if ('appArgs' in txn) {\n      var tempArgs = [];\n      txn.appArgs.forEach(element => {\n        tempArgs.push(base64ToUI8A(element));\n      });\n      txn.appArgs = tempArgs;\n    }\n  } // Note: this part is not copy/pasted from AlgoSigner,\n  // and isn't even strictly necessary,\n  // but it is nice for getting the same signatures from algosdk & AlgoSigner\n\n\n  if ('group' in txn) {\n    txn.group = base64ToUI8A(txn.group);\n  }\n\n  return txn;\n}\n\nconst clean_for_AlgoSigner = txnOrig => {\n  // Make a copy with just the properties, because reasons\n  const txn = { ...txnOrig\n  }; // AlgoSigner does weird things with fees if you don't specify flatFee\n\n  txn.flatFee = true; // \"Creation of PaymentTx has extra or invalid fields: name,tag,appArgs.\"\n\n  delete txn.name;\n  delete txn.tag; // uncaught (in promise) lease must be a Uint8Array.\n  // it is... but how about we just delete it instead\n  // This is presumed safe when lease is empty\n\n  if (txn.lease instanceof Uint8Array && txn.lease.length === 0) {\n    delete txn.lease;\n  } else {\n    console.log(txn.lease);\n    throw Error(`Impossible: non-empty lease`);\n  } // Creation of ApplTx has extra or invalid fields: nonParticipation\n\n\n  if (!txn.nonParticipation) {\n    delete txn.nonParticipation;\n  } else {\n    throw Error(`Impossible: expected falsy nonParticipation, got: ${txn.nonParticipation}`);\n  } // \"Creation of ApplTx has extra or invalid fields: name,tag.\"\n\n\n  if (txn.type !== 'appl') {\n    delete txn.appArgs;\n  } else {\n    if (txn.appArgs) {\n      if (txn.appArgs.length === 0) {\n        txn.appArgs = [];\n      } else {\n        txn.appArgs = txn.appArgs.map(arg => uint8ArrayToStr(arg, 'base64'));\n      }\n    }\n  } // Validation failed for transaction because of invalid properties [from,to]\n  // closeRemainderTo can cause an error w/ js-algorand-sdk addr parsing\n\n\n  for (const field of ['from', 'to', 'closeRemainderTo']) {\n    if (txn[field] && txn[field].publicKey) {\n      txn[field] = algosdk.encodeAddress(txn[field].publicKey);\n    }\n  } // Weirdly, AlgoSigner *requires* the note to be a string\n  // note is the only field that needs to be utf8-encoded, so far...\n\n\n  for (const field of ['note']) {\n    if (txn[field] && typeof txn[field] !== 'string') {\n      txn[field] = uint8ArrayToStr(txn[field], 'utf8');\n    }\n  } // Uncaught (in promise) First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\n  // No idea what it's talking about, but probably GenesisHash?\n  // And some more uint8Array BS\n\n\n  for (const field of ['genesisHash', 'appApprovalProgram', 'appClearProgram', 'group']) {\n    if (txn[field] && typeof txn[field] !== 'string') {\n      txn[field] = uint8ArrayToStr(txn[field], 'base64');\n    }\n  }\n\n  return txn;\n};\n\nconst sign_and_send_sync = async (label, networkAccount, txn) => {\n  const txn_s = await signTxn(networkAccount, txn);\n\n  try {\n    return await sendAndConfirm(txn_s);\n  } catch (e) {\n    console.log(e);\n    throw Error(`${label} txn failed:\\n${JSON.stringify(txn)}\\nwith:\\n${JSON.stringify(e)}`);\n  }\n}; // XXX I'd use x.replaceAll if I could (not supported in this node version), but it would be better to extend ConnectorInfo so these are functions\n\n\nconst replaceAll = (orig, what, whatp) => {\n  const once = orig.replace(what, whatp);\n\n  if (once === orig) {\n    return orig;\n  } else {\n    return replaceAll(once, what, whatp);\n  }\n};\n\nconst replaceUint8Array = (label, arr, x) => replaceAll(x, `\"{{${label}}}\"`, `base32(${base32.encode(arr).toString()})`);\n\nconst replaceAddr = (label, addr, x) => replaceUint8Array(label, algosdk.decodeAddress(addr).publicKey, x);\n\nfunction must_be_supported(bin) {\n  const algob = bin._Connectors.ALGO;\n  const {\n    unsupported\n  } = algob;\n\n  if (unsupported) {\n    throw Error(`This Reach application is not supported by Algorand.`);\n  }\n} // Get these from stdlib\n\n\nconst MaxTxnLife = 1000;\nconst LogicSigMaxSize = 1000;\nconst MaxAppArgs = 16;\nconst MaxAppTotalArgLen = 2048;\nconst MaxAppProgramLen = 1024;\n\nasync function compileFor(bin, info) {\n  const {\n    ApplicationID,\n    Deployer\n  } = info;\n  must_be_supported(bin);\n  const algob = bin._Connectors.ALGO;\n  const {\n    appApproval,\n    appClear,\n    ctc,\n    steps,\n    stepargs\n  } = algob;\n\n  const subst_appid = x => replaceUint8Array('ApplicationID', T_UInt.toNet(bigNumberify(ApplicationID)), x);\n\n  const subst_creator = x => replaceAddr('Deployer', Deployer, x);\n\n  const checkLen = (label, actual, expected) => {\n    debug(`checkLen`, {\n      label,\n      actual,\n      expected\n    });\n\n    if (actual > expected) {\n      throw Error(`This Reach application is not supported by Algorand: ${label} length is ${actual}, but should be less than ${expected}.`);\n    }\n  };\n\n  const ctc_bin = await compileTEAL('ctc_subst', subst_creator(subst_appid(ctc)));\n  checkLen(`Escrow Contract`, ctc_bin.result.length, LogicSigMaxSize);\n\n  const subst_ctc = x => replaceAddr('ContractAddr', ctc_bin.hash, x);\n\n  let appApproval_subst = appApproval;\n  const stepCode_bin = await Promise.all(steps.map(async (mc, mi) => {\n    if (!mc) {\n      return null;\n    }\n\n    const mN = `m${mi}`;\n    const mc_subst = subst_creator(subst_ctc(subst_appid(mc)));\n    const cr = await compileTEAL(mN, mc_subst);\n    checkLen(`${mN} Contract`, cr.result.length, LogicSigMaxSize);\n    const sa = stepargs[mi];\n\n    if (sa) {\n      checkLen(`${mN} Contract Arguments Count`, sa.count, MaxAppArgs);\n      checkLen(`${mN} Contract Arguments Length`, sa.size, MaxAppTotalArgLen);\n    }\n\n    appApproval_subst = replaceAddr(mN, cr.hash, appApproval_subst);\n    return cr;\n  }));\n  const appApproval_bin = await compileTEAL('appApproval_subst', appApproval_subst);\n  checkLen(`Approval Contract`, appApproval_bin.result.length, MaxAppProgramLen);\n  const appClear_bin = await compileTEAL('appClear', appClear);\n  checkLen(`Clear Contract`, appClear_bin.result.length, MaxAppProgramLen);\n  return {\n    appApproval: appApproval_bin,\n    appClear: appClear_bin,\n    ctc: ctc_bin,\n    steps: stepCode_bin\n  };\n}\n\nconst ui8z = new Uint8Array();\n\nconst base64ToUI8A = x => Uint8Array.from(Buffer.from(x, 'base64'));\n\nconst base64ify = x => Buffer.from(x).toString('base64');\n\nconst format_failed_request = e => {\n  const ep = JSON.parse(JSON.stringify(e));\n  const db64 = ep.req ? ep.req.data ? base64ify(ep.req.data) : `no data, but ${JSON.stringify(Object.keys(ep.req))}` : `no req, but ${JSON.stringify(Object.keys(ep))}`;\n  const msg = e.text ? JSON.parse(e.text) : e;\n  return `\\n${db64}\\n${JSON.stringify(msg)}`;\n};\n\nconst doQuery_ = async (dhead, query) => {\n  debug(dhead, '--- QUERY =', query);\n  let res;\n\n  try {\n    res = await query.do();\n  } catch (e) {\n    throw Error(`${dhead} --- QUERY FAIL: ${JSON.stringify(e)}`);\n  }\n\n  debug(dhead, '--- RESULT =', res);\n  return res;\n};\n\nconst doQuery = async (dhead, query) => {\n  const res = await doQuery_(dhead, query);\n\n  if (res.transactions.length == 0) {\n    // XXX Look at the round in res and wait for a new round\n    return null;\n  }\n\n  const txn = res.transactions[0];\n  return txn;\n}; // ****************************************************************************\n// Common Interface Exports\n// ****************************************************************************\n\n\nexport const {\n  addressEq,\n  digest\n} = compiledStdlib;\nexport const {\n  T_Null,\n  T_Bool,\n  T_UInt,\n  T_Tuple,\n  T_Array,\n  T_Object,\n  T_Data,\n  T_Bytes,\n  T_Address,\n  T_Digest,\n  T_Struct\n} = typeDefs;\nexport const {\n  randomUInt,\n  hasRandom\n} = makeRandom(8);\nexport const [getLedger, setLedger] = replaceableThunk(() => DEFAULT_ALGO_LEDGER);\n\nfunction getLedgerFromAlgoSigner(AlgoSigner) {\n  // XXX: get AlgoSigner to tell us what Ledger is \"currently selected\"\n  // since that ability doesn't actually exist, we operate based off of setLedger()\n  void AlgoSigner;\n  return getLedger();\n}\n\nasync function waitIndexerFromEnv(env) {\n  const {\n    ALGO_INDEXER_SERVER,\n    ALGO_INDEXER_PORT,\n    ALGO_INDEXER_TOKEN\n  } = env;\n  await wait1port(ALGO_INDEXER_SERVER, ALGO_INDEXER_PORT);\n  return new algosdk.Indexer(ALGO_INDEXER_TOKEN, ALGO_INDEXER_SERVER, ALGO_INDEXER_PORT);\n}\n\nasync function waitAlgodClientFromEnv(env) {\n  const {\n    ALGO_SERVER,\n    ALGO_PORT,\n    ALGO_TOKEN\n  } = env;\n  await wait1port(ALGO_SERVER, ALGO_PORT);\n  return new algosdk.Algodv2(ALGO_TOKEN, ALGO_SERVER, ALGO_PORT);\n} // TODO: read token from scripts/algorand-devnet/algorand_data/algod.token\n\n\nexport const [getAlgodClient, setAlgodClient] = replaceableThunk(async () => {\n  debug(`Setting algod client to default`);\n  return await waitAlgodClientFromEnv(envDefaultsALGO(process.env));\n});\nexport const [getIndexer, setIndexer] = replaceableThunk(async () => {\n  debug(`setting indexer to default`);\n  return await waitIndexerFromEnv(envDefaultsALGO(process.env));\n});\nexport async function getProvider() {\n  return {\n    algodClient: await getAlgodClient(),\n    indexer: await getIndexer(),\n    ledger: getLedger()\n  };\n}\nexport async function setProvider(provider) {\n  provider = await provider; // XXX doesn't waitPort these, because these are opaque to us.\n  // should we do something similar where we wait for /health to give us a 200 response?\n\n  setAlgodClient((async () => provider.algodClient)());\n  setIndexer((async () => provider.indexer)());\n  setLedger(provider.ledger);\n}\nconst localhostProviderEnv = {\n  ALGO_LEDGER: 'Reach Devnet',\n  ALGO_SERVER: 'http://localhost',\n  ALGO_PORT: '4180',\n  ALGO_TOKEN: rawDefaultToken,\n  ALGO_INDEXER_SERVER: 'http://localhost',\n  ALGO_INDEXER_PORT: '8980',\n  ALGO_INDEXER_TOKEN: rawDefaultItoken\n};\nconst DEFAULT_ALGO_LEDGER = localhostProviderEnv.ALGO_LEDGER;\nconst DEFAULT_ALGO_SERVER = localhostProviderEnv.ALGO_SERVER;\nconst DEFAULT_ALGO_PORT = localhostProviderEnv.ALGO_PORT;\nconst DEFAULT_ALGO_TOKEN = localhostProviderEnv.ALGO_TOKEN;\nconst DEFAULT_ALGO_INDEXER_SERVER = localhostProviderEnv.ALGO_INDEXER_SERVER;\nconst DEFAULT_ALGO_INDEXER_PORT = localhostProviderEnv.ALGO_INDEXER_PORT;\nconst DEFAULT_ALGO_INDEXER_TOKEN = localhostProviderEnv.ALGO_INDEXER_TOKEN;\n\nfunction serverLooksLikeRandlabs(server) {\n  return server.toLowerCase().includes('algoexplorerapi.io');\n}\n\nfunction envDefaultALGOPort(port, defaultPort, server) {\n  // Some simple guessing\n  return port !== undefined ? port : serverLooksLikeRandlabs(server) ? '' : defaultPort;\n}\n\nfunction envDefaultALGOToken(token, defaultToken, server, port) {\n  // Some simple guessing\n  // port is not currently used for this guessing, but could be in the future\n  void port;\n  return token !== undefined ? token : serverLooksLikeRandlabs(server) ? '' : defaultToken;\n}\n\nfunction guessRandlabsLedger(server) {\n  if (server === undefined) return undefined;\n  server = server.toLowerCase();\n\n  if (server.startsWith('https://algoexplorerapi.io')) {\n    return 'MainNet';\n  } else if (server.startsWith('https://testnet.algoexplorerapi.io')) {\n    return 'TestNet';\n  } else if (server.startsWith('https://betanet.algoexplorerapi.io')) {\n    return 'BetaNet';\n  }\n\n  return undefined;\n}\n\nfunction envDefaultALGOLedger(ledger, defaultLedger, server, port) {\n  // Some simple guessing\n  // port is not currently used for this guessing, but could be in the future\n  void port;\n  return ledger !== undefined ? ledger : serverLooksLikeRandlabs(server) ? guessRandlabsLedger(ledger) : defaultLedger;\n}\n\nfunction envDefaultsALGO(env) {\n  const ALGO_SERVER = envDefault(env.ALGO_SERVER, DEFAULT_ALGO_SERVER);\n  const ALGO_PORT = envDefaultALGOPort(env.ALGO_PORT, DEFAULT_ALGO_PORT, ALGO_SERVER);\n  const ALGO_TOKEN = envDefaultALGOToken(env.ALGO_TOKEN, DEFAULT_ALGO_TOKEN, ALGO_SERVER, ALGO_PORT);\n  const ALGO_LEDGER = envDefaultALGOLedger(env.ALGO_LEDGER, DEFAULT_ALGO_LEDGER, ALGO_SERVER, ALGO_PORT);\n  const ALGO_INDEXER_SERVER = envDefault(env.ALGO_INDEXER_SERVER, DEFAULT_ALGO_INDEXER_SERVER);\n  const ALGO_INDEXER_PORT = envDefaultALGOPort(env.ALGO_INDEXER_PORT, DEFAULT_ALGO_INDEXER_PORT, ALGO_INDEXER_SERVER);\n  const ALGO_INDEXER_TOKEN = envDefaultALGOToken(env.ALGO_INDEXER_TOKEN, DEFAULT_ALGO_INDEXER_TOKEN, ALGO_INDEXER_SERVER, ALGO_INDEXER_PORT);\n  return {\n    ALGO_LEDGER,\n    ALGO_SERVER,\n    ALGO_PORT,\n    ALGO_TOKEN,\n    ALGO_INDEXER_SERVER,\n    ALGO_INDEXER_PORT,\n    ALGO_INDEXER_TOKEN\n  };\n}\n\nexport function setProviderByEnv(env) {\n  // Note: This doesn't just immediately call setProviderByEnv,\n  // because here we can actually take the opportunity to wait1port.\n  const fullEnv = envDefaultsALGO(env);\n  setAlgodClient(waitAlgodClientFromEnv(fullEnv));\n  setIndexer(waitIndexerFromEnv(fullEnv));\n  setLedger(fullEnv.ALGO_LEDGER);\n}\n\nfunction randlabsProviderEnv(ALGO_LEDGER) {\n  const prefix = ALGO_LEDGER === 'MainNet' ? '' : `${ALGO_LEDGER.toLowerCase()}.`;\n  const RANDLABS_BASE = `https://${prefix}algoexplorerapi.io`;\n  return {\n    ALGO_LEDGER,\n    ALGO_SERVER: RANDLABS_BASE,\n    ALGO_PORT: '',\n    ALGO_TOKEN: '',\n    ALGO_INDEXER_SERVER: `${RANDLABS_BASE}/idx2`,\n    ALGO_INDEXER_PORT: '',\n    ALGO_INDEXER_TOKEN: ''\n  };\n}\n\nexport function providerEnvByName(providerName) {\n  switch (providerName) {\n    case 'MainNet':\n      return randlabsProviderEnv('MainNet');\n\n    case 'TestNet':\n      return randlabsProviderEnv('TestNet');\n\n    case 'BetaNet':\n      return randlabsProviderEnv('BetaNet');\n\n    case 'randlabs/MainNet':\n      return randlabsProviderEnv('MainNet');\n\n    case 'randlabs/TestNet':\n      return randlabsProviderEnv('TestNet');\n\n    case 'randlabs/BetaNet':\n      return randlabsProviderEnv('BetaNet');\n\n    case 'LocalHost':\n      return localhostProviderEnv;\n\n    default:\n      throw Error(`Unrecognized provider name: ${providerName}`);\n  }\n}\nexport function setProviderByName(providerName) {\n  return setProviderByEnv(providerEnvByName(providerName));\n} // eslint-disable-next-line max-len\n\nconst rawFaucetDefaultMnemonic = 'husband sock drift razor piece february loop nose crew object salon come sketch frost grocery capital young strategy catalog dial seminar sword betray absent army';\nconst [getFaucet, setFaucet] = replaceableThunk(async () => {\n  const ledger = getLedger();\n\n  if (ledger !== localhostProviderEnv.ALGO_LEDGER) {\n    throw Error(`Cannot automatically use faucet for ledger '${ledger}'; if you want to use a custom faucet, use setFaucet`);\n  }\n\n  const FAUCET = algosdk.mnemonicToSecretKey(envDefault(process.env.ALGO_FAUCET_PASSPHRASE, rawFaucetDefaultMnemonic));\n  return await connectAccount(FAUCET);\n});\nexport { getFaucet, setFaucet };\n\nconst makeTransferTxn = (from, to, value, token, ps, closeTo = undefined) => {\n  const valuen = bigNumberToNumber(value); // XXX AlgoSigner doesn't correctly handle msgpacked notes\n  // When it does: update {,un}clean_for_AlgoSigner\n  // const note = algosdk.encodeObj('Reach');\n\n  const note = new Uint8Array(Buffer.from('Reach'));\n  const txn = token ? algosdk.makeAssetTransferTxnWithSuggestedParams(from, to, closeTo, undefined, valuen, ui8z, bigNumberToNumber(token), ps) : algosdk.makePaymentTxnWithSuggestedParams(from, to, valuen, closeTo, note, ps);\n  return txn;\n};\n\nexport const transfer = async (from, to, value, token = undefined) => {\n  const sender = from.networkAccount;\n  const receiver = to.networkAccount.addr;\n  const valuebn = bigNumberify(value);\n  const ps = await getTxnParams();\n  const txn = makeTransferTxn(sender.addr, receiver, valuebn, token, ps);\n  return await sign_and_send_sync(`transfer ${JSON.stringify(from)} ${JSON.stringify(to)} ${valuebn}`, sender, txn);\n};\n\nasync function signTxn(networkAccount, txnOrig) {\n  const {\n    sk,\n    AlgoSigner\n  } = networkAccount;\n\n  if (sk && !AlgoSigner) {\n    const tx = txnOrig.signTxn(sk);\n    const ret = {\n      tx,\n      txID: txnOrig.txID().toString(),\n      lastRound: txnOrig.lastRound\n    };\n    debug('signed sk_ret');\n    debug({\n      txID: ret.txID\n    });\n    debug(msgpack.decode(ret.tx));\n    return ret;\n  } else if (AlgoSigner) {\n    // TODO: clean up txn before signing\n    const txn = clean_for_AlgoSigner(txnOrig); // Note: don't delete the following,\n    // it is extremely useful for debugging when stuff changes wrt AlgoSigner/algosdk clashes\n    // if (sk) {\n    //   const re_tx = txnOrig.signTxn ? txnOrig : new algosdk__src__transaction.Transaction(txnOrig);\n    //   re_tx.group = txnOrig.group;\n    //   const sk_tx = re_tx.signTxn(sk);\n    //   const sk_ret = {\n    //     tx: sk_tx,\n    //     txID: re_tx.txID().toString(),\n    //     lastRound: txnOrig.lastRound,\n    //   };\n    //   console.log('signed sk_ret');\n    //   console.log({txID: sk_ret.txID});\n    //   console.log(msgpack.decode(sk_ret.tx));\n    // }\n\n    debug('AlgoSigner.sign ...');\n    const stx_obj = await AlgoSigner.sign(txn);\n    debug('...signed');\n    debug({\n      stx_obj\n    });\n    const ret = {\n      tx: Buffer.from(stx_obj.blob, 'base64'),\n      txID: stx_obj.txID,\n      lastRound: txnOrig.lastRound\n    };\n    debug('signed AlgoSigner');\n    debug({\n      txID: ret.txID\n    });\n    debug(msgpack.decode(ret.tx));\n    return ret;\n  } else {\n    throw Error(`networkAccount has neither sk nor AlgoSigner: ${JSON.stringify(networkAccount)}`);\n  }\n}\n\nexport const connectAccount = async networkAccount => {\n  const indexer = await getIndexer();\n  const thisAcc = networkAccount;\n  const shad = thisAcc.addr.substring(2, 6);\n  let label = shad;\n  const pks = T_Address.canonicalize(thisAcc);\n  debug(shad, ': connectAccount');\n\n  const selfAddress = () => {\n    return pks;\n  };\n\n  const iam = some_addr => {\n    if (some_addr === pks) {\n      return some_addr;\n    } else {\n      throw Error(`I should be ${some_addr}, but am ${pks}`);\n    }\n  };\n\n  const attachP = async (bin, ctcInfoP) => {\n    const ctcInfo = await ctcInfoP;\n\n    const getInfo = async () => ctcInfo;\n\n    const {\n      Deployer,\n      ApplicationID\n    } = ctcInfo;\n    let lastRound = ctcInfo.creationRound;\n    debug(shad, ': attach', ApplicationID, 'created at', lastRound);\n    const bin_comp = await compileFor(bin, ctcInfo);\n    const escrowAddr = bin_comp.ctc.hash;\n    void addressToHex; // XXX const escrowAddrRaw = T_Address.canonicalize(addressToHex(escrowAddr));\n\n    await verifyContract(ctcInfo, bin);\n    const ctc_prog = algosdk.makeLogicSig(bin_comp.ctc.result, []);\n\n    const wait = async delta => {\n      return await waitUntilTime(bigNumberify(lastRound).add(delta));\n    };\n\n    const sendrecv = async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay, sim_p) => {\n      if (hasLastTime !== false) {\n        const ltidx = hasLastTime.toNumber();\n        tys.splice(ltidx, 1);\n        args.splice(ltidx, 1);\n      }\n\n      const doRecv = async waitIfNotPresent => await recv(funcNum, evt_cnt, out_tys, waitIfNotPresent, timeout_delay);\n\n      if (!onlyIf) {\n        return await doRecv(true);\n      }\n\n      const [value, toks] = pay;\n      void toks; // <-- rely on simulation because of ordering\n\n      const funcName = `m${funcNum}`;\n      const dhead = `${shad}: ${label} sendrecv ${funcName} ${timeout_delay}`;\n      debug(dhead, '--- START');\n      const handler = bin_comp.steps[funcNum];\n\n      if (!handler) {\n        throw Error(`${dhead} Internal error: reference to undefined handler: ${funcName}`);\n      }\n\n      const fake_res = {\n        didTimeout: false,\n        data: argsSlice(args, evt_cnt),\n        time: bigNumberify(0),\n        value: value,\n        from: pks,\n        getOutput: async (o_lab, o_ctc) => {\n          void o_lab;\n          void o_ctc;\n          throw Error(`Algorand does not support remote calls, and Reach should not have generated a call to this function`);\n        }\n      };\n      const sim_r = await sim_p(fake_res);\n      debug(dhead, '--- SIMULATE', sim_r);\n      const isHalt = sim_r.isHalt;\n      const sim_txns = sim_r.txns;\n      const [view_ty, view_v] = sim_r.view;\n      debug(dhead, 'VIEW', {\n        view_ty,\n        view_v\n      });\n\n      while (true) {\n        const params = await getTxnParams();\n\n        if (timeout_delay) {\n          const tdn = Math.min(MaxTxnLife, timeout_delay.toNumber());\n          params.lastRound = lastRound + tdn;\n\n          if (params.firstRound > params.lastRound) {\n            debug(dhead, '--- FAIL/TIMEOUT');\n            return {\n              didTimeout: true\n            };\n          }\n        }\n\n        debug(dhead, '--- ASSEMBLE w/', params);\n        let txnToContract_value_idx = -1;\n        let totalFromFee = 0;\n        const txnExtraTxns = sim_txns.map((t, i) => {\n          const {\n            tok\n          } = t;\n          let amt = bigNumberify(0);\n          let from = escrowAddr;\n          let to = escrowAddr;\n          let closeTo = undefined;\n\n          if (t.kind === 'from') {\n            from = escrowAddr; // @ts-ignore\n\n            const tto = t.to; // XXX use some other function\n\n            to = algosdk.encodeAddress(Buffer.from(tto.slice(2), 'hex'));\n            amt = t.amt;\n          } else if (t.kind === 'init') {\n            from = escrowAddr;\n            to = escrowAddr;\n            totalFromFee += raw_minimumBalance;\n            amt = t.amt;\n          } else if (t.kind === 'halt') {\n            from = escrowAddr;\n            to = Deployer;\n            closeTo = Deployer;\n          } else if (t.kind === 'to') {\n            from = thisAcc.addr;\n            to = escrowAddr;\n            amt = t.amt;\n          } else {\n            assert(false, 'sim txn kind');\n          }\n\n          const txn = makeTransferTxn(from, to, amt, tok, params, closeTo);\n\n          if (from === escrowAddr) {\n            totalFromFee += txn.fee;\n          }\n\n          if (t.kind === 'to' && !tok) {\n            txnToContract_value_idx = i;\n          }\n\n          return txn;\n        });\n        debug(dhead, '--- totalFromFee =', totalFromFee);\n        assert(txnToContract_value_idx !== -1, 'sim txn no value');\n        txnExtraTxns[txnToContract_value_idx] = makeTransferTxn(thisAcc.addr, escrowAddr, value.add(totalFromFee), undefined, params);\n        const actual_args = [sim_r.prevSt_noPrevTime, sim_r.nextSt_noTime, view_v, isHalt, bigNumberify(totalFromFee), lastRound, ...args];\n        const actual_tys = [T_Digest, T_Digest, view_ty, T_Bool, T_UInt, T_UInt, ...tys];\n        debug(dhead, '--- ARGS =', actual_args);\n        const safe_args = actual_args.map((m, i) => actual_tys[i].toNet(m));\n        safe_args.forEach(x => {\n          if (!(x instanceof Uint8Array)) {\n            // The types say this is impossible now,\n            // but we'll leave it in for a while just in case...\n            throw Error(`expect safe program argument, got ${JSON.stringify(x)}`);\n          }\n        });\n\n        const ui8h = x => Buffer.from(x).toString('hex');\n\n        debug(dhead, '--- PREPARE:', safe_args.map(ui8h));\n        const handler_sig = algosdk.makeLogicSig(handler.result, []);\n        debug(dhead, '--- PREPARED');\n        const whichAppl = isHalt ? // We are treating it like any party can delete the application, but the docs say it may only be possible for the creator. The code appears to not care: https://github.com/algorand/go-algorand/blob/0e9cc6b0c2ddc43c3cfa751d61c1321d8707c0da/ledger/apply/application.go#L589\n        algosdk.makeApplicationDeleteTxn : algosdk.makeApplicationNoOpTxn;\n        const txnAppl = whichAppl(thisAcc.addr, params, ApplicationID, safe_args);\n        const txnFromHandler = algosdk.makePaymentTxnWithSuggestedParams(handler.hash, thisAcc.addr, 0, thisAcc.addr, ui8z, params);\n        debug(dhead, '--- txnFromHandler =', txnFromHandler);\n        const txnToHandler = algosdk.makePaymentTxnWithSuggestedParams(thisAcc.addr, handler.hash, txnFromHandler.fee + raw_minimumBalance, undefined, ui8z, params);\n        debug(dhead, '--- txnToHandler =', txnToHandler);\n        const txns = [txnAppl, txnToHandler, txnFromHandler, ...txnExtraTxns];\n        algosdk.assignGroupID(txns);\n        regroup(thisAcc, txns);\n\n        const signLSTO = (txn, ls) => {\n          const tx_obj = algosdk.signLogicSigTransactionObject(txn, ls);\n          return {\n            tx: tx_obj.blob,\n            txID: tx_obj.txID,\n            lastRound: txn.lastRound\n          };\n        };\n\n        const sign_me = async x => await signTxn(thisAcc, x);\n\n        const txnAppl_s = await sign_me(txnAppl);\n        const txnFromHandler_s = signLSTO(txnFromHandler, handler_sig);\n        const txnToHandler_s = await sign_me(txnToHandler);\n        const txnExtraTxns_s = await Promise.all(txnExtraTxns.map(async (t, i) => {\n          const st = sim_txns[i];\n          debug('txnExtraTxns_s', {\n            t,\n            i,\n            st\n          });\n          const t_s = st.kind === 'to' ? await sign_me(t) : signLSTO(t, ctc_prog);\n          return t_s;\n        }));\n        const txns_s = [txnAppl_s, txnToHandler_s, txnFromHandler_s, ...txnExtraTxns_s];\n        debug(dhead, '--- SEND:', txns_s.length);\n        let res;\n\n        try {\n          res = await sendAndConfirm(txns_s); // XXX we should inspect res and if we failed because we didn't get picked out of the queue, then we shouldn't error, but should retry and let the timeout logic happen.\n\n          debug(dhead, '--- SUCCESS:', res);\n        } catch (e) {\n          if (e.type == 'sendRawTransaction') {\n            if (!soloSend) {\n              debug(dhead, '--- FAIL:', format_failed_request(e.e));\n            } else {\n              throw Error(`${dhead} --- FAIL:\\n${format_failed_request(e.e)}`);\n            }\n          } else {\n            if (!soloSend) {\n              debug(dhead, '--- FAIL:', e);\n            } else {\n              throw Error(`${dhead} --- FAIL:\\n${JSON.stringify(e)}`);\n            }\n          }\n        }\n\n        return await doRecv(false);\n      }\n    };\n\n    const recv = async (funcNum, evt_cnt, tys, waitIfNotPresent, timeout_delay) => {\n      // Ignoring this, because no ALGO dev node\n      void waitIfNotPresent;\n      const funcName = `m${funcNum}`;\n      const dhead = `${shad}: ${label} recv ${funcName} ${timeout_delay}`;\n      debug(dhead, '--- START');\n      const handler = bin_comp.steps[funcNum];\n\n      if (!handler) {\n        throw Error(`${dhead} Internal error: reference to undefined handler: ${funcName}`);\n      }\n\n      const timeoutRound = timeout_delay ? lastRound + timeout_delay.toNumber() : undefined;\n\n      while (true) {\n        const currentRound = await getLastRound();\n\n        if (timeoutRound && timeoutRound < currentRound) {\n          return {\n            didTimeout: true\n          };\n        }\n\n        let hquery = indexer.searchForTransactions().address(handler.hash).addressRole('sender') // Look at the next one after the last message\n        // XXX when we implement firstMsg, this won't work on the first\n        // message\n        .minRound(lastRound + 1);\n\n        if (timeoutRound) {\n          hquery = hquery.maxRound(timeoutRound);\n        }\n\n        const htxn = await doQuery(dhead, hquery);\n\n        if (!htxn) {\n          // XXX perhaps wait until a new round has happened using wait\n          await Timeout.set(2000);\n          continue;\n        }\n\n        debug(dhead, '--- htxn =', htxn);\n        const theRound = htxn['confirmed-round'];\n        let query = indexer.searchForTransactions().applicationID(ApplicationID).txType('appl').round(theRound);\n        const txn = await doQuery(dhead, query);\n\n        if (!txn) {\n          // XXX This is probably really bad\n          continue;\n        }\n\n        debug(dhead, '--- txn =', txn);\n        const ctc_args = txn['application-transaction']['application-args'];\n        debug(dhead, '--- ctc_args =', ctc_args);\n        const args = argsSlice(ctc_args, evt_cnt);\n        debug(dhead, '--- args =', args);\n        /** @description base64->hex->arrayify */\n\n        const reNetify = x => {\n          const s = Buffer.from(x, 'base64').toString('hex');\n          debug(dhead, '--- reNetify(', x, ') = ', s);\n          return ethers.utils.arrayify('0x' + s);\n        };\n\n        debug(dhead, '--- tys =', tys);\n        const args_un = args.map((x, i) => tys[i].fromNet(reNetify(x)));\n        debug(dhead, '--- args_un =', args_un);\n        const totalFromFee = T_UInt.fromNet(reNetify(ctc_args[3]));\n        debug(dhead, '--- totalFromFee =', totalFromFee);\n        const fromAddr = htxn['payment-transaction'].receiver;\n        const from = T_Address.canonicalize({\n          addr: fromAddr\n        });\n        debug(dhead, '--- from =', from, '=', fromAddr);\n        const oldLastRound = lastRound;\n        lastRound = theRound;\n        debug(dhead, '--- updating round from', oldLastRound, 'to', lastRound);\n\n        const getOutput = (o_lab, o_ctc) => {\n          void o_lab;\n          void o_ctc;\n          throw Error(`Algorand does not support remote calls`);\n        };\n\n        return {\n          didTimeout: false,\n          data: args_un,\n          time: bigNumberify(lastRound),\n          from,\n          getOutput\n        };\n      }\n    };\n\n    const creationTime = async () => bigNumberify((await getInfo()).creationRound);\n\n    const views_bin = bin._getViews({\n      reachStdlib: compiledStdlib\n    });\n\n    const getView1 = (vs, v, k, vim) => async () => {\n      void v;\n      void k;\n      const {\n        decode\n      } = vim;\n      const client = await getAlgodClient();\n      const appInfo = await client.getApplicationByID(ApplicationID).do();\n      const appSt = appInfo['params']['global-state'];\n      const viewSt = appSt.find(x => x.key === 'dg==').value;\n      debug({\n        viewSt\n      });\n      const vvn = base64ToUI8A(viewSt.bytes);\n      debug({\n        vvn\n      });\n      const vin = T_UInt.fromNet(vvn.slice(0, T_UInt.netSize));\n      const vi = bigNumberToNumber(vin);\n      debug({\n        vi\n      });\n      const vtys = vs[vi];\n      debug({\n        vtys\n      });\n      const vty = T_Tuple([T_UInt, ...vtys]);\n      debug({\n        vty\n      });\n      const vvs = vty.fromNet(vvn);\n      debug({\n        vvs\n      });\n      const vres = decode(vi, vvs.slice(1));\n      debug({\n        vres\n      });\n      return vres;\n    };\n\n    const getViews = getViewsHelper(views_bin, getView1);\n    return {\n      getInfo,\n      creationTime,\n      sendrecv,\n      recv,\n      wait,\n      iam,\n      selfAddress,\n      getViews,\n      stdlib: compiledStdlib\n    };\n  };\n\n  const deployP = async bin => {\n    must_be_supported(bin);\n    debug(shad, 'deploy');\n    const algob = bin._Connectors.ALGO;\n    const {\n      appApproval0,\n      appClear\n    } = algob;\n    const Deployer = thisAcc.addr;\n    const appApproval0_subst = replaceAddr('Deployer', Deployer, appApproval0);\n    const appApproval0_bin = await compileTEAL('appApproval0', appApproval0_subst);\n    const appClear_bin = await compileTEAL('appClear', appClear);\n    const createRes = await sign_and_send_sync('ApplicationCreate', thisAcc, algosdk.makeApplicationCreateTxn(thisAcc.addr, await getTxnParams(), algosdk.OnApplicationComplete.NoOpOC, appApproval0_bin.result, appClear_bin.result, 0, 0, 2, 2));\n    const ApplicationID = createRes['application-index'];\n\n    if (!ApplicationID) {\n      throw Error(`No application-index in ${JSON.stringify(createRes)}`);\n    }\n\n    const bin_comp = await compileFor(bin, {\n      ApplicationID,\n      Deployer,\n      creationRound: 0\n    });\n    const escrowAddr = bin_comp.ctc.hash;\n    const params = await getTxnParams();\n    const txnUpdate = algosdk.makeApplicationUpdateTxn(thisAcc.addr, params, ApplicationID, bin_comp.appApproval.result, appClear_bin.result);\n    const txnToContract = algosdk.makePaymentTxnWithSuggestedParams(thisAcc.addr, escrowAddr, raw_minimumBalance, undefined, ui8z, params);\n    const txns = [txnUpdate, txnToContract];\n    algosdk.assignGroupID(txns);\n    regroup(thisAcc, txns);\n    const txnUpdate_s = await signTxn(thisAcc, txnUpdate);\n    const txnToContract_s = await signTxn(thisAcc, txnToContract);\n    const txns_s = [txnUpdate_s, txnToContract_s];\n    let updateRes;\n\n    try {\n      updateRes = await sendAndConfirm(txns_s);\n    } catch (e) {\n      throw Error(`deploy: ${JSON.stringify(e)}`);\n    }\n\n    const creationRound = updateRes['confirmed-round'];\n\n    const getInfo = async () => ({\n      ApplicationID,\n      creationRound,\n      Deployer\n    });\n\n    debug(shad, 'application created');\n    return await attachP(bin, getInfo());\n  };\n\n  const implNow = {\n    stdlib: compiledStdlib\n  };\n\n  const attach = (bin, ctcInfoP) => {\n    return deferContract(false, attachP(bin, ctcInfoP), implNow);\n  };\n\n  const deploy = bin => {\n    return deferContract(false, deployP(bin), implNow);\n  };\n\n  function setDebugLabel(newLabel) {\n    label = newLabel; // @ts-ignore\n\n    return this;\n  }\n\n  return {\n    deploy,\n    attach,\n    networkAccount,\n    getAddress: selfAddress,\n    stdlib: compiledStdlib,\n    setDebugLabel\n  };\n};\nexport const balanceOf = async acc => {\n  const {\n    networkAccount\n  } = acc;\n  if (!networkAccount) throw Error(`acc.networkAccount missing. Got: ${acc}`);\n  const client = await getAlgodClient();\n  const {\n    amount\n  } = await client.accountInformation(networkAccount.addr).do();\n  return bigNumberify(amount);\n};\nexport const createAccount = async () => {\n  const networkAccount = algosdk.generateAccount();\n  return await connectAccount(networkAccount);\n};\nexport const fundFromFaucet = async (account, value) => {\n  const faucet = await getFaucet();\n  await transfer(faucet, account, value);\n};\nexport const newTestAccount = async startingBalance => {\n  const account = await createAccount();\n  await fundFromFaucet(account, startingBalance);\n  return account;\n};\n/** @description the display name of the standard unit of currency for the network */\n\nexport const standardUnit = 'ALGO';\n/** @description the display name of the atomic (smallest) unit of currency for the network */\n\nexport const atomicUnit = 'Î¼ALGO';\n/**\n * @description  Parse currency by network\n * @param amt  value in the {@link standardUnit} for the network.\n * @returns  the amount in the {@link atomicUnit} of the network.\n * @example  parseCurrency(100).toString() // => '100000000'\n */\n\nexport function parseCurrency(amt) {\n  const numericAmt = isBigNumber(amt) ? amt.toNumber() : typeof amt === 'string' ? parseFloat(amt) : amt;\n  return bigNumberify(algosdk.algosToMicroalgos(numericAmt));\n} // XXX get from SDK\n\nconst raw_minimumBalance = 100000;\nexport const minimumBalance = bigNumberify(raw_minimumBalance);\n/**\n * @description  Format currency by network\n * @param amt  the amount in the {@link atomicUnit} of the network.\n * @param decimals  up to how many decimal places to display in the {@link standardUnit}.\n *   Trailing zeroes will be omitted. Excess decimal places will be truncated. (not rounded)\n *   This argument defaults to maximum precision.\n * @returns  a string representation of that amount in the {@link standardUnit} for that network.\n * @example  formatCurrency(bigNumberify('100000000')); // => '100'\n */\n\nexport function formatCurrency(amt, decimals = 6) {\n  // Recall that 1 algo = 10^6 microalgos\n  if (!(Number.isInteger(decimals) && 0 <= decimals)) {\n    throw Error(`Expected decimals to be a nonnegative integer, but got ${decimals}.`);\n  } // Use decimals+1 and then slice it off to truncate instead of round\n\n\n  const algosStr = algosdk.microalgosToAlgos(bigNumberify(amt).toNumber()).toFixed(decimals + 1); // Have to roundtrip thru Number to drop trailing zeroes\n\n  return Number(algosStr.slice(0, algosStr.length - 1)).toString();\n} // XXX The getDefaultAccount pattern doesn't really work w/ AlgoSigner\n// AlgoSigner does not expose a \"currently-selected account\"\n\nexport async function getDefaultAccount() {\n  if (!window.prompt) {\n    throw Error(`Cannot prompt the user for default account with window.prompt`);\n  }\n\n  const signStrategy = getSignStrategy();\n\n  if (signStrategy === 'mnemonic') {\n    const mnemonic = window.prompt(`Please paste the mnemonic for your account, or cancel to generate a new one`);\n\n    if (mnemonic) {\n      debug(`Creating account from user-provided mnemonic`);\n      return await newAccountFromMnemonic(mnemonic);\n    } else {\n      debug(`No mnemonic provided. Randomly generating a new account secret instead.`);\n      return await createAccount();\n    }\n  } else if (signStrategy === 'AlgoSigner') {\n    const AlgoSigner = await getAlgoSigner();\n    const ledger = getLedgerFromAlgoSigner(AlgoSigner);\n    if (ledger === undefined) throw Error(`Ledger is undefined; this is required by AlgoSigner`);\n    const addr = window.prompt(`Please paste your account's address. (This account must be listed in AlgoSigner.)`);\n\n    if (!addr) {\n      throw Error(`No address provided`);\n    }\n\n    return await newAccountFromAlgoSigner(addr, AlgoSigner, ledger);\n  } else if (signStrategy === 'MyAlgo') {\n    throw Error(`MyAlgo wallet support is not yet implemented`);\n  } else {\n    throw Error(`signStrategy '${signStrategy}' not recognized. Valid options are 'mnemonic', 'AlgoSigner', and 'MyAlgo'.`);\n  }\n}\n/**\n * @param mnemonic 25 words, space-separated\n */\n\nexport const newAccountFromMnemonic = async mnemonic => {\n  return await connectAccount(algosdk.mnemonicToSecretKey(mnemonic));\n};\n/**\n * @param secret a Uint8Array, or its hex string representation\n */\n\nexport const newAccountFromSecret = async secret => {\n  const sk = ethers.utils.arrayify(secret);\n  const mnemonic = algosdk.secretKeyToMnemonic(sk);\n  return await newAccountFromMnemonic(mnemonic);\n};\nexport const newAccountFromAlgoSigner = async (addr, AlgoSigner, ledger) => {\n  if (!AlgoSigner) {\n    throw Error(`AlgoSigner is falsy`);\n  }\n\n  const accts = await AlgoSigner.accounts({\n    ledger\n  });\n\n  if (!Array.isArray(accts)) {\n    throw Error(`AlgoSigner.accounts('${ledger}') is not an array: ${accts}`);\n  }\n\n  if (!accts.map(x => x.address).includes(addr)) {\n    throw Error(`Address ${addr} not found in AlgoSigner accounts`);\n  }\n\n  let networkAccount = {\n    addr,\n    AlgoSigner\n  };\n  return await connectAccount(networkAccount);\n};\nexport const getNetworkTime = async () => bigNumberify(await getLastRound());\nexport const waitUntilTime = async (targetTime, onProgress) => {\n  const onProg = onProgress || (() => {});\n\n  let currentTime = await getNetworkTime();\n\n  while (currentTime.lt(targetTime)) {\n    debug('waitUntilTime: iteration:', currentTime, '->', targetTime);\n    const status = await (await getAlgodClient()).statusAfterBlock(currentTime.toNumber()).do();\n    currentTime = bigNumberify(status['last-round']);\n    onProg({\n      currentTime,\n      targetTime\n    });\n  }\n\n  debug('waitUntilTime: ended:', currentTime, '->', targetTime);\n  return currentTime;\n};\nexport const wait = async (delta, onProgress) => {\n  const now = await getNetworkTime();\n  debug('wait: delta=', delta, 'now=', now, 'until=', now.add(delta));\n  return await waitUntilTime(now.add(delta), onProgress);\n};\nexport const verifyContract = async (info, bin) => {\n  const {\n    ApplicationID,\n    Deployer,\n    creationRound\n  } = info;\n  const compiled = await compileFor(bin, info);\n  const {\n    appApproval,\n    appClear\n  } = compiled;\n  let dhead = `verifyContract`;\n\n  const chk = (p, msg) => {\n    if (!p) {\n      throw Error(`verifyContract failed: ${msg}`);\n    }\n  };\n\n  const chkeq = (a, e, msg) => {\n    const as = JSON.stringify(a);\n    const es = JSON.stringify(e);\n    chk(as === es, `${msg}: expected ${es}, got ${as}`);\n  };\n\n  const client = await getAlgodClient();\n  const appInfo = await client.getApplicationByID(ApplicationID).do();\n  const appInfo_p = appInfo['params'];\n  debug(dhead, '-- appInfo_p =', appInfo_p);\n  const indexer = await getIndexer();\n  const cquery = indexer.searchForTransactions().applicationID(ApplicationID).txType('appl').round(creationRound);\n  let ctxn = null;\n\n  while (!ctxn) {\n    const cres = await doQuery_(dhead, cquery);\n\n    if (cres['current-round'] < creationRound) {\n      debug(dhead, '-- waiting for creationRound');\n      await Timeout.set(1000);\n      continue;\n    }\n\n    ctxn = cres.transactions[0];\n  }\n\n  debug(dhead, '-- ctxn =', ctxn);\n\n  const fmtp = x => uint8ArrayToStr(x.result, 'base64');\n\n  chk(ctxn, `Cannot query for creationRound accuracy`);\n  chk(appInfo_p, `Cannot lookup ApplicationId`);\n  chkeq(appInfo_p['approval-program'], fmtp(appApproval), `Approval program does not match Reach backend`);\n  chkeq(appInfo_p['clear-state-program'], fmtp(appClear), `ClearState program does not match Reach backend`);\n  chkeq(appInfo_p['creator'], Deployer, `Deployer does not match contract information`);\n  const catxn = ctxn['application-transaction'];\n  chkeq(catxn['approval-program'], appInfo_p['approval-program'], `creationRound Approval program`);\n  chkeq(catxn['clear-state-program'], appInfo_p['clear-state-program'], `creationRound ClearState program`);\n  chkeq(catxn['on-completion'], 'update', `creationRound on-completion`);\n  chkeq(ctxn['sender'], Deployer, `creationRound Deployer`); // Note: (after deployMode:firstMsg is implemented)\n  // 1. (above) attach initial args to ContractInfo\n  // 2. verify contract storage matches expectations based on initial args\n\n  return true;\n};\nexport const reachStdlib = compiledStdlib;","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/@reach-sh/stdlib/ALGO.mjs"],"names":["algosdk","base32","ethers","Timeout","buffer","msgpack","Buffer","getViewsHelper","deferContract","debug","assert","envDefault","isBigNumber","bigNumberify","bigNumberToNumber","argsSlice","makeRandom","waitPort","replaceableThunk","addressToHex","stdlib","compiledStdlib","typeDefs","process","window","uint8ArrayToStr","a","enc","Uint8Array","console","log","Error","from","toString","getWaitPort","setWaitPort","wait1port","server","port","getSignStrategy","setSignStrategy","getAlgoSigner","setAlgoSigner","AlgoSigner","connect","env","REACH_CONNECTOR_MODE","rawDefaultToken","rawDefaultItoken","getLastRound","getAlgodClient","status","do","waitForConfirmation","txId","untilRound","algodClient","lastRound","lastRoundAfterCall","statusAfterBlock","pendingInfo","pendingTransactionInformation","confirmedRound","type","sendAndConfirm","stx_or_stxs","txID","tx","sendme","Array","isArray","length","map","stx","req","sendRawTransaction","base64ify","txnBytesToPost","e","compileTEAL","label","code","s","r","compile","statusCode","src","result","base64ToUI8A","JSON","stringify","getTxnParams","params","getTransactionParams","firstRound","set","regroup","thisAcc","txns","roundtrip_txns","x","clean_for_AlgoSigner","unclean_for_AlgoSigner","assignGroupID","group","txn","txnOrig","Object","keys","forEach","key","undefined","note","appApprovalProgram","appClearProgram","tempArgs","appArgs","element","push","flatFee","name","tag","lease","nonParticipation","arg","field","publicKey","encodeAddress","sign_and_send_sync","networkAccount","txn_s","signTxn","replaceAll","orig","what","whatp","once","replace","replaceUint8Array","arr","encode","replaceAddr","addr","decodeAddress","must_be_supported","bin","algob","_Connectors","ALGO","unsupported","MaxTxnLife","LogicSigMaxSize","MaxAppArgs","MaxAppTotalArgLen","MaxAppProgramLen","compileFor","info","ApplicationID","Deployer","appApproval","appClear","ctc","steps","stepargs","subst_appid","T_UInt","toNet","subst_creator","checkLen","actual","expected","ctc_bin","subst_ctc","hash","appApproval_subst","stepCode_bin","Promise","all","mc","mi","mN","mc_subst","cr","sa","count","size","appApproval_bin","appClear_bin","ui8z","format_failed_request","ep","parse","db64","data","msg","text","doQuery_","dhead","query","res","doQuery","transactions","addressEq","digest","T_Null","T_Bool","T_Tuple","T_Array","T_Object","T_Data","T_Bytes","T_Address","T_Digest","T_Struct","randomUInt","hasRandom","getLedger","setLedger","DEFAULT_ALGO_LEDGER","getLedgerFromAlgoSigner","waitIndexerFromEnv","ALGO_INDEXER_SERVER","ALGO_INDEXER_PORT","ALGO_INDEXER_TOKEN","Indexer","waitAlgodClientFromEnv","ALGO_SERVER","ALGO_PORT","ALGO_TOKEN","Algodv2","setAlgodClient","envDefaultsALGO","getIndexer","setIndexer","getProvider","indexer","ledger","setProvider","provider","localhostProviderEnv","ALGO_LEDGER","DEFAULT_ALGO_SERVER","DEFAULT_ALGO_PORT","DEFAULT_ALGO_TOKEN","DEFAULT_ALGO_INDEXER_SERVER","DEFAULT_ALGO_INDEXER_PORT","DEFAULT_ALGO_INDEXER_TOKEN","serverLooksLikeRandlabs","toLowerCase","includes","envDefaultALGOPort","defaultPort","envDefaultALGOToken","token","defaultToken","guessRandlabsLedger","startsWith","envDefaultALGOLedger","defaultLedger","setProviderByEnv","fullEnv","randlabsProviderEnv","prefix","RANDLABS_BASE","providerEnvByName","providerName","setProviderByName","rawFaucetDefaultMnemonic","getFaucet","setFaucet","FAUCET","mnemonicToSecretKey","ALGO_FAUCET_PASSPHRASE","connectAccount","makeTransferTxn","to","value","ps","closeTo","valuen","makeAssetTransferTxnWithSuggestedParams","makePaymentTxnWithSuggestedParams","transfer","sender","receiver","valuebn","sk","ret","decode","stx_obj","sign","blob","shad","substring","pks","canonicalize","selfAddress","iam","some_addr","attachP","ctcInfoP","ctcInfo","getInfo","creationRound","bin_comp","escrowAddr","verifyContract","ctc_prog","makeLogicSig","wait","delta","waitUntilTime","add","sendrecv","funcNum","evt_cnt","hasLastTime","tys","args","pay","out_tys","onlyIf","soloSend","timeout_delay","sim_p","ltidx","toNumber","splice","doRecv","waitIfNotPresent","recv","toks","funcName","handler","fake_res","didTimeout","time","getOutput","o_lab","o_ctc","sim_r","isHalt","sim_txns","view_ty","view_v","view","tdn","Math","min","txnToContract_value_idx","totalFromFee","txnExtraTxns","t","i","tok","amt","kind","tto","slice","raw_minimumBalance","fee","actual_args","prevSt_noPrevTime","nextSt_noTime","actual_tys","safe_args","m","ui8h","handler_sig","whichAppl","makeApplicationDeleteTxn","makeApplicationNoOpTxn","txnAppl","txnFromHandler","txnToHandler","signLSTO","ls","tx_obj","signLogicSigTransactionObject","sign_me","txnAppl_s","txnFromHandler_s","txnToHandler_s","txnExtraTxns_s","st","t_s","txns_s","timeoutRound","currentRound","hquery","searchForTransactions","address","addressRole","minRound","maxRound","htxn","theRound","applicationID","txType","round","ctc_args","reNetify","utils","arrayify","args_un","fromNet","fromAddr","oldLastRound","creationTime","views_bin","_getViews","reachStdlib","getView1","vs","v","k","vim","client","appInfo","getApplicationByID","appSt","viewSt","find","vvn","bytes","vin","netSize","vi","vtys","vty","vvs","vres","getViews","deployP","appApproval0","appApproval0_subst","appApproval0_bin","createRes","makeApplicationCreateTxn","OnApplicationComplete","NoOpOC","txnUpdate","makeApplicationUpdateTxn","txnToContract","txnUpdate_s","txnToContract_s","updateRes","implNow","attach","deploy","setDebugLabel","newLabel","getAddress","balanceOf","acc","amount","accountInformation","createAccount","generateAccount","fundFromFaucet","account","faucet","newTestAccount","startingBalance","standardUnit","atomicUnit","parseCurrency","numericAmt","parseFloat","algosToMicroalgos","minimumBalance","formatCurrency","decimals","Number","isInteger","algosStr","microalgosToAlgos","toFixed","getDefaultAccount","prompt","signStrategy","mnemonic","newAccountFromMnemonic","newAccountFromAlgoSigner","newAccountFromSecret","secret","secretKeyToMnemonic","accts","accounts","getNetworkTime","targetTime","onProgress","onProg","currentTime","lt","now","compiled","chk","p","chkeq","as","es","appInfo_p","cquery","ctxn","cres","fmtp","catxn"],"mappings":"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","sourcesContent":["// XXX: use @types/algosdk when we can\nimport algosdk from 'algosdk';\nimport base32 from 'hi-base32';\nimport ethers from 'ethers';\nimport Timeout from 'await-timeout';\nimport buffer from 'buffer';\nimport msgpack from '@msgpack/msgpack';\n// DEBUG: uncomment this for debugging in browser\n// @ts-ignore\n// import algosdk__src__transaction from 'algosdk/src/transaction';\nconst { Buffer } = buffer;\nimport { getViewsHelper, deferContract, debug, assert, envDefault, isBigNumber, bigNumberify, bigNumberToNumber, argsSlice, makeRandom } from './shared.mjs';\nimport waitPort from './waitPort.mjs';\nimport { replaceableThunk } from './shared_impl.mjs';\nimport { addressToHex, stdlib as compiledStdlib, typeDefs } from './ALGO_compiled.mjs';\nimport { process, window } from './shim.mjs';\nexport * from './shared.mjs';\n// Helpers\nfunction uint8ArrayToStr(a, enc = 'utf8') {\n  if (!(a instanceof Uint8Array)) {\n    console.log(a);\n    throw Error(`Expected Uint8Array, got ${a}`);\n  }\n  return Buffer.from(a).toString(enc);\n}\nconst [getWaitPort, setWaitPort] = replaceableThunk(() => true);\nexport { setWaitPort };\nasync function wait1port(server, port) {\n  if (!getWaitPort())\n    return;\n  return await waitPort(server, port);\n}\nconst [getSignStrategy, setSignStrategy] = replaceableThunk(() => 'mnemonic');\nexport { getSignStrategy, setSignStrategy };\nconst [getAlgoSigner, setAlgoSigner] = replaceableThunk(async () => {\n  if (window.AlgoSigner) {\n    const AlgoSigner = window.AlgoSigner;\n    await AlgoSigner.connect();\n    return AlgoSigner;\n  } else {\n    // TODO: wait for a few seconds and try again before giving up\n    throw Error(`Can't find AlgoSigner. Please refresh the page and try again.`);\n  }\n});\nexport { setAlgoSigner };\nif (process.env.REACH_CONNECTOR_MODE == 'ALGO-browser'\n  // Yes, this is dumb. TODO something better\n  ||\n  process.env.REACH_CONNECTOR_MODE === 'ETH-browser') {\n  setWaitPort(false);\n}\nconst rawDefaultToken = 'c87f5580d7a866317b4bfe9e8b8d1dda955636ccebfa88c12b414db208dd9705';\nconst rawDefaultItoken = 'reach-devnet';\nconst getLastRound = async () => (await (await getAlgodClient()).status().do())['last-round'];\nexport const waitForConfirmation = async (txId, untilRound) => {\n  const algodClient = await getAlgodClient();\n  let lastRound = null;\n  do {\n    const lastRoundAfterCall = lastRound ?\n      algodClient.statusAfterBlock(lastRound) :\n      algodClient.status();\n    lastRound = (await lastRoundAfterCall.do())['last-round'];\n    const pendingInfo = await algodClient.pendingTransactionInformation(txId).do();\n    const confirmedRound = pendingInfo['confirmed-round'];\n    if (confirmedRound && confirmedRound > 0) {\n      return pendingInfo;\n    }\n  } while (!untilRound || lastRound < untilRound);\n  throw { type: 'waitForConfirmation', txId, untilRound, lastRound };\n};\nconst sendAndConfirm = async (stx_or_stxs) => {\n  // @ts-ignore\n  let { lastRound, txID, tx } = stx_or_stxs;\n  let sendme = tx;\n  if (Array.isArray(stx_or_stxs)) {\n    if (stx_or_stxs.length === 0) {\n      debug(`Sending nothing... why...?`);\n      // @ts-ignore\n      return null;\n    }\n    debug(`Sending multiple...`);\n    lastRound = stx_or_stxs[0].lastRound;\n    txID = stx_or_stxs[0].txID;\n    sendme = stx_or_stxs.map((stx) => stx.tx);\n  }\n  const untilRound = lastRound;\n  const req = (await getAlgodClient()).sendRawTransaction(sendme);\n  // @ts-ignore\n  debug('sendAndConfirm:', base64ify(req.txnBytesToPost));\n  try {\n    await req.do();\n  } catch (e) {\n    throw { type: 'sendRawTransaction', e };\n  }\n  return await waitForConfirmation(txID, untilRound);\n};\n// Backend\nconst compileTEAL = async (label, code) => {\n  debug('compile', label);\n  let s, r;\n  try {\n    r = await (await getAlgodClient()).compile(code).do();\n    s = 200;\n  } catch (e) {\n    s = typeof e === 'object' ? e.statusCode : 'not object';\n    r = e;\n  }\n  if (s == 200) {\n    debug('compile', label, 'succeeded:', r);\n    r.src = code;\n    r.result = base64ToUI8A(r.result);\n    // debug('compile transformed:', r);\n    return r;\n  } else {\n    throw Error(`compile ${label} failed: ${s}: ${JSON.stringify(r)}`);\n  }\n};\nexport const getTxnParams = async () => {\n  debug(`fillTxn: getting params`);\n  while (true) {\n    const params = await (await getAlgodClient()).getTransactionParams().do();\n    debug('fillTxn: got params:', params);\n    if (params.firstRound !== 0) {\n      return params;\n    }\n    debug(`...but firstRound is 0, so let's wait and try again.`);\n    // Assumption: firstRound will move past 0 on its own.\n    await Timeout.set(1000);\n  }\n};\n\nfunction regroup(thisAcc, txns) {\n  // Sorry this is so dumb.\n  // Basically, if these go thru AlgoSigner,\n  // it will mangle them,\n  //  so we need to recalculate the group hash.\n  if (thisAcc.AlgoSigner) {\n    const roundtrip_txns = txns\n      .map(x => clean_for_AlgoSigner(x))\n      .map(x => unclean_for_AlgoSigner(x));\n    // console.log(`deployP: group`);\n    // console.log(txns[0].group);\n    // console.log(Buffer.from(txns[0].group, 'base64').toString('base64'));\n    // console.log({...txns[0]});\n    algosdk.assignGroupID(roundtrip_txns);\n    // console.log(`deploy: roundtrip group`);\n    // console.log(Buffer.from(roundtrip_txns[0].group, 'base64').toString('base64'));\n    const group = roundtrip_txns[0].group;\n    // The same thing, but more paranoid:\n    // const group = Buffer.from(roundtrip_txns[0].group, 'base64').toString('base64');\n    for (const txn of txns) {\n      txn.group = group;\n    }\n    // console.log({...txns[0]});\n    return roundtrip_txns;\n  } else {\n    return txns;\n  }\n}\n// A copy/paste of some logic from AlgoSigner\n// packages/extension/src/background/messaging/task.ts\nfunction unclean_for_AlgoSigner(txnOrig) {\n  const txn = { ...txnOrig };\n  Object.keys({ ...txnOrig }).forEach(key => {\n    if (txn[key] === undefined || txn[key] === null) {\n      delete txn[key];\n    }\n  });\n  // Modify base64 encoded fields\n  if ('note' in txn && txn.note !== undefined) {\n    txn.note = new Uint8Array(Buffer.from(txn.note));\n  }\n  // Application transactions only\n  if (txn && txn.type === 'appl') {\n    if ('appApprovalProgram' in txn) {\n      txn.appApprovalProgram = base64ToUI8A(txn.appApprovalProgram);\n    }\n    if ('appClearProgram' in txn) {\n      txn.appClearProgram = base64ToUI8A(txn.appClearProgram);\n    }\n    if ('appArgs' in txn) {\n      var tempArgs = [];\n      txn.appArgs.forEach((element) => {\n        tempArgs.push(base64ToUI8A(element));\n      });\n      txn.appArgs = tempArgs;\n    }\n  }\n  // Note: this part is not copy/pasted from AlgoSigner,\n  // and isn't even strictly necessary,\n  // but it is nice for getting the same signatures from algosdk & AlgoSigner\n  if ('group' in txn) {\n    txn.group = base64ToUI8A(txn.group);\n  }\n  return txn;\n}\nconst clean_for_AlgoSigner = (txnOrig) => {\n  // Make a copy with just the properties, because reasons\n  const txn = { ...txnOrig };\n  // AlgoSigner does weird things with fees if you don't specify flatFee\n  txn.flatFee = true;\n  // \"Creation of PaymentTx has extra or invalid fields: name,tag,appArgs.\"\n  delete txn.name;\n  delete txn.tag;\n  // uncaught (in promise) lease must be a Uint8Array.\n  // it is... but how about we just delete it instead\n  // This is presumed safe when lease is empty\n  if (txn.lease instanceof Uint8Array && txn.lease.length === 0) {\n    delete txn.lease;\n  } else {\n    console.log(txn.lease);\n    throw Error(`Impossible: non-empty lease`);\n  }\n  // Creation of ApplTx has extra or invalid fields: nonParticipation\n  if (!txn.nonParticipation) {\n    delete txn.nonParticipation;\n  } else {\n    throw Error(`Impossible: expected falsy nonParticipation, got: ${txn.nonParticipation}`);\n  }\n  // \"Creation of ApplTx has extra or invalid fields: name,tag.\"\n  if (txn.type !== 'appl') {\n    delete txn.appArgs;\n  } else {\n    if (txn.appArgs) {\n      if (txn.appArgs.length === 0) {\n        txn.appArgs = [];\n      } else {\n        txn.appArgs = txn.appArgs.map((arg) => uint8ArrayToStr(arg, 'base64'));\n      }\n    }\n  }\n  // Validation failed for transaction because of invalid properties [from,to]\n  // closeRemainderTo can cause an error w/ js-algorand-sdk addr parsing\n  for (const field of ['from', 'to', 'closeRemainderTo']) {\n    if (txn[field] && txn[field].publicKey) {\n      txn[field] = algosdk.encodeAddress(txn[field].publicKey);\n    }\n  }\n  // Weirdly, AlgoSigner *requires* the note to be a string\n  // note is the only field that needs to be utf8-encoded, so far...\n  for (const field of ['note']) {\n    if (txn[field] && typeof txn[field] !== 'string') {\n      txn[field] = uint8ArrayToStr(txn[field], 'utf8');\n    }\n  }\n  // Uncaught (in promise) First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\n  // No idea what it's talking about, but probably GenesisHash?\n  // And some more uint8Array BS\n  for (const field of ['genesisHash', 'appApprovalProgram', 'appClearProgram', 'group']) {\n    if (txn[field] && typeof txn[field] !== 'string') {\n      txn[field] = uint8ArrayToStr(txn[field], 'base64');\n    }\n  }\n  return txn;\n};\nconst sign_and_send_sync = async (label, networkAccount, txn) => {\n  const txn_s = await signTxn(networkAccount, txn);\n  try {\n    return await sendAndConfirm(txn_s);\n  } catch (e) {\n    console.log(e);\n    throw Error(`${label} txn failed:\\n${JSON.stringify(txn)}\\nwith:\\n${JSON.stringify(e)}`);\n  }\n};\n// XXX I'd use x.replaceAll if I could (not supported in this node version), but it would be better to extend ConnectorInfo so these are functions\nconst replaceAll = (orig, what, whatp) => {\n  const once = orig.replace(what, whatp);\n  if (once === orig) {\n    return orig;\n  } else {\n    return replaceAll(once, what, whatp);\n  }\n};\nconst replaceUint8Array = (label, arr, x) => replaceAll(x, `\"{{${label}}}\"`, `base32(${base32.encode(arr).toString()})`);\nconst replaceAddr = (label, addr, x) => replaceUint8Array(label, algosdk.decodeAddress(addr).publicKey, x);\n\nfunction must_be_supported(bin) {\n  const algob = bin._Connectors.ALGO;\n  const { unsupported } = algob;\n  if (unsupported) {\n    throw Error(`This Reach application is not supported by Algorand.`);\n  }\n}\n// Get these from stdlib\nconst MaxTxnLife = 1000;\nconst LogicSigMaxSize = 1000;\nconst MaxAppArgs = 16;\nconst MaxAppTotalArgLen = 2048;\nconst MaxAppProgramLen = 1024;\nasync function compileFor(bin, info) {\n  const { ApplicationID, Deployer } = info;\n  must_be_supported(bin);\n  const algob = bin._Connectors.ALGO;\n  const { appApproval, appClear, ctc, steps, stepargs } = algob;\n  const subst_appid = (x) => replaceUint8Array('ApplicationID', T_UInt.toNet(bigNumberify(ApplicationID)), x);\n  const subst_creator = (x) => replaceAddr('Deployer', Deployer, x);\n  const checkLen = (label, actual, expected) => {\n    debug(`checkLen`, { label, actual, expected });\n    if (actual > expected) {\n      throw Error(`This Reach application is not supported by Algorand: ${label} length is ${actual}, but should be less than ${expected}.`);\n    }\n  };\n  const ctc_bin = await compileTEAL('ctc_subst', subst_creator(subst_appid(ctc)));\n  checkLen(`Escrow Contract`, ctc_bin.result.length, LogicSigMaxSize);\n  const subst_ctc = (x) => replaceAddr('ContractAddr', ctc_bin.hash, x);\n  let appApproval_subst = appApproval;\n  const stepCode_bin = await Promise.all(steps.map(async (mc, mi) => {\n    if (!mc) {\n      return null;\n    }\n    const mN = `m${mi}`;\n    const mc_subst = subst_creator(subst_ctc(subst_appid(mc)));\n    const cr = await compileTEAL(mN, mc_subst);\n    checkLen(`${mN} Contract`, cr.result.length, LogicSigMaxSize);\n    const sa = stepargs[mi];\n    if (sa) {\n      checkLen(`${mN} Contract Arguments Count`, sa.count, MaxAppArgs);\n      checkLen(`${mN} Contract Arguments Length`, sa.size, MaxAppTotalArgLen);\n    }\n    appApproval_subst =\n      replaceAddr(mN, cr.hash, appApproval_subst);\n    return cr;\n  }));\n  const appApproval_bin = await compileTEAL('appApproval_subst', appApproval_subst);\n  checkLen(`Approval Contract`, appApproval_bin.result.length, MaxAppProgramLen);\n  const appClear_bin = await compileTEAL('appClear', appClear);\n  checkLen(`Clear Contract`, appClear_bin.result.length, MaxAppProgramLen);\n  return {\n    appApproval: appApproval_bin,\n    appClear: appClear_bin,\n    ctc: ctc_bin,\n    steps: stepCode_bin,\n  };\n}\nconst ui8z = new Uint8Array();\nconst base64ToUI8A = (x) => Uint8Array.from(Buffer.from(x, 'base64'));\nconst base64ify = (x) => Buffer.from(x).toString('base64');\nconst format_failed_request = (e) => {\n  const ep = JSON.parse(JSON.stringify(e));\n  const db64 = ep.req ?\n    (ep.req.data ? base64ify(ep.req.data) :\n      `no data, but ${JSON.stringify(Object.keys(ep.req))}`) :\n    `no req, but ${JSON.stringify(Object.keys(ep))}`;\n  const msg = e.text ? JSON.parse(e.text) : e;\n  return `\\n${db64}\\n${JSON.stringify(msg)}`;\n};\nconst doQuery_ = async (dhead, query) => {\n  debug(dhead, '--- QUERY =', query);\n  let res;\n  try {\n    res = await query.do();\n  } catch (e) {\n    throw Error(`${dhead} --- QUERY FAIL: ${JSON.stringify(e)}`);\n  }\n  debug(dhead, '--- RESULT =', res);\n  return res;\n};\nconst doQuery = async (dhead, query) => {\n  const res = await doQuery_(dhead, query);\n  if (res.transactions.length == 0) {\n    // XXX Look at the round in res and wait for a new round\n    return null;\n  }\n  const txn = res.transactions[0];\n  return txn;\n};\n// ****************************************************************************\n// Common Interface Exports\n// ****************************************************************************\nexport const { addressEq, digest } = compiledStdlib;\nexport const { T_Null, T_Bool, T_UInt, T_Tuple, T_Array, T_Object, T_Data, T_Bytes, T_Address, T_Digest, T_Struct } = typeDefs;\nexport const { randomUInt, hasRandom } = makeRandom(8);\nexport const [getLedger, setLedger] = replaceableThunk(() => DEFAULT_ALGO_LEDGER);\n\nfunction getLedgerFromAlgoSigner(AlgoSigner) {\n  // XXX: get AlgoSigner to tell us what Ledger is \"currently selected\"\n  // since that ability doesn't actually exist, we operate based off of setLedger()\n  void(AlgoSigner);\n  return getLedger();\n}\nasync function waitIndexerFromEnv(env) {\n  const { ALGO_INDEXER_SERVER, ALGO_INDEXER_PORT, ALGO_INDEXER_TOKEN } = env;\n  await wait1port(ALGO_INDEXER_SERVER, ALGO_INDEXER_PORT);\n  return new algosdk.Indexer(ALGO_INDEXER_TOKEN, ALGO_INDEXER_SERVER, ALGO_INDEXER_PORT);\n}\nasync function waitAlgodClientFromEnv(env) {\n  const { ALGO_SERVER, ALGO_PORT, ALGO_TOKEN } = env;\n  await wait1port(ALGO_SERVER, ALGO_PORT);\n  return new algosdk.Algodv2(ALGO_TOKEN, ALGO_SERVER, ALGO_PORT);\n}\n// TODO: read token from scripts/algorand-devnet/algorand_data/algod.token\nexport const [getAlgodClient, setAlgodClient] = replaceableThunk(async () => {\n  debug(`Setting algod client to default`);\n  return await waitAlgodClientFromEnv(envDefaultsALGO(process.env));\n});\nexport const [getIndexer, setIndexer] = replaceableThunk(async () => {\n  debug(`setting indexer to default`);\n  return await waitIndexerFromEnv(envDefaultsALGO(process.env));\n});\nexport async function getProvider() {\n  return {\n    algodClient: await getAlgodClient(),\n    indexer: await getIndexer(),\n    ledger: getLedger(),\n  };\n}\nexport async function setProvider(provider) {\n  provider = await provider;\n  // XXX doesn't waitPort these, because these are opaque to us.\n  // should we do something similar where we wait for /health to give us a 200 response?\n  setAlgodClient((async () => provider.algodClient)());\n  setIndexer((async () => provider.indexer)());\n  setLedger(provider.ledger);\n}\nconst localhostProviderEnv = {\n  ALGO_LEDGER: 'Reach Devnet',\n  ALGO_SERVER: 'http://localhost',\n  ALGO_PORT: '4180',\n  ALGO_TOKEN: rawDefaultToken,\n  ALGO_INDEXER_SERVER: 'http://localhost',\n  ALGO_INDEXER_PORT: '8980',\n  ALGO_INDEXER_TOKEN: rawDefaultItoken,\n};\nconst DEFAULT_ALGO_LEDGER = localhostProviderEnv.ALGO_LEDGER;\nconst DEFAULT_ALGO_SERVER = localhostProviderEnv.ALGO_SERVER;\nconst DEFAULT_ALGO_PORT = localhostProviderEnv.ALGO_PORT;\nconst DEFAULT_ALGO_TOKEN = localhostProviderEnv.ALGO_TOKEN;\nconst DEFAULT_ALGO_INDEXER_SERVER = localhostProviderEnv.ALGO_INDEXER_SERVER;\nconst DEFAULT_ALGO_INDEXER_PORT = localhostProviderEnv.ALGO_INDEXER_PORT;\nconst DEFAULT_ALGO_INDEXER_TOKEN = localhostProviderEnv.ALGO_INDEXER_TOKEN;\n\nfunction serverLooksLikeRandlabs(server) {\n  return server.toLowerCase().includes('algoexplorerapi.io');\n}\n\nfunction envDefaultALGOPort(port, defaultPort, server) {\n  // Some simple guessing\n  return port !== undefined ? port :\n    serverLooksLikeRandlabs(server) ? '' :\n    defaultPort;\n}\n\nfunction envDefaultALGOToken(token, defaultToken, server, port) {\n  // Some simple guessing\n  // port is not currently used for this guessing, but could be in the future\n  void(port);\n  return token !== undefined ? token :\n    serverLooksLikeRandlabs(server) ? '' :\n    defaultToken;\n}\n\nfunction guessRandlabsLedger(server) {\n  if (server === undefined)\n    return undefined;\n  server = server.toLowerCase();\n  if (server.startsWith('https://algoexplorerapi.io')) {\n    return 'MainNet';\n  } else if (server.startsWith('https://testnet.algoexplorerapi.io')) {\n    return 'TestNet';\n  } else if (server.startsWith('https://betanet.algoexplorerapi.io')) {\n    return 'BetaNet';\n  }\n  return undefined;\n}\n\nfunction envDefaultALGOLedger(ledger, defaultLedger, server, port) {\n  // Some simple guessing\n  // port is not currently used for this guessing, but could be in the future\n  void(port);\n  return ledger !== undefined ? ledger :\n    serverLooksLikeRandlabs(server) ? guessRandlabsLedger(ledger) :\n    defaultLedger;\n}\n\nfunction envDefaultsALGO(env) {\n  const ALGO_SERVER = envDefault(env.ALGO_SERVER, DEFAULT_ALGO_SERVER);\n  const ALGO_PORT = envDefaultALGOPort(env.ALGO_PORT, DEFAULT_ALGO_PORT, ALGO_SERVER);\n  const ALGO_TOKEN = envDefaultALGOToken(env.ALGO_TOKEN, DEFAULT_ALGO_TOKEN, ALGO_SERVER, ALGO_PORT);\n  const ALGO_LEDGER = envDefaultALGOLedger(env.ALGO_LEDGER, DEFAULT_ALGO_LEDGER, ALGO_SERVER, ALGO_PORT);\n  const ALGO_INDEXER_SERVER = envDefault(env.ALGO_INDEXER_SERVER, DEFAULT_ALGO_INDEXER_SERVER);\n  const ALGO_INDEXER_PORT = envDefaultALGOPort(env.ALGO_INDEXER_PORT, DEFAULT_ALGO_INDEXER_PORT, ALGO_INDEXER_SERVER);\n  const ALGO_INDEXER_TOKEN = envDefaultALGOToken(env.ALGO_INDEXER_TOKEN, DEFAULT_ALGO_INDEXER_TOKEN, ALGO_INDEXER_SERVER, ALGO_INDEXER_PORT);\n  return {\n    ALGO_LEDGER,\n    ALGO_SERVER,\n    ALGO_PORT,\n    ALGO_TOKEN,\n    ALGO_INDEXER_SERVER,\n    ALGO_INDEXER_PORT,\n    ALGO_INDEXER_TOKEN,\n  };\n}\nexport function setProviderByEnv(env) {\n  // Note: This doesn't just immediately call setProviderByEnv,\n  // because here we can actually take the opportunity to wait1port.\n  const fullEnv = envDefaultsALGO(env);\n  setAlgodClient(waitAlgodClientFromEnv(fullEnv));\n  setIndexer(waitIndexerFromEnv(fullEnv));\n  setLedger(fullEnv.ALGO_LEDGER);\n}\n\nfunction randlabsProviderEnv(ALGO_LEDGER) {\n  const prefix = ALGO_LEDGER === 'MainNet' ? '' : `${ALGO_LEDGER.toLowerCase()}.`;\n  const RANDLABS_BASE = `https://${prefix}algoexplorerapi.io`;\n  return {\n    ALGO_LEDGER,\n    ALGO_SERVER: RANDLABS_BASE,\n    ALGO_PORT: '',\n    ALGO_TOKEN: '',\n    ALGO_INDEXER_SERVER: `${RANDLABS_BASE}/idx2`,\n    ALGO_INDEXER_PORT: '',\n    ALGO_INDEXER_TOKEN: '',\n  };\n}\nexport function providerEnvByName(providerName) {\n  switch (providerName) {\n    case 'MainNet':\n      return randlabsProviderEnv('MainNet');\n    case 'TestNet':\n      return randlabsProviderEnv('TestNet');\n    case 'BetaNet':\n      return randlabsProviderEnv('BetaNet');\n    case 'randlabs/MainNet':\n      return randlabsProviderEnv('MainNet');\n    case 'randlabs/TestNet':\n      return randlabsProviderEnv('TestNet');\n    case 'randlabs/BetaNet':\n      return randlabsProviderEnv('BetaNet');\n    case 'LocalHost':\n      return localhostProviderEnv;\n    default:\n      throw Error(`Unrecognized provider name: ${providerName}`);\n  }\n}\nexport function setProviderByName(providerName) {\n  return setProviderByEnv(providerEnvByName(providerName));\n}\n// eslint-disable-next-line max-len\nconst rawFaucetDefaultMnemonic = 'husband sock drift razor piece february loop nose crew object salon come sketch frost grocery capital young strategy catalog dial seminar sword betray absent army';\nconst [getFaucet, setFaucet] = replaceableThunk(async () => {\n  const ledger = getLedger();\n  if (ledger !== localhostProviderEnv.ALGO_LEDGER) {\n    throw Error(`Cannot automatically use faucet for ledger '${ledger}'; if you want to use a custom faucet, use setFaucet`);\n  }\n  const FAUCET = algosdk.mnemonicToSecretKey(envDefault(process.env.ALGO_FAUCET_PASSPHRASE, rawFaucetDefaultMnemonic));\n  return await connectAccount(FAUCET);\n});\nexport { getFaucet, setFaucet };\nconst makeTransferTxn = (from, to, value, token, ps, closeTo = undefined) => {\n  const valuen = bigNumberToNumber(value);\n  // XXX AlgoSigner doesn't correctly handle msgpacked notes\n  // When it does: update {,un}clean_for_AlgoSigner\n  // const note = algosdk.encodeObj('Reach');\n  const note = new Uint8Array(Buffer.from('Reach'));\n  const txn = token ?\n    algosdk.makeAssetTransferTxnWithSuggestedParams(from, to, closeTo, undefined, valuen, ui8z, bigNumberToNumber(token), ps) :\n    algosdk.makePaymentTxnWithSuggestedParams(from, to, valuen, closeTo, note, ps);\n  return txn;\n};\nexport const transfer = async (from, to, value, token = undefined) => {\n  const sender = from.networkAccount;\n  const receiver = to.networkAccount.addr;\n  const valuebn = bigNumberify(value);\n  const ps = await getTxnParams();\n  const txn = makeTransferTxn(sender.addr, receiver, valuebn, token, ps);\n  return await sign_and_send_sync(`transfer ${JSON.stringify(from)} ${JSON.stringify(to)} ${valuebn}`, sender, txn);\n};\nasync function signTxn(networkAccount, txnOrig) {\n  const { sk, AlgoSigner } = networkAccount;\n  if (sk && !AlgoSigner) {\n    const tx = txnOrig.signTxn(sk);\n    const ret = {\n      tx,\n      txID: txnOrig.txID().toString(),\n      lastRound: txnOrig.lastRound,\n    };\n    debug('signed sk_ret');\n    debug({ txID: ret.txID });\n    debug(msgpack.decode(ret.tx));\n    return ret;\n  } else if (AlgoSigner) {\n    // TODO: clean up txn before signing\n    const txn = clean_for_AlgoSigner(txnOrig);\n    // Note: don't delete the following,\n    // it is extremely useful for debugging when stuff changes wrt AlgoSigner/algosdk clashes\n    // if (sk) {\n    //   const re_tx = txnOrig.signTxn ? txnOrig : new algosdk__src__transaction.Transaction(txnOrig);\n    //   re_tx.group = txnOrig.group;\n    //   const sk_tx = re_tx.signTxn(sk);\n    //   const sk_ret = {\n    //     tx: sk_tx,\n    //     txID: re_tx.txID().toString(),\n    //     lastRound: txnOrig.lastRound,\n    //   };\n    //   console.log('signed sk_ret');\n    //   console.log({txID: sk_ret.txID});\n    //   console.log(msgpack.decode(sk_ret.tx));\n    // }\n    debug('AlgoSigner.sign ...');\n    const stx_obj = await AlgoSigner.sign(txn);\n    debug('...signed');\n    debug({ stx_obj });\n    const ret = {\n      tx: Buffer.from(stx_obj.blob, 'base64'),\n      txID: stx_obj.txID,\n      lastRound: txnOrig.lastRound,\n    };\n    debug('signed AlgoSigner');\n    debug({ txID: ret.txID });\n    debug(msgpack.decode(ret.tx));\n    return ret;\n  } else {\n    throw Error(`networkAccount has neither sk nor AlgoSigner: ${JSON.stringify(networkAccount)}`);\n  }\n}\nexport const connectAccount = async (networkAccount) => {\n  const indexer = await getIndexer();\n  const thisAcc = networkAccount;\n  const shad = thisAcc.addr.substring(2, 6);\n  let label = shad;\n  const pks = T_Address.canonicalize(thisAcc);\n  debug(shad, ': connectAccount');\n  const selfAddress = () => {\n    return pks;\n  };\n  const iam = (some_addr) => {\n    if (some_addr === pks) {\n      return some_addr;\n    } else {\n      throw Error(`I should be ${some_addr}, but am ${pks}`);\n    }\n  };\n  const attachP = async (bin, ctcInfoP) => {\n    const ctcInfo = await ctcInfoP;\n    const getInfo = async () => ctcInfo;\n    const { Deployer, ApplicationID } = ctcInfo;\n    let lastRound = ctcInfo.creationRound;\n    debug(shad, ': attach', ApplicationID, 'created at', lastRound);\n    const bin_comp = await compileFor(bin, ctcInfo);\n    const escrowAddr = bin_comp.ctc.hash;\n    void(addressToHex);\n    // XXX const escrowAddrRaw = T_Address.canonicalize(addressToHex(escrowAddr));\n    await verifyContract(ctcInfo, bin);\n    const ctc_prog = algosdk.makeLogicSig(bin_comp.ctc.result, []);\n    const wait = async (delta) => {\n      return await waitUntilTime(bigNumberify(lastRound).add(delta));\n    };\n    const sendrecv = async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay, sim_p) => {\n      if (hasLastTime !== false) {\n        const ltidx = hasLastTime.toNumber();\n        tys.splice(ltidx, 1);\n        args.splice(ltidx, 1);\n      }\n      const doRecv = async (waitIfNotPresent) => await recv(funcNum, evt_cnt, out_tys, waitIfNotPresent, timeout_delay);\n      if (!onlyIf) {\n        return await doRecv(true);\n      }\n      const [value, toks] = pay;\n      void(toks); // <-- rely on simulation because of ordering\n      const funcName = `m${funcNum}`;\n      const dhead = `${shad}: ${label} sendrecv ${funcName} ${timeout_delay}`;\n      debug(dhead, '--- START');\n      const handler = bin_comp.steps[funcNum];\n      if (!handler) {\n        throw Error(`${dhead} Internal error: reference to undefined handler: ${funcName}`);\n      }\n      const fake_res = {\n        didTimeout: false,\n        data: argsSlice(args, evt_cnt),\n        time: bigNumberify(0),\n        value: value,\n        from: pks,\n        getOutput: (async (o_lab, o_ctc) => {\n          void(o_lab);\n          void(o_ctc);\n          throw Error(`Algorand does not support remote calls, and Reach should not have generated a call to this function`);\n        }),\n      };\n      const sim_r = await sim_p(fake_res);\n      debug(dhead, '--- SIMULATE', sim_r);\n      const isHalt = sim_r.isHalt;\n      const sim_txns = sim_r.txns;\n      const [view_ty, view_v] = sim_r.view;\n      debug(dhead, 'VIEW', { view_ty, view_v });\n      while (true) {\n        const params = await getTxnParams();\n        if (timeout_delay) {\n          const tdn = Math.min(MaxTxnLife, timeout_delay.toNumber());\n          params.lastRound = lastRound + tdn;\n          if (params.firstRound > params.lastRound) {\n            debug(dhead, '--- FAIL/TIMEOUT');\n            return { didTimeout: true };\n          }\n        }\n        debug(dhead, '--- ASSEMBLE w/', params);\n        let txnToContract_value_idx = -1;\n        let totalFromFee = 0;\n        const txnExtraTxns = sim_txns.map((t, i) => {\n          const { tok } = t;\n          let amt = bigNumberify(0);\n          let from = escrowAddr;\n          let to = escrowAddr;\n          let closeTo = undefined;\n          if (t.kind === 'from') {\n            from = escrowAddr;\n            // @ts-ignore\n            const tto = t.to;\n            // XXX use some other function\n            to = algosdk.encodeAddress(Buffer.from(tto.slice(2), 'hex'));\n            amt = t.amt;\n          } else if (t.kind === 'init') {\n            from = escrowAddr;\n            to = escrowAddr;\n            totalFromFee += raw_minimumBalance;\n            amt = t.amt;\n          } else if (t.kind === 'halt') {\n            from = escrowAddr;\n            to = Deployer;\n            closeTo = Deployer;\n          } else if (t.kind === 'to') {\n            from = thisAcc.addr;\n            to = escrowAddr;\n            amt = t.amt;\n          } else {\n            assert(false, 'sim txn kind');\n          }\n          const txn = makeTransferTxn(from, to, amt, tok, params, closeTo);\n          if (from === escrowAddr) {\n            totalFromFee += txn.fee;\n          }\n          if (t.kind === 'to' && !tok) {\n            txnToContract_value_idx = i;\n          }\n          return txn;\n        });\n        debug(dhead, '--- totalFromFee =', totalFromFee);\n        assert(txnToContract_value_idx !== -1, 'sim txn no value');\n        txnExtraTxns[txnToContract_value_idx] =\n          makeTransferTxn(thisAcc.addr, escrowAddr, value.add(totalFromFee), undefined, params);\n        const actual_args = [sim_r.prevSt_noPrevTime, sim_r.nextSt_noTime, view_v, isHalt, bigNumberify(totalFromFee), lastRound, ...args];\n        const actual_tys = [T_Digest, T_Digest, view_ty, T_Bool, T_UInt, T_UInt, ...tys];\n        debug(dhead, '--- ARGS =', actual_args);\n        const safe_args = actual_args.map((m, i) => actual_tys[i].toNet(m));\n        safe_args.forEach((x) => {\n          if (!(x instanceof Uint8Array)) {\n            // The types say this is impossible now,\n            // but we'll leave it in for a while just in case...\n            throw Error(`expect safe program argument, got ${JSON.stringify(x)}`);\n          }\n        });\n        const ui8h = (x) => Buffer.from(x).toString('hex');\n        debug(dhead, '--- PREPARE:', safe_args.map(ui8h));\n        const handler_sig = algosdk.makeLogicSig(handler.result, []);\n        debug(dhead, '--- PREPARED');\n        const whichAppl = isHalt ?\n          // We are treating it like any party can delete the application, but the docs say it may only be possible for the creator. The code appears to not care: https://github.com/algorand/go-algorand/blob/0e9cc6b0c2ddc43c3cfa751d61c1321d8707c0da/ledger/apply/application.go#L589\n          algosdk.makeApplicationDeleteTxn :\n          algosdk.makeApplicationNoOpTxn;\n        const txnAppl = whichAppl(thisAcc.addr, params, ApplicationID, safe_args);\n        const txnFromHandler = algosdk.makePaymentTxnWithSuggestedParams(handler.hash, thisAcc.addr, 0, thisAcc.addr, ui8z, params);\n        debug(dhead, '--- txnFromHandler =', txnFromHandler);\n        const txnToHandler = algosdk.makePaymentTxnWithSuggestedParams(thisAcc.addr, handler.hash, txnFromHandler.fee + raw_minimumBalance, undefined, ui8z, params);\n        debug(dhead, '--- txnToHandler =', txnToHandler);\n        const txns = [\n          txnAppl,\n          txnToHandler,\n          txnFromHandler,\n          ...txnExtraTxns,\n        ];\n        algosdk.assignGroupID(txns);\n        regroup(thisAcc, txns);\n        const signLSTO = (txn, ls) => {\n          const tx_obj = algosdk.signLogicSigTransactionObject(txn, ls);\n          return {\n            tx: tx_obj.blob,\n            txID: tx_obj.txID,\n            lastRound: txn.lastRound,\n          };\n        };\n        const sign_me = async (x) => await signTxn(thisAcc, x);\n        const txnAppl_s = await sign_me(txnAppl);\n        const txnFromHandler_s = signLSTO(txnFromHandler, handler_sig);\n        const txnToHandler_s = await sign_me(txnToHandler);\n        const txnExtraTxns_s = await Promise.all(txnExtraTxns.map(async (t, i) => {\n          const st = sim_txns[i];\n          debug('txnExtraTxns_s', { t, i, st });\n          const t_s = st.kind === 'to' ?\n            await sign_me(t) :\n            signLSTO(t, ctc_prog);\n          return t_s;\n        }));\n        const txns_s = [\n          txnAppl_s,\n          txnToHandler_s,\n          txnFromHandler_s,\n          ...txnExtraTxns_s,\n        ];\n        debug(dhead, '--- SEND:', txns_s.length);\n        let res;\n        try {\n          res = await sendAndConfirm(txns_s);\n          // XXX we should inspect res and if we failed because we didn't get picked out of the queue, then we shouldn't error, but should retry and let the timeout logic happen.\n          debug(dhead, '--- SUCCESS:', res);\n        } catch (e) {\n          if (e.type == 'sendRawTransaction') {\n            if (!soloSend) {\n              debug(dhead, '--- FAIL:', format_failed_request(e.e));\n            } else {\n              throw Error(`${dhead} --- FAIL:\\n${format_failed_request(e.e)}`);\n            }\n          } else {\n            if (!soloSend) {\n              debug(dhead, '--- FAIL:', e);\n            } else {\n              throw Error(`${dhead} --- FAIL:\\n${JSON.stringify(e)}`);\n            }\n          }\n        }\n        return await doRecv(false);\n      }\n    };\n    const recv = async (funcNum, evt_cnt, tys, waitIfNotPresent, timeout_delay) => {\n      // Ignoring this, because no ALGO dev node\n      void(waitIfNotPresent);\n      const funcName = `m${funcNum}`;\n      const dhead = `${shad}: ${label} recv ${funcName} ${timeout_delay}`;\n      debug(dhead, '--- START');\n      const handler = bin_comp.steps[funcNum];\n      if (!handler) {\n        throw Error(`${dhead} Internal error: reference to undefined handler: ${funcName}`);\n      }\n      const timeoutRound = timeout_delay ?\n        lastRound + timeout_delay.toNumber() :\n        undefined;\n      while (true) {\n        const currentRound = await getLastRound();\n        if (timeoutRound && timeoutRound < currentRound) {\n          return { didTimeout: true };\n        }\n        let hquery = indexer.searchForTransactions()\n          .address(handler.hash)\n          .addressRole('sender')\n          // Look at the next one after the last message\n          // XXX when we implement firstMsg, this won't work on the first\n          // message\n          .minRound(lastRound + 1);\n        if (timeoutRound) {\n          hquery = hquery.maxRound(timeoutRound);\n        }\n        const htxn = await doQuery(dhead, hquery);\n        if (!htxn) {\n          // XXX perhaps wait until a new round has happened using wait\n          await Timeout.set(2000);\n          continue;\n        }\n        debug(dhead, '--- htxn =', htxn);\n        const theRound = htxn['confirmed-round'];\n        let query = indexer.searchForTransactions()\n          .applicationID(ApplicationID)\n          .txType('appl')\n          .round(theRound);\n        const txn = await doQuery(dhead, query);\n        if (!txn) {\n          // XXX This is probably really bad\n          continue;\n        }\n        debug(dhead, '--- txn =', txn);\n        const ctc_args = txn['application-transaction']['application-args'];\n        debug(dhead, '--- ctc_args =', ctc_args);\n        const args = argsSlice(ctc_args, evt_cnt);\n        debug(dhead, '--- args =', args);\n        /** @description base64->hex->arrayify */\n        const reNetify = (x) => {\n          const s = Buffer.from(x, 'base64').toString('hex');\n          debug(dhead, '--- reNetify(', x, ') = ', s);\n          return ethers.utils.arrayify('0x' + s);\n        };\n        debug(dhead, '--- tys =', tys);\n        const args_un = args.map((x, i) => tys[i].fromNet(reNetify(x)));\n        debug(dhead, '--- args_un =', args_un);\n        const totalFromFee = T_UInt.fromNet(reNetify(ctc_args[3]));\n        debug(dhead, '--- totalFromFee =', totalFromFee);\n        const fromAddr = htxn['payment-transaction'].receiver;\n        const from = T_Address.canonicalize({ addr: fromAddr });\n        debug(dhead, '--- from =', from, '=', fromAddr);\n        const oldLastRound = lastRound;\n        lastRound = theRound;\n        debug(dhead, '--- updating round from', oldLastRound, 'to', lastRound);\n        const getOutput = (o_lab, o_ctc) => {\n          void(o_lab);\n          void(o_ctc);\n          throw Error(`Algorand does not support remote calls`);\n        };\n        return {\n          didTimeout: false,\n          data: args_un,\n          time: bigNumberify(lastRound),\n          from,\n          getOutput,\n        };\n      }\n    };\n    const creationTime = async () => bigNumberify((await getInfo()).creationRound);\n    const views_bin = bin._getViews({ reachStdlib: compiledStdlib });\n    const getView1 = (vs, v, k, vim) => async () => {\n      void(v);\n      void(k);\n      const { decode } = vim;\n      const client = await getAlgodClient();\n      const appInfo = await client.getApplicationByID(ApplicationID).do();\n      const appSt = appInfo['params']['global-state'];\n      const viewSt = (appSt.find((x) => x.key === 'dg==')).value;\n      debug({ viewSt });\n      const vvn = base64ToUI8A(viewSt.bytes);\n      debug({ vvn });\n      const vin = T_UInt.fromNet(vvn.slice(0, T_UInt.netSize));\n      const vi = bigNumberToNumber(vin);\n      debug({ vi });\n      const vtys = vs[vi];\n      debug({ vtys });\n      const vty = T_Tuple([T_UInt, ...vtys]);\n      debug({ vty });\n      const vvs = vty.fromNet(vvn);\n      debug({ vvs });\n      const vres = decode(vi, vvs.slice(1));\n      debug({ vres });\n      return vres;\n    };\n    const getViews = getViewsHelper(views_bin, getView1);\n    return { getInfo, creationTime, sendrecv, recv, wait, iam, selfAddress, getViews, stdlib: compiledStdlib };\n  };\n  const deployP = async (bin) => {\n    must_be_supported(bin);\n    debug(shad, 'deploy');\n    const algob = bin._Connectors.ALGO;\n    const { appApproval0, appClear } = algob;\n    const Deployer = thisAcc.addr;\n    const appApproval0_subst = replaceAddr('Deployer', Deployer, appApproval0);\n    const appApproval0_bin = await compileTEAL('appApproval0', appApproval0_subst);\n    const appClear_bin = await compileTEAL('appClear', appClear);\n    const createRes = await sign_and_send_sync('ApplicationCreate', thisAcc, algosdk.makeApplicationCreateTxn(thisAcc.addr, await getTxnParams(), algosdk.OnApplicationComplete.NoOpOC, appApproval0_bin.result, appClear_bin.result, 0, 0, 2, 2));\n    const ApplicationID = createRes['application-index'];\n    if (!ApplicationID) {\n      throw Error(`No application-index in ${JSON.stringify(createRes)}`);\n    }\n    const bin_comp = await compileFor(bin, { ApplicationID, Deployer, creationRound: 0 });\n    const escrowAddr = bin_comp.ctc.hash;\n    const params = await getTxnParams();\n    const txnUpdate = algosdk.makeApplicationUpdateTxn(thisAcc.addr, params, ApplicationID, bin_comp.appApproval.result, appClear_bin.result);\n    const txnToContract = algosdk.makePaymentTxnWithSuggestedParams(thisAcc.addr, escrowAddr, raw_minimumBalance, undefined, ui8z, params);\n    const txns = [\n      txnUpdate,\n      txnToContract,\n    ];\n    algosdk.assignGroupID(txns);\n    regroup(thisAcc, txns);\n    const txnUpdate_s = await signTxn(thisAcc, txnUpdate);\n    const txnToContract_s = await signTxn(thisAcc, txnToContract);\n    const txns_s = [\n      txnUpdate_s,\n      txnToContract_s,\n    ];\n    let updateRes;\n    try {\n      updateRes = await sendAndConfirm(txns_s);\n    } catch (e) {\n      throw Error(`deploy: ${JSON.stringify(e)}`);\n    }\n    const creationRound = updateRes['confirmed-round'];\n    const getInfo = async () => ({ ApplicationID, creationRound, Deployer });\n    debug(shad, 'application created');\n    return await attachP(bin, getInfo());\n  };\n  const implNow = { stdlib: compiledStdlib };\n  const attach = (bin, ctcInfoP) => {\n    return deferContract(false, attachP(bin, ctcInfoP), implNow);\n  };\n  const deploy = (bin) => {\n    return deferContract(false, deployP(bin), implNow);\n  };\n\n  function setDebugLabel(newLabel) {\n    label = newLabel;\n    // @ts-ignore\n    return this;\n  }\n  return { deploy, attach, networkAccount, getAddress: selfAddress, stdlib: compiledStdlib, setDebugLabel };\n};\nexport const balanceOf = async (acc) => {\n  const { networkAccount } = acc;\n  if (!networkAccount)\n    throw Error(`acc.networkAccount missing. Got: ${acc}`);\n  const client = await getAlgodClient();\n  const { amount } = await client.accountInformation(networkAccount.addr).do();\n  return bigNumberify(amount);\n};\nexport const createAccount = async () => {\n  const networkAccount = algosdk.generateAccount();\n  return await connectAccount(networkAccount);\n};\nexport const fundFromFaucet = async (account, value) => {\n  const faucet = await getFaucet();\n  await transfer(faucet, account, value);\n};\nexport const newTestAccount = async (startingBalance) => {\n  const account = await createAccount();\n  await fundFromFaucet(account, startingBalance);\n  return account;\n};\n/** @description the display name of the standard unit of currency for the network */\nexport const standardUnit = 'ALGO';\n/** @description the display name of the atomic (smallest) unit of currency for the network */\nexport const atomicUnit = 'Î¼ALGO';\n/**\n * @description  Parse currency by network\n * @param amt  value in the {@link standardUnit} for the network.\n * @returns  the amount in the {@link atomicUnit} of the network.\n * @example  parseCurrency(100).toString() // => '100000000'\n */\nexport function parseCurrency(amt) {\n  const numericAmt = isBigNumber(amt) ? amt.toNumber() :\n    typeof amt === 'string' ? parseFloat(amt) :\n    amt;\n  return bigNumberify(algosdk.algosToMicroalgos(numericAmt));\n}\n// XXX get from SDK\nconst raw_minimumBalance = 100000;\nexport const minimumBalance = bigNumberify(raw_minimumBalance);\n/**\n * @description  Format currency by network\n * @param amt  the amount in the {@link atomicUnit} of the network.\n * @param decimals  up to how many decimal places to display in the {@link standardUnit}.\n *   Trailing zeroes will be omitted. Excess decimal places will be truncated. (not rounded)\n *   This argument defaults to maximum precision.\n * @returns  a string representation of that amount in the {@link standardUnit} for that network.\n * @example  formatCurrency(bigNumberify('100000000')); // => '100'\n */\nexport function formatCurrency(amt, decimals = 6) {\n  // Recall that 1 algo = 10^6 microalgos\n  if (!(Number.isInteger(decimals) && 0 <= decimals)) {\n    throw Error(`Expected decimals to be a nonnegative integer, but got ${decimals}.`);\n  }\n  // Use decimals+1 and then slice it off to truncate instead of round\n  const algosStr = algosdk\n    .microalgosToAlgos(bigNumberify(amt).toNumber())\n    .toFixed(decimals + 1);\n  // Have to roundtrip thru Number to drop trailing zeroes\n  return Number(algosStr.slice(0, algosStr.length - 1)).toString();\n}\n// XXX The getDefaultAccount pattern doesn't really work w/ AlgoSigner\n// AlgoSigner does not expose a \"currently-selected account\"\nexport async function getDefaultAccount() {\n  if (!window.prompt) {\n    throw Error(`Cannot prompt the user for default account with window.prompt`);\n  }\n  const signStrategy = getSignStrategy();\n  if (signStrategy === 'mnemonic') {\n    const mnemonic = window.prompt(`Please paste the mnemonic for your account, or cancel to generate a new one`);\n    if (mnemonic) {\n      debug(`Creating account from user-provided mnemonic`);\n      return await newAccountFromMnemonic(mnemonic);\n    } else {\n      debug(`No mnemonic provided. Randomly generating a new account secret instead.`);\n      return await createAccount();\n    }\n  } else if (signStrategy === 'AlgoSigner') {\n    const AlgoSigner = await getAlgoSigner();\n    const ledger = getLedgerFromAlgoSigner(AlgoSigner);\n    if (ledger === undefined)\n      throw Error(`Ledger is undefined; this is required by AlgoSigner`);\n    const addr = window.prompt(`Please paste your account's address. (This account must be listed in AlgoSigner.)`);\n    if (!addr) {\n      throw Error(`No address provided`);\n    }\n    return await newAccountFromAlgoSigner(addr, AlgoSigner, ledger);\n  } else if (signStrategy === 'MyAlgo') {\n    throw Error(`MyAlgo wallet support is not yet implemented`);\n  } else {\n    throw Error(`signStrategy '${signStrategy}' not recognized. Valid options are 'mnemonic', 'AlgoSigner', and 'MyAlgo'.`);\n  }\n}\n/**\n * @param mnemonic 25 words, space-separated\n */\nexport const newAccountFromMnemonic = async (mnemonic) => {\n  return await connectAccount(algosdk.mnemonicToSecretKey(mnemonic));\n};\n/**\n * @param secret a Uint8Array, or its hex string representation\n */\nexport const newAccountFromSecret = async (secret) => {\n  const sk = ethers.utils.arrayify(secret);\n  const mnemonic = algosdk.secretKeyToMnemonic(sk);\n  return await newAccountFromMnemonic(mnemonic);\n};\nexport const newAccountFromAlgoSigner = async (addr, AlgoSigner, ledger) => {\n  if (!AlgoSigner) {\n    throw Error(`AlgoSigner is falsy`);\n  }\n  const accts = await AlgoSigner.accounts({ ledger });\n  if (!Array.isArray(accts)) {\n    throw Error(`AlgoSigner.accounts('${ledger}') is not an array: ${accts}`);\n  }\n  if (!accts.map(x => x.address).includes(addr)) {\n    throw Error(`Address ${addr} not found in AlgoSigner accounts`);\n  }\n  let networkAccount = { addr, AlgoSigner };\n  return await connectAccount(networkAccount);\n};\nexport const getNetworkTime = async () => bigNumberify(await getLastRound());\nexport const waitUntilTime = async (targetTime, onProgress) => {\n  const onProg = onProgress || (() => {});\n  let currentTime = await getNetworkTime();\n  while (currentTime.lt(targetTime)) {\n    debug('waitUntilTime: iteration:', currentTime, '->', targetTime);\n    const status = await (await getAlgodClient()).statusAfterBlock(currentTime.toNumber()).do();\n    currentTime = bigNumberify(status['last-round']);\n    onProg({ currentTime, targetTime });\n  }\n  debug('waitUntilTime: ended:', currentTime, '->', targetTime);\n  return currentTime;\n};\nexport const wait = async (delta, onProgress) => {\n  const now = await getNetworkTime();\n  debug('wait: delta=', delta, 'now=', now, 'until=', now.add(delta));\n  return await waitUntilTime(now.add(delta), onProgress);\n};\nexport const verifyContract = async (info, bin) => {\n  const { ApplicationID, Deployer, creationRound } = info;\n  const compiled = await compileFor(bin, info);\n  const { appApproval, appClear } = compiled;\n  let dhead = `verifyContract`;\n  const chk = (p, msg) => {\n    if (!p) {\n      throw Error(`verifyContract failed: ${msg}`);\n    }\n  };\n  const chkeq = (a, e, msg) => {\n    const as = JSON.stringify(a);\n    const es = JSON.stringify(e);\n    chk(as === es, `${msg}: expected ${es}, got ${as}`);\n  };\n  const client = await getAlgodClient();\n  const appInfo = await client.getApplicationByID(ApplicationID).do();\n  const appInfo_p = appInfo['params'];\n  debug(dhead, '-- appInfo_p =', appInfo_p);\n  const indexer = await getIndexer();\n  const cquery = indexer.searchForTransactions()\n    .applicationID(ApplicationID)\n    .txType('appl')\n    .round(creationRound);\n  let ctxn = null;\n  while (!ctxn) {\n    const cres = await doQuery_(dhead, cquery);\n    if (cres['current-round'] < creationRound) {\n      debug(dhead, '-- waiting for creationRound');\n      await Timeout.set(1000);\n      continue;\n    }\n    ctxn = cres.transactions[0];\n  }\n  debug(dhead, '-- ctxn =', ctxn);\n  const fmtp = (x) => uint8ArrayToStr(x.result, 'base64');\n  chk(ctxn, `Cannot query for creationRound accuracy`);\n  chk(appInfo_p, `Cannot lookup ApplicationId`);\n  chkeq(appInfo_p['approval-program'], fmtp(appApproval), `Approval program does not match Reach backend`);\n  chkeq(appInfo_p['clear-state-program'], fmtp(appClear), `ClearState program does not match Reach backend`);\n  chkeq(appInfo_p['creator'], Deployer, `Deployer does not match contract information`);\n  const catxn = ctxn['application-transaction'];\n  chkeq(catxn['approval-program'], appInfo_p['approval-program'], `creationRound Approval program`);\n  chkeq(catxn['clear-state-program'], appInfo_p['clear-state-program'], `creationRound ClearState program`);\n  chkeq(catxn['on-completion'], 'update', `creationRound on-completion`);\n  chkeq(ctxn['sender'], Deployer, `creationRound Deployer`);\n  // Note: (after deployMode:firstMsg is implemented)\n  // 1. (above) attach initial args to ContractInfo\n  // 2. verify contract storage matches expectations based on initial args\n  return true;\n};\nexport const reachStdlib = compiledStdlib;\n"]},"metadata":{},"sourceType":"module"}