{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst txnBuilder = require('./transaction');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst encoding = require('./encoding/encoding');\n\nconst address = require('./encoding/address');\n\nconst utils = require('./utils/utils');\n\nconst ALGORAND_MAX_TX_GROUP_SIZE = 16;\n/**\n * Aux class for group id calculation of a group of transactions\n */\n\nclass TxGroup {\n  constructor(hashes) {\n    if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {\n      const errorMsg = `${hashes.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;\n      throw Error(errorMsg);\n    }\n\n    this.name = 'Transaction group';\n    this.tag = Buffer.from('TG');\n    this.txGroupHashes = hashes;\n  } // eslint-disable-next-line camelcase\n\n\n  get_obj_for_encoding() {\n    const txgroup = {\n      txlist: this.txGroupHashes\n    };\n    return txgroup;\n  } // eslint-disable-next-line camelcase\n\n\n  static from_obj_for_encoding(txgroupForEnc) {\n    const txn = Object.create(this.prototype);\n    txn.name = 'Transaction group';\n    txn.tag = Buffer.from('TG');\n    txn.txGroupHashes = [];\n\n    for (const hash of txgroupForEnc.txlist) {\n      txn.txGroupHashes.push(Buffer.from(hash));\n    }\n\n    return txn;\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n\n}\n/**\n * computeGroupID returns group ID for a group of transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @return Buffer\n */\n\n\nfunction computeGroupID(txns) {\n  const hashes = [];\n\n  for (const txn of txns) {\n    let tx = txn;\n\n    if (!(txn instanceof txnBuilder.Transaction)) {\n      tx = new txnBuilder.Transaction(txn);\n    }\n\n    hashes.push(tx.rawTxID());\n  }\n\n  const txgroup = new TxGroup(hashes);\n  const bytes = txgroup.toByte();\n  const toBeHashed = Buffer.from(utils.concatArrays(txgroup.tag, bytes));\n  const gid = nacl.genericHash(toBeHashed);\n  return Buffer.from(gid);\n}\n/**\n * assignGroupID assigns group id to a given list of unsigned transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @param from optional sender address specifying which transaction return\n * @return possible list of matching transactions\n */\n\n\nfunction assignGroupID(txns, from = undefined) {\n  const gid = computeGroupID(txns);\n  const result = [];\n\n  for (const txn of txns) {\n    if (!from || address.encodeAddress(txn.from.publicKey) === from) {\n      let tx = txn;\n\n      if (!(tx instanceof txnBuilder.Transaction)) {\n        tx = new txnBuilder.Transaction(txn);\n      }\n\n      tx.group = gid;\n      result.push(tx);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  TxGroup,\n  computeGroupID,\n  assignGroupID\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/algosdk/src/group.js"],"names":["Buffer","require","txnBuilder","nacl","encoding","address","utils","ALGORAND_MAX_TX_GROUP_SIZE","TxGroup","constructor","hashes","length","errorMsg","toString","Error","name","tag","from","txGroupHashes","get_obj_for_encoding","txgroup","txlist","from_obj_for_encoding","txgroupForEnc","txn","Object","create","prototype","hash","push","toByte","encode","computeGroupID","txns","tx","Transaction","rawTxID","bytes","toBeHashed","concatArrays","gid","genericHash","assignGroupID","undefined","result","encodeAddress","publicKey","group","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst txnBuilder = require('./transaction');\nconst nacl = require('./nacl/naclWrappers');\nconst encoding = require('./encoding/encoding');\nconst address = require('./encoding/address');\nconst utils = require('./utils/utils');\n\nconst ALGORAND_MAX_TX_GROUP_SIZE = 16;\n\n/**\n * Aux class for group id calculation of a group of transactions\n */\nclass TxGroup {\n  constructor(hashes) {\n    if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {\n      const errorMsg = `${hashes.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;\n      throw Error(errorMsg);\n    }\n\n    this.name = 'Transaction group';\n    this.tag = Buffer.from('TG');\n\n    this.txGroupHashes = hashes;\n  }\n\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const txgroup = {\n      txlist: this.txGroupHashes,\n    };\n    return txgroup;\n  }\n\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(txgroupForEnc) {\n    const txn = Object.create(this.prototype);\n    txn.name = 'Transaction group';\n    txn.tag = Buffer.from('TG');\n    txn.txGroupHashes = [];\n    for (const hash of txgroupForEnc.txlist) {\n      txn.txGroupHashes.push(Buffer.from(hash));\n    }\n    return txn;\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n}\n\n/**\n * computeGroupID returns group ID for a group of transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @return Buffer\n */\nfunction computeGroupID(txns) {\n  const hashes = [];\n  for (const txn of txns) {\n    let tx = txn;\n    if (!(txn instanceof txnBuilder.Transaction)) {\n      tx = new txnBuilder.Transaction(txn);\n    }\n    hashes.push(tx.rawTxID());\n  }\n\n  const txgroup = new TxGroup(hashes);\n\n  const bytes = txgroup.toByte();\n  const toBeHashed = Buffer.from(utils.concatArrays(txgroup.tag, bytes));\n  const gid = nacl.genericHash(toBeHashed);\n  return Buffer.from(gid);\n}\n\n/**\n * assignGroupID assigns group id to a given list of unsigned transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @param from optional sender address specifying which transaction return\n * @return possible list of matching transactions\n */\nfunction assignGroupID(txns, from = undefined) {\n  const gid = computeGroupID(txns);\n  const result = [];\n  for (const txn of txns) {\n    if (!from || address.encodeAddress(txn.from.publicKey) === from) {\n      let tx = txn;\n      if (!(tx instanceof txnBuilder.Transaction)) {\n        tx = new txnBuilder.Transaction(txn);\n      }\n      tx.group = gid;\n      result.push(tx);\n    }\n  }\n  return result;\n}\n\nmodule.exports = {\n  TxGroup,\n  computeGroupID,\n  assignGroupID,\n};\n"]},"metadata":{},"sourceType":"script"}