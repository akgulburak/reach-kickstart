{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Decoder = exports.DecodeError = exports.DataViewIndexOutOfBoundsError = void 0;\n\nconst prettyByte_1 = require(\"./utils/prettyByte\");\n\nconst ExtensionCodec_1 = require(\"./ExtensionCodec\");\n\nconst int_1 = require(\"./utils/int\");\n\nconst utf8_1 = require(\"./utils/utf8\");\n\nconst typedArrays_1 = require(\"./utils/typedArrays\");\n\nconst CachedKeyDecoder_1 = require(\"./CachedKeyDecoder\");\n\nconst isValidMapKeyType = key => {\n  const keyType = typeof key;\n  return keyType === \"string\" || keyType === \"number\";\n};\n\nconst HEAD_BYTE_REQUIRED = -1;\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer); // IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\n\nexports.DataViewIndexOutOfBoundsError = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e) {\n    return e.constructor;\n  }\n\n  throw new Error(\"never reached\");\n})();\n\nconst MORE_DATA = new exports.DataViewIndexOutOfBoundsError(\"Insufficient data\");\nconst DEFAULT_MAX_LENGTH = 4294967295; // uint32_max\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();\n\nclass DecodeError extends Error {\n  constructor(message) {\n    super(message); // fix the prototype chain in a cross-platform way\n\n    const proto = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name\n    });\n  }\n\n}\n\nexports.DecodeError = DecodeError;\n\nclass Decoder {\n  constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = undefined, maxStrLength = DEFAULT_MAX_LENGTH, maxBinLength = DEFAULT_MAX_LENGTH, maxArrayLength = DEFAULT_MAX_LENGTH, maxMapLength = DEFAULT_MAX_LENGTH, maxExtLength = DEFAULT_MAX_LENGTH, keyDecoder = sharedCachedKeyDecoder) {\n    this.extensionCodec = extensionCodec;\n    this.context = context;\n    this.maxStrLength = maxStrLength;\n    this.maxBinLength = maxBinLength;\n    this.maxArrayLength = maxArrayLength;\n    this.maxMapLength = maxMapLength;\n    this.maxExtLength = maxExtLength;\n    this.keyDecoder = keyDecoder;\n    this.totalPos = 0;\n    this.pos = 0;\n    this.view = EMPTY_VIEW;\n    this.bytes = EMPTY_BYTES;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack = [];\n  }\n\n  reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0; // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  setBuffer(buffer) {\n    this.bytes = typedArrays_1.ensureUint8Array(buffer);\n    this.view = typedArrays_1.createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  appendBuffer(buffer) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining()) {\n      this.setBuffer(buffer);\n    } else {\n      // retried because data is insufficient\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = typedArrays_1.ensureUint8Array(buffer);\n      const concated = new Uint8Array(remainingData.length + newData.length);\n      concated.set(remainingData);\n      concated.set(newData, remainingData.length);\n      this.setBuffer(concated);\n    }\n  }\n\n  hasRemaining(size = 1) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  createExtraByteError(posToShow) {\n    const {\n      view,\n      pos\n    } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  decode(buffer) {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n    const object = this.doDecodeSync();\n\n    if (this.hasRemaining()) {\n      throw this.createExtraByteError(this.pos);\n    }\n\n    return object;\n  }\n\n  *decodeMulti(buffer) {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    while (this.hasRemaining()) {\n      yield this.doDecodeSync();\n    }\n  }\n\n  async decodeAsync(stream) {\n    let decoded = false;\n    let object;\n\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        } // fallthrough\n\n      }\n\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining()) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      return object;\n    }\n\n    const {\n      headByte,\n      pos,\n      totalPos\n    } = this;\n    throw new RangeError(`Insufficient data in parsing ${prettyByte_1.prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);\n  }\n\n  decodeArrayStream(stream) {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  decodeStream(stream) {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  async *decodeMultiAsync(stream, isArray) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        } // fallthrough\n\n      }\n\n      this.totalPos += this.pos;\n    }\n  }\n\n  doDecodeSync() {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte_1.prettyByte(headByte)}`);\n      }\n\n      this.complete();\n      const stack = this.stack;\n\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1];\n\n        if (state.type === 0\n        /* ARRAY */\n        ) {\n            state.array[state.position] = object;\n            state.position++;\n\n            if (state.position === state.size) {\n              stack.pop();\n              object = state.array;\n            } else {\n              continue DECODE;\n            }\n          } else if (state.type === 1\n        /* MAP_KEY */\n        ) {\n            if (!isValidMapKeyType(object)) {\n              throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n            }\n\n            if (object === \"__proto__\") {\n              throw new DecodeError(\"The key __proto__ is not allowed\");\n            }\n\n            state.key = object;\n            state.type = 2\n            /* MAP_VALUE */\n            ;\n            continue DECODE;\n          } else {\n          // it must be `state.type === State.MAP_VALUE` here\n          state.map[state.key] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = 1\n            /* MAP_KEY */\n            ;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  readHeadByte() {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8(); // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  complete() {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  readArraySize() {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n\n      case 0xdd:\n        return this.readU32();\n\n      default:\n        {\n          if (headByte < 0xa0) {\n            return headByte - 0x90;\n          } else {\n            throw new DecodeError(`Unrecognized array type byte: ${prettyByte_1.prettyByte(headByte)}`);\n          }\n        }\n    }\n  }\n\n  pushMapState(size) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: 1\n      /* MAP_KEY */\n      ,\n      size,\n      key: null,\n      readCount: 0,\n      map: {}\n    });\n  }\n\n  pushArrayState(size) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: 0\n      /* ARRAY */\n      ,\n      size,\n      array: new Array(size),\n      position: 0\n    });\n  }\n\n  decodeUtf8String(byteLength, headerOffset) {\n    var _a;\n\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object;\n\n    if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {\n      object = utf8_1.utf8DecodeTD(this.bytes, offset, byteLength);\n    } else {\n      object = utf8_1.utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  stateIsMapKey() {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1];\n      return state.type === 1\n      /* MAP_KEY */\n      ;\n    }\n\n    return false;\n  }\n\n  decodeBinary(byteLength, headOffset) {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  decodeExtension(size, headOffset) {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1\n    /* extType */\n    );\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  readU8() {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  readI8() {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  readU16() {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  readI16() {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  readU32() {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  readI32() {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  readU64() {\n    const value = int_1.getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  readI64() {\n    const value = int_1.getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n}\n\nexports.Decoder = Decoder;","map":{"version":3,"sources":["../src/Decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decoder = exports.DecodeError = exports.DataViewIndexOutOfBoundsError = void 0;\nconst prettyByte_1 = require(\"./utils/prettyByte\");\nconst ExtensionCodec_1 = require(\"./ExtensionCodec\");\nconst int_1 = require(\"./utils/int\");\nconst utf8_1 = require(\"./utils/utf8\");\nconst typedArrays_1 = require(\"./utils/typedArrays\");\nconst CachedKeyDecoder_1 = require(\"./CachedKeyDecoder\");\nconst isValidMapKeyType = (key) => {\n    const keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nconst HEAD_BYTE_REQUIRED = -1;\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexports.DataViewIndexOutOfBoundsError = (() => {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nconst MORE_DATA = new exports.DataViewIndexOutOfBoundsError(\"Insufficient data\");\nconst DEFAULT_MAX_LENGTH = 4294967295; // uint32_max\nconst sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();\nclass DecodeError extends Error {\n    constructor(message) {\n        super(message);\n        // fix the prototype chain in a cross-platform way\n        const proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(this, proto);\n        Object.defineProperty(this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n    }\n}\nexports.DecodeError = DecodeError;\nclass Decoder {\n    constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = undefined, maxStrLength = DEFAULT_MAX_LENGTH, maxBinLength = DEFAULT_MAX_LENGTH, maxArrayLength = DEFAULT_MAX_LENGTH, maxMapLength = DEFAULT_MAX_LENGTH, maxExtLength = DEFAULT_MAX_LENGTH, keyDecoder = sharedCachedKeyDecoder) {\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    reinitializeState() {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    }\n    setBuffer(buffer) {\n        this.bytes = typedArrays_1.ensureUint8Array(buffer);\n        this.view = typedArrays_1.createDataView(this.bytes);\n        this.pos = 0;\n    }\n    appendBuffer(buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining()) {\n            this.setBuffer(buffer);\n        }\n        else {\n            // retried because data is insufficient\n            const remainingData = this.bytes.subarray(this.pos);\n            const newData = typedArrays_1.ensureUint8Array(buffer);\n            const concated = new Uint8Array(remainingData.length + newData.length);\n            concated.set(remainingData);\n            concated.set(newData, remainingData.length);\n            this.setBuffer(concated);\n        }\n    }\n    hasRemaining(size = 1) {\n        return this.view.byteLength - this.pos >= size;\n    }\n    createExtraByteError(posToShow) {\n        const { view, pos } = this;\n        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n    }\n    decode(buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        const object = this.doDecodeSync();\n        if (this.hasRemaining()) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    }\n    *decodeMulti(buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        while (this.hasRemaining()) {\n            yield this.doDecodeSync();\n        }\n    }\n    async decodeAsync(stream) {\n        let decoded = false;\n        let object;\n        for await (const buffer of stream) {\n            if (decoded) {\n                throw this.createExtraByteError(this.totalPos);\n            }\n            this.appendBuffer(buffer);\n            try {\n                object = this.doDecodeSync();\n                decoded = true;\n            }\n            catch (e) {\n                if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {\n                    throw e; // rethrow\n                }\n                // fallthrough\n            }\n            this.totalPos += this.pos;\n        }\n        if (decoded) {\n            if (this.hasRemaining()) {\n                throw this.createExtraByteError(this.totalPos);\n            }\n            return object;\n        }\n        const { headByte, pos, totalPos } = this;\n        throw new RangeError(`Insufficient data in parsing ${prettyByte_1.prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);\n    }\n    decodeArrayStream(stream) {\n        return this.decodeMultiAsync(stream, true);\n    }\n    decodeStream(stream) {\n        return this.decodeMultiAsync(stream, false);\n    }\n    async *decodeMultiAsync(stream, isArray) {\n        let isArrayHeaderRequired = isArray;\n        let arrayItemsLeft = -1;\n        for await (const buffer of stream) {\n            if (isArray && arrayItemsLeft === 0) {\n                throw this.createExtraByteError(this.totalPos);\n            }\n            this.appendBuffer(buffer);\n            if (isArrayHeaderRequired) {\n                arrayItemsLeft = this.readArraySize();\n                isArrayHeaderRequired = false;\n                this.complete();\n            }\n            try {\n                while (true) {\n                    yield this.doDecodeSync();\n                    if (--arrayItemsLeft === 0) {\n                        break;\n                    }\n                }\n            }\n            catch (e) {\n                if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {\n                    throw e; // rethrow\n                }\n                // fallthrough\n            }\n            this.totalPos += this.pos;\n        }\n    }\n    doDecodeSync() {\n        DECODE: while (true) {\n            const headByte = this.readHeadByte();\n            let object;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    const size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    const size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    const byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                const byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                const byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                const byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                const size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                const size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                const size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                const size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                const size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                const size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new DecodeError(`Unrecognized type byte: ${prettyByte_1.prettyByte(headByte)}`);\n            }\n            this.complete();\n            const stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                const state = stack[stack.length - 1];\n                if (state.type === 0 /* ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    }\n    readHeadByte() {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    }\n    complete() {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    }\n    readArraySize() {\n        const headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new DecodeError(`Unrecognized array type byte: ${prettyByte_1.prettyByte(headByte)}`);\n                }\n            }\n        }\n    }\n    pushMapState(size) {\n        if (size > this.maxMapLength) {\n            throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n        }\n        this.stack.push({\n            type: 1 /* MAP_KEY */,\n            size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    }\n    pushArrayState(size) {\n        if (size > this.maxArrayLength) {\n            throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n        }\n        this.stack.push({\n            type: 0 /* ARRAY */,\n            size,\n            array: new Array(size),\n            position: 0,\n        });\n    }\n    decodeUtf8String(byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headerOffset;\n        let object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {\n            object = utf8_1.utf8DecodeTD(this.bytes, offset, byteLength);\n        }\n        else {\n            object = utf8_1.utf8DecodeJs(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    }\n    stateIsMapKey() {\n        if (this.stack.length > 0) {\n            const state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* MAP_KEY */;\n        }\n        return false;\n    }\n    decodeBinary(byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headOffset;\n        const object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    }\n    decodeExtension(size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n        }\n        const extType = this.view.getInt8(this.pos + headOffset);\n        const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    }\n    lookU8() {\n        return this.view.getUint8(this.pos);\n    }\n    lookU16() {\n        return this.view.getUint16(this.pos);\n    }\n    lookU32() {\n        return this.view.getUint32(this.pos);\n    }\n    readU8() {\n        const value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readI8() {\n        const value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readU16() {\n        const value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readI16() {\n        const value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readI32() {\n        const value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readU64() {\n        const value = int_1.getUint64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readI64() {\n        const value = int_1.getInt64(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readF32() {\n        const value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readF64() {\n        const value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n}\nexports.Decoder = Decoder;\n//# sourceMappingURL=Decoder.js.map"]},"metadata":{},"sourceType":"script"}