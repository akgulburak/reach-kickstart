{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst request = require('superagent');\n\nconst utils = require('../utils/utils');\n\nfunction createJSONParser(options) {\n  // eslint-disable-next-line consistent-return\n  return (res, fn) => {\n    if (typeof fn === 'string') {\n      // in browser\n      return fn && utils.parseJSON(fn, options);\n    } // in node\n    // based off https://github.com/visionmedia/superagent/blob/1277a880c32191e300b229e352e0633e421046c8/src/node/parsers/json.js\n\n\n    res.text = '';\n    res.setEncoding('utf8');\n    res.on('data', chunk => {\n      res.text += chunk;\n    });\n    res.on('end', () => {\n      let body;\n      let err;\n\n      try {\n        body = res.text && utils.parseJSON(res.text, options);\n      } catch (err_) {\n        err = err_; // issue #675: return the raw response if the response parsing fails\n\n        err.rawResponse = res.text || null; // issue #876: return the http status code if the response parsing fails\n\n        err.statusCode = res.statusCode;\n      } finally {\n        fn(err, body);\n      }\n    });\n  };\n}\n/**\n * removeEmpty gets a dictionary and removes empty values\n * @param obj\n * @returns {*}\n */\n\n\nfunction removeEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n\n  return obj;\n}\n/**\n * getAccceptFormat returns the correct Accept header depending on the\n * requested format.\n * @param query\n * @returns {string}\n */\n\n\nfunction getAccceptFormat(query) {\n  if (query !== undefined && Object.prototype.hasOwnProperty.call(query, 'format')) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n\n      case 'json':\n        return 'application/json';\n\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n\nfunction HTTPClient(token, baseServer, port, headers = {}) {\n  // Do not need colon if port is empty\n  let baseServerWithPort = baseServer;\n\n  if (port !== '') {\n    baseServerWithPort += `:${port.toString()}`;\n  }\n\n  this.address = baseServerWithPort;\n  this.token = token;\n  this.defaultHeaders = headers;\n  /**\n   * Send a GET request.\n   * @param {string} path The path of the request.\n   * @param {object} query An object containing the query paramters of the request.\n   * @param {object} requestHeaders An object containing additional request headers to use.\n   * @param {object} jsonOptions Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   * @returns {Promise<object>} Response object.\n   */\n\n  this.get = async (path, query, requestHeaders = {}, jsonOptions = {}) => {\n    const format = getAccceptFormat(query);\n    let r = request.get(this.address + path).set(this.token).set(this.defaultHeaders).set(requestHeaders).set('Accept', format).query(removeEmpty(query));\n\n    if (format === 'application/msgpack') {\n      r = r.responseType('arraybuffer');\n    } else if (format === 'application/json' && Object.keys(jsonOptions).length !== 0) {\n      if (r.buffer !== r.ca) {\n        // in node, need to set buffer\n        r = r.buffer(true);\n      }\n\n      r = r.parse(createJSONParser(jsonOptions));\n    }\n\n    const res = await r;\n\n    if (Buffer.isBuffer(res.body)) {\n      // In node res.body will be a Buffer, but in the browser it will be an ArrayBuffer\n      // (thanks superagent...), so convert it to an ArrayBuffer for consistency.\n      const underlyingArrayBuffer = res.body.buffer;\n      const start = res.body.byteOffset;\n      const end = start + res.body.byteLength;\n      res.body = underlyingArrayBuffer.slice(start, end);\n    }\n\n    return res;\n  };\n\n  this.post = async (path, data, requestHeaders = {}) => request.post(this.address + path).set(this.token).set(this.defaultHeaders).set(requestHeaders).send(data);\n\n  this.delete = async (path, data, requestHeaders = {}) => request.delete(this.address + path).set(this.token).set(this.defaultHeaders).set(requestHeaders).send(data);\n}\n\nmodule.exports = {\n  HTTPClient\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/client/client.js"],"names":["Buffer","require","request","utils","createJSONParser","options","res","fn","parseJSON","text","setEncoding","on","chunk","body","err","err_","rawResponse","statusCode","removeEmpty","obj","key","Object","prototype","hasOwnProperty","call","length","getAccceptFormat","query","undefined","format","HTTPClient","token","baseServer","port","headers","baseServerWithPort","toString","address","defaultHeaders","get","path","requestHeaders","jsonOptions","r","set","responseType","keys","buffer","ca","parse","isBuffer","underlyingArrayBuffer","start","byteOffset","end","byteLength","slice","post","data","send","delete","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst request = require('superagent');\nconst utils = require('../utils/utils');\n\nfunction createJSONParser(options) {\n  // eslint-disable-next-line consistent-return\n  return (res, fn) => {\n    if (typeof fn === 'string') {\n      // in browser\n      return fn && utils.parseJSON(fn, options);\n    }\n\n    // in node\n    // based off https://github.com/visionmedia/superagent/blob/1277a880c32191e300b229e352e0633e421046c8/src/node/parsers/json.js\n    res.text = '';\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      res.text += chunk;\n    });\n    res.on('end', () => {\n      let body;\n      let err;\n      try {\n        body = res.text && utils.parseJSON(res.text, options);\n      } catch (err_) {\n        err = err_;\n        // issue #675: return the raw response if the response parsing fails\n        err.rawResponse = res.text || null;\n        // issue #876: return the http status code if the response parsing fails\n        err.statusCode = res.statusCode;\n      } finally {\n        fn(err, body);\n      }\n    });\n  };\n}\n\n/**\n * removeEmpty gets a dictionary and removes empty values\n * @param obj\n * @returns {*}\n */\nfunction removeEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n  return obj;\n}\n\n/**\n * getAccceptFormat returns the correct Accept header depending on the\n * requested format.\n * @param query\n * @returns {string}\n */\nfunction getAccceptFormat(query) {\n  if (\n    query !== undefined &&\n    Object.prototype.hasOwnProperty.call(query, 'format')\n  ) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n      case 'json':\n        return 'application/json';\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n\nfunction HTTPClient(token, baseServer, port, headers = {}) {\n  // Do not need colon if port is empty\n  let baseServerWithPort = baseServer;\n  if (port !== '') {\n    baseServerWithPort += `:${port.toString()}`;\n  }\n  this.address = baseServerWithPort;\n  this.token = token;\n  this.defaultHeaders = headers;\n\n  /**\n   * Send a GET request.\n   * @param {string} path The path of the request.\n   * @param {object} query An object containing the query paramters of the request.\n   * @param {object} requestHeaders An object containing additional request headers to use.\n   * @param {object} jsonOptions Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   * @returns {Promise<object>} Response object.\n   */\n  this.get = async (path, query, requestHeaders = {}, jsonOptions = {}) => {\n    const format = getAccceptFormat(query);\n    let r = request\n      .get(this.address + path)\n      .set(this.token)\n      .set(this.defaultHeaders)\n      .set(requestHeaders)\n      .set('Accept', format)\n      .query(removeEmpty(query));\n\n    if (format === 'application/msgpack') {\n      r = r.responseType('arraybuffer');\n    } else if (\n      format === 'application/json' &&\n      Object.keys(jsonOptions).length !== 0\n    ) {\n      if (r.buffer !== r.ca) {\n        // in node, need to set buffer\n        r = r.buffer(true);\n      }\n      r = r.parse(createJSONParser(jsonOptions));\n    }\n\n    const res = await r;\n    if (Buffer.isBuffer(res.body)) {\n      // In node res.body will be a Buffer, but in the browser it will be an ArrayBuffer\n      // (thanks superagent...), so convert it to an ArrayBuffer for consistency.\n      const underlyingArrayBuffer = res.body.buffer;\n      const start = res.body.byteOffset;\n      const end = start + res.body.byteLength;\n      res.body = underlyingArrayBuffer.slice(start, end);\n    }\n    return res;\n  };\n\n  this.post = async (path, data, requestHeaders = {}) =>\n    request\n      .post(this.address + path)\n      .set(this.token)\n      .set(this.defaultHeaders)\n      .set(requestHeaders)\n      .send(data);\n\n  this.delete = async (path, data, requestHeaders = {}) =>\n    request\n      .delete(this.address + path)\n      .set(this.token)\n      .set(this.defaultHeaders)\n      .set(requestHeaders)\n      .send(data);\n}\n\nmodule.exports = { HTTPClient };\n"]},"metadata":{},"sourceType":"script"}