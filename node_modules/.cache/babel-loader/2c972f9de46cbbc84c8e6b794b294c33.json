{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst client = require('./client');\n\nconst txn = require('../transaction');\n\nfunction Kmd(token, baseServer = 'http://127.0.0.1', port = 7833) {\n  // Get client\n  const c = new client.HTTPClient({\n    'X-KMD-API-Token': token\n  }, baseServer, port);\n  /**\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\n   * @returns {Promise<*>}\n   */\n\n  this.versions = async () => {\n    const res = await c.get('/versions');\n    return res.body;\n  };\n  /**\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listWallets = async () => {\n    const res = await c.get('/v1/wallets');\n    return res.body;\n  };\n  /**\n   * createWallet creates a wallet with the specified name, password, driver,\n   * and master derivation key. If the master derivation key is blank, one is\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\n   * containing information about the new wallet.\n   * @param walletName\n   * @param walletPassword\n   * @param walletDriverName\n   * @param walletMDK\n   * @returns {Promise<*>}\n   */\n\n\n  this.createWallet = async (walletName, walletPassword, walletMDK = '', walletDriverName = 'sqlite') => {\n    const req = {\n      wallet_name: walletName,\n      wallet_driver_name: walletDriverName,\n      wallet_password: walletPassword,\n      master_derivation_key: Buffer.from(walletMDK).toString('base64')\n    };\n    const res = await c.post('/v1/wallet', req);\n    return res.body;\n  };\n  /**\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\n   * initWalletHandleResponse containing a wallet handle token. This wallet\n   * handle token can be used for subsequent operations on this wallet, like key\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\n   * configurable number of seconds, and must be renewed periodically with\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\n   * you're done interacting with this wallet.\n   * @param walletID\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n\n\n  this.initWalletHandle = async (walletID, walletPassword) => {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword\n    };\n    const res = await c.post('/v1/wallet/init', req);\n    return res.body;\n  };\n  /**\n   * releaseWalletHandle invalidates the passed wallet handle token, making\n   * it unusuable for subsequent wallet operations.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.releaseWalletHandle = async walletHandle => {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await c.post('/v1/wallet/release', req);\n    return res.body;\n  };\n  /**\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\n   * the expiration time to some number of seconds in the future. It returns a\n   * RenewWalletHandleResponse containing the walletHandle and the number of\n   * seconds until expiration\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.renewWalletHandle = async walletHandle => {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await c.post('/v1/wallet/renew', req);\n    return res.body;\n  };\n  /**\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\n   * and renames the underlying wallet.\n   * @param walletID\n   * @param walletPassword\n   * @param newWalletName\n   * @returns {Promise<*>}\n   */\n\n\n  this.renameWallet = async (walletID, walletPassword, newWalletName) => {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword,\n      wallet_name: newWalletName\n    };\n    const res = await c.post('/v1/wallet/rename', req);\n    return res.body;\n  };\n  /**\n   * getWallet accepts a wallet handle and returns high level information about\n   * this wallet in a GetWalletResponse.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.getWallet = async walletHandle => {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await c.post('/v1/wallet/info', req);\n    return res.body;\n  };\n  /**\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\n   * returns an ExportMasterDerivationKeyResponse containing the master\n   * derivation key. This key can be used as an argument to CreateWallet in\n   * order to recover the keys generated by this wallet. The master derivation\n   * key can be encoded as a sequence of words using the mnemonic library, and\n   * @param walletHandle\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportMasterDerivationKey = async (walletHandle, walletPassword) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword\n    };\n    const res = await c.post('/v1/master-key/export', req);\n    return {\n      master_derivation_key: Buffer.from(res.body.master_derivation_key, 'base64')\n    };\n  };\n  /**\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\n   * the key into the wallet. It returns an ImportKeyResponse containing the\n   * address corresponding to this private key.\n   * @param walletHandle\n   * @param secretKey\n   * @returns {Promise<*>}\n   */\n\n\n  this.importKey = async (walletHandle, secretKey) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      private_key: Buffer.from(secretKey).toString('base64')\n    };\n    const res = await c.post('/v1/key/import', req);\n    return res.body;\n  };\n  /**\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\n   * address stored in the wallet.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportKey = async (walletHandle, walletPassword, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    const res = await c.post('/v1/key/export', req);\n    return {\n      private_key: Buffer.from(res.body.private_key, 'base64')\n    };\n  };\n  /**\n   * generateKey accepts a wallet handle, and then generates the next key in the\n   * wallet using its internal master derivation key. Two wallets with the same\n   * master derivation key will generate the same sequence of keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.generateKey = async walletHandle => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      display_mnemonic: false\n    };\n    const res = await c.post('/v1/key', req);\n    return res.body;\n  };\n  /**\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\n   * the information about this address from the wallet (including address and\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\n   * the same key will not be generated again. However, if a wallet is recovered\n   * using the master derivation key, a key generated in this way can be\n   * recovered.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.deleteKey = async (walletHandle, walletPassword, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    const res = await c.delete('/v1/key', req);\n    return res.body;\n  };\n  /**\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\n   * all of the addresses for which this wallet contains secret keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listKeys = async walletHandle => {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await c.post('/v1/key/list', req);\n    return res.body;\n  };\n  /**\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * Sender field.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @returns {Promise<*>}\n   */\n\n\n  this.signTransaction = async (walletHandle, walletPassword, transaction) => {\n    const tx = new txn.Transaction(transaction);\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: Buffer.from(tx.toByte()).toString('base64')\n    };\n    const res = await c.post('/v1/transaction/sign', req);\n\n    if (res.statusCode === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n\n    return res.body;\n  };\n  /**\n   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * publicKey arg.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @param publicKey sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\n   * @returns {Promise<*>}\n   */\n\n\n  this.signTransactionWithSpecificPublicKey = async (walletHandle, walletPassword, transaction, publicKey) => {\n    const tx = new txn.Transaction(transaction);\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\n      public_key: Buffer.from(publicKey).toString('base64')\n    };\n    const res = await c.post('/v1/transaction/sign', req);\n\n    if (res.statusCode === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n\n    return res.body;\n  };\n  /**\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\n   * containing the multisig addresses whose preimages are stored in this wallet.\n   * A preimage is the information needed to reconstruct this multisig address,\n   * including multisig version information, threshold information, and a list\n   * of public keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listMultisig = async walletHandle => {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    const res = await c.post('/v1/multisig/list', req);\n    return res.body;\n  };\n  /**\n   * importMultisig accepts a wallet handle and the information required to\n   * generate a multisig address. It derives this address, and stores all of the\n   * information within the wallet. It returns a ImportMultisigResponse with the\n   * derived address.\n   * @param walletHandle\n   * @param version\n   * @param threshold\n   * @param pks\n   * @returns {Promise<*>}\n   */\n\n\n  this.importMultisig = async (walletHandle, version, threshold, pks) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      multisig_version: version,\n      threshold,\n      pks\n    };\n    const res = await c.post('/v1/multisig/import', req);\n    return res.body;\n  };\n  /**\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and returns an ExportMultisigResponse containing the stored\n   * multisig preimage. The preimage contains all of the information necessary\n   * to derive the multisig address, including version, threshold, and a list of\n   * public keys.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportMultisig = async (walletHandle, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr\n    };\n    const res = await c.post('/v1/multisig/export', req);\n    return res.body;\n  };\n  /**\n   * signMultisigTransaction accepts a wallet handle, wallet password,\n   * transaction, public key (*not* an address), and an optional partial\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\n   * signature by the secret key included.\n   * @param walletHandle\n   * @param pw\n   * @param tx\n   * @param pk\n   * @param partial\n   * @returns {Promise<*>}\n   */\n\n\n  this.signMultisigTransaction = async (walletHandle, pw, transaction, pk, partial) => {\n    const tx = new txn.Transaction(transaction);\n    const req = {\n      wallet_handle_token: walletHandle,\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\n      public_key: Buffer.from(pk).toString('base64'),\n      partial_multisig: partial,\n      wallet_password: pw\n    };\n    const res = await c.post('/v1/multisig/sign', req);\n    return res.body;\n  };\n  /**\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and deletes the information about this multisig address from the\n   * wallet (including address and secret key).\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.deleteMultisig = async (walletHandle, walletPassword, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    const res = await c.delete('/v1/multisig', req);\n    return res.body;\n  };\n}\n\nmodule.exports = {\n  Kmd\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/algosdk/src/client/kmd.js"],"names":["Buffer","require","client","txn","Kmd","token","baseServer","port","c","HTTPClient","versions","res","get","body","listWallets","createWallet","walletName","walletPassword","walletMDK","walletDriverName","req","wallet_name","wallet_driver_name","wallet_password","master_derivation_key","from","toString","post","initWalletHandle","walletID","wallet_id","releaseWalletHandle","walletHandle","wallet_handle_token","renewWalletHandle","renameWallet","newWalletName","getWallet","exportMasterDerivationKey","importKey","secretKey","private_key","exportKey","addr","address","generateKey","display_mnemonic","deleteKey","delete","listKeys","signTransaction","transaction","tx","Transaction","toByte","statusCode","signed_transaction","signTransactionWithSpecificPublicKey","publicKey","public_key","listMultisig","importMultisig","version","threshold","pks","multisig_version","exportMultisig","signMultisigTransaction","pw","pk","partial","partial_multisig","deleteMultisig","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst client = require('./client');\nconst txn = require('../transaction');\n\nfunction Kmd(token, baseServer = 'http://127.0.0.1', port = 7833) {\n  // Get client\n  const c = new client.HTTPClient(\n    { 'X-KMD-API-Token': token },\n    baseServer,\n    port\n  );\n\n  /**\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\n   * @returns {Promise<*>}\n   */\n  this.versions = async () => {\n    const res = await c.get('/versions');\n    return res.body;\n  };\n\n  /**\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\n   * @returns {Promise<*>}\n   */\n  this.listWallets = async () => {\n    const res = await c.get('/v1/wallets');\n    return res.body;\n  };\n\n  /**\n   * createWallet creates a wallet with the specified name, password, driver,\n   * and master derivation key. If the master derivation key is blank, one is\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\n   * containing information about the new wallet.\n   * @param walletName\n   * @param walletPassword\n   * @param walletDriverName\n   * @param walletMDK\n   * @returns {Promise<*>}\n   */\n  this.createWallet = async (\n    walletName,\n    walletPassword,\n    walletMDK = '',\n    walletDriverName = 'sqlite'\n  ) => {\n    const req = {\n      wallet_name: walletName,\n      wallet_driver_name: walletDriverName,\n      wallet_password: walletPassword,\n      master_derivation_key: Buffer.from(walletMDK).toString('base64'),\n    };\n    const res = await c.post('/v1/wallet', req);\n    return res.body;\n  };\n\n  /**\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\n   * initWalletHandleResponse containing a wallet handle token. This wallet\n   * handle token can be used for subsequent operations on this wallet, like key\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\n   * configurable number of seconds, and must be renewed periodically with\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\n   * you're done interacting with this wallet.\n   * @param walletID\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n  this.initWalletHandle = async (walletID, walletPassword) => {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword,\n    };\n    const res = await c.post('/v1/wallet/init', req);\n    return res.body;\n  };\n\n  /**\n   * releaseWalletHandle invalidates the passed wallet handle token, making\n   * it unusuable for subsequent wallet operations.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n  this.releaseWalletHandle = async (walletHandle) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    const res = await c.post('/v1/wallet/release', req);\n    return res.body;\n  };\n\n  /**\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\n   * the expiration time to some number of seconds in the future. It returns a\n   * RenewWalletHandleResponse containing the walletHandle and the number of\n   * seconds until expiration\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n  this.renewWalletHandle = async (walletHandle) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    const res = await c.post('/v1/wallet/renew', req);\n    return res.body;\n  };\n\n  /**\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\n   * and renames the underlying wallet.\n   * @param walletID\n   * @param walletPassword\n   * @param newWalletName\n   * @returns {Promise<*>}\n   */\n  this.renameWallet = async (walletID, walletPassword, newWalletName) => {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword,\n      wallet_name: newWalletName,\n    };\n    const res = await c.post('/v1/wallet/rename', req);\n    return res.body;\n  };\n\n  /**\n   * getWallet accepts a wallet handle and returns high level information about\n   * this wallet in a GetWalletResponse.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n  this.getWallet = async (walletHandle) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    const res = await c.post('/v1/wallet/info', req);\n    return res.body;\n  };\n\n  /**\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\n   * returns an ExportMasterDerivationKeyResponse containing the master\n   * derivation key. This key can be used as an argument to CreateWallet in\n   * order to recover the keys generated by this wallet. The master derivation\n   * key can be encoded as a sequence of words using the mnemonic library, and\n   * @param walletHandle\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n  this.exportMasterDerivationKey = async (walletHandle, walletPassword) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n    };\n    const res = await c.post('/v1/master-key/export', req);\n    return {\n      master_derivation_key: Buffer.from(\n        res.body.master_derivation_key,\n        'base64'\n      ),\n    };\n  };\n\n  /**\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\n   * the key into the wallet. It returns an ImportKeyResponse containing the\n   * address corresponding to this private key.\n   * @param walletHandle\n   * @param secretKey\n   * @returns {Promise<*>}\n   */\n  this.importKey = async (walletHandle, secretKey) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      private_key: Buffer.from(secretKey).toString('base64'),\n    };\n    const res = await c.post('/v1/key/import', req);\n    return res.body;\n  };\n\n  /**\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\n   * address stored in the wallet.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n  this.exportKey = async (walletHandle, walletPassword, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword,\n    };\n    const res = await c.post('/v1/key/export', req);\n    return { private_key: Buffer.from(res.body.private_key, 'base64') };\n  };\n\n  /**\n   * generateKey accepts a wallet handle, and then generates the next key in the\n   * wallet using its internal master derivation key. Two wallets with the same\n   * master derivation key will generate the same sequence of keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n  this.generateKey = async (walletHandle) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      display_mnemonic: false,\n    };\n    const res = await c.post('/v1/key', req);\n    return res.body;\n  };\n\n  /**\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\n   * the information about this address from the wallet (including address and\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\n   * the same key will not be generated again. However, if a wallet is recovered\n   * using the master derivation key, a key generated in this way can be\n   * recovered.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n  this.deleteKey = async (walletHandle, walletPassword, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword,\n    };\n    const res = await c.delete('/v1/key', req);\n    return res.body;\n  };\n\n  /**\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\n   * all of the addresses for which this wallet contains secret keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n  this.listKeys = async (walletHandle) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    const res = await c.post('/v1/key/list', req);\n    return res.body;\n  };\n\n  /**\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * Sender field.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @returns {Promise<*>}\n   */\n  this.signTransaction = async (walletHandle, walletPassword, transaction) => {\n    const tx = new txn.Transaction(transaction);\n\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\n    };\n    const res = await c.post('/v1/transaction/sign', req);\n\n    if (res.statusCode === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n    return res.body;\n  };\n\n  /**\n   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * publicKey arg.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @param publicKey sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\n   * @returns {Promise<*>}\n   */\n  this.signTransactionWithSpecificPublicKey = async (\n    walletHandle,\n    walletPassword,\n    transaction,\n    publicKey\n  ) => {\n    const tx = new txn.Transaction(transaction);\n\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\n      public_key: Buffer.from(publicKey).toString('base64'),\n    };\n    const res = await c.post('/v1/transaction/sign', req);\n\n    if (res.statusCode === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n    return res.body;\n  };\n  /**\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\n   * containing the multisig addresses whose preimages are stored in this wallet.\n   * A preimage is the information needed to reconstruct this multisig address,\n   * including multisig version information, threshold information, and a list\n   * of public keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n  this.listMultisig = async (walletHandle) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    const res = await c.post('/v1/multisig/list', req);\n    return res.body;\n  };\n\n  /**\n   * importMultisig accepts a wallet handle and the information required to\n   * generate a multisig address. It derives this address, and stores all of the\n   * information within the wallet. It returns a ImportMultisigResponse with the\n   * derived address.\n   * @param walletHandle\n   * @param version\n   * @param threshold\n   * @param pks\n   * @returns {Promise<*>}\n   */\n  this.importMultisig = async (walletHandle, version, threshold, pks) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      multisig_version: version,\n      threshold,\n      pks,\n    };\n    const res = await c.post('/v1/multisig/import', req);\n    return res.body;\n  };\n\n  /**\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and returns an ExportMultisigResponse containing the stored\n   * multisig preimage. The preimage contains all of the information necessary\n   * to derive the multisig address, including version, threshold, and a list of\n   * public keys.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n  this.exportMultisig = async (walletHandle, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n    };\n    const res = await c.post('/v1/multisig/export', req);\n    return res.body;\n  };\n\n  /**\n   * signMultisigTransaction accepts a wallet handle, wallet password,\n   * transaction, public key (*not* an address), and an optional partial\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\n   * signature by the secret key included.\n   * @param walletHandle\n   * @param pw\n   * @param tx\n   * @param pk\n   * @param partial\n   * @returns {Promise<*>}\n   */\n  this.signMultisigTransaction = async (\n    walletHandle,\n    pw,\n    transaction,\n    pk,\n    partial\n  ) => {\n    const tx = new txn.Transaction(transaction);\n    const req = {\n      wallet_handle_token: walletHandle,\n      transaction: Buffer.from(tx.toByte()).toString('base64'),\n      public_key: Buffer.from(pk).toString('base64'),\n      partial_multisig: partial,\n      wallet_password: pw,\n    };\n    const res = await c.post('/v1/multisig/sign', req);\n    return res.body;\n  };\n\n  /**\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and deletes the information about this multisig address from the\n   * wallet (including address and secret key).\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n  this.deleteMultisig = async (walletHandle, walletPassword, addr) => {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword,\n    };\n    const res = await c.delete('/v1/multisig', req);\n    return res.body;\n  };\n}\nmodule.exports = { Kmd };\n"]},"metadata":{},"sourceType":"script"}