{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nconst makeTxn = require('../makeTxn');\n\nconst group = require('../group');\n\nconst logicsig = require('../logicsig');\n\nconst logic = require('../logic/logic');\n\nconst templates = require('./templates');\n\nconst utils = require('../utils/utils');\n\nclass Split {\n  /**\n   * Split splits money sent to some account to two recipients at some ratio.\n   * This is a contract account.\n   *\n   * This allows either a two-transaction group, for executing a\n   * split, or single transaction, for closing the account.\n   *\n   * Withdrawals from this account are allowed as a group transaction which\n   * sends receiverOne and receiverTwo amounts with exactly the specified ratio:\n   * (rat1*amountForReceiverOne) = (rat2*amountForReceiverTwo)\n   * At least minPay must be sent to receiverOne.\n   * (CloseRemainderTo must be zero.)\n   *\n   * After expiryRound passes, all funds can be refunded to owner.\n   * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {string} receiverOne: the first recipient in the split account\n   * @param {string} receiverTwo: the second recipient in the split account\n   * @param {int} rat1: fraction of money to be paid to the 1st recipient\n   * @param {int} rat2: fraction of money to be paid to the 2nd recipient\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minPay: minimum amount to be paid out of the account\n   * @param {int} maxFee: half of the maximum fee used by each split forwarding group transaction\n   * @returns {Split}\n   */\n  constructor(owner, receiverOne, receiverTwo, rat1, rat2, expiryRound, minPay, maxFee) {\n    // don't need to validate owner, receiverone, receivertwo - they'll be validated by template.insert\n    if (!Number.isSafeInteger(rat2) || rat2 < 0) throw Error('rat2 must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(rat1) || rat1 < 0) throw Error('rat1 must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error('expiryRound must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(minPay) || minPay < 0) throw Error('minPay must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error('maxFee must be a positive number and smaller than 2^53-1');\n    const referenceProgramB64 = 'ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [4\n    /* timeout */\n    , 7\n    /* rat2 */\n    , 8\n    /* rat1 */\n    , 9\n    /* minPay */\n    , 10\n    /* owner */\n    , 14\n    /* receiver1 */\n    , 47\n    /* receiver2 */\n    , 80];\n    const injectionVector = [maxFee, expiryRound, rat2, rat1, minPay, owner, receiverOne, receiverTwo];\n    const injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS];\n    const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    const lsig = logicsig.makeLogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: bytes representing the contract in question\n * @param {int} amount: the amount to be transferred\n * @param {int} firstRound: the first round on which the transaction group will be valid\n * @param {int} lastRound: the last round on which the transaction group will be valid\n * @param {int} fee: the fee to pay in microAlgos\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n */\n\n\nfunction getSplitFundsTransaction(contract, amount, firstRound, lastRound, fee, genesisHash) {\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n  let rat2 = ints[6];\n  let rat1 = ints[5];\n  let amountForReceiverOne = 0; // reduce fractions\n\n  const gcdFn = (a, b) => {\n    if (typeof a !== 'number' || typeof b !== 'number') throw new Error('gcd operates only on positive integers');\n\n    if (!b) {\n      return a;\n    }\n\n    return gcdFn(b, a % b);\n  };\n\n  const gcd = gcdFn(rat2, rat1);\n  rat2 = Math.floor(rat2 / gcd);\n  rat1 = Math.floor(rat1 / gcd);\n  const ratio = rat1 / rat2;\n  amountForReceiverOne = Math.round(amount / (1 + ratio));\n  const amountForReceiverTwo = amount - amountForReceiverOne;\n\n  if (rat1 * amountForReceiverOne !== rat2 * amountForReceiverTwo) {\n    throw Error('could not split funds in a way that satisfied the contract ratio');\n  }\n\n  const logicSig = logicsig.makeLogicSig(contract, undefined); // no args\n\n  const from = logicSig.address();\n  const receiverOne = address.encodeAddress(byteArrays[1]);\n  const receiverTwo = address.encodeAddress(byteArrays[2]);\n  const tx1 = makeTxn.makePaymentTxn(from, receiverOne, fee, amountForReceiverOne, undefined, firstRound, lastRound, undefined, genesisHash);\n  const tx2 = makeTxn.makePaymentTxn(from, receiverTwo, fee, amountForReceiverTwo, undefined, firstRound, lastRound, undefined, genesisHash);\n  const txns = [tx1, tx2];\n  const txGroup = group.assignGroupID(txns);\n  const signedTxns = txGroup.map(txn => logicsig.signLogicSigTransactionObject(txn, logicsig).blob);\n  return utils.concatArrays(signedTxns[0], signedTxns[1]);\n}\n\nmodule.exports = {\n  Split,\n  getSplitFundsTransaction\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/logicTemplates/split.js"],"names":["Buffer","require","address","makeTxn","group","logicsig","logic","templates","utils","Split","constructor","owner","receiverOne","receiverTwo","rat1","rat2","expiryRound","minPay","maxFee","Number","isSafeInteger","Error","referenceProgramB64","referenceProgramBytes","from","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","injectedBytes","inject","programBytes","lsig","makeLogicSig","undefined","getProgram","getAddress","getSplitFundsTransaction","contract","amount","firstRound","lastRound","fee","genesisHash","programOutputs","readProgram","ints","byteArrays","amountForReceiverOne","gcdFn","a","b","gcd","Math","floor","ratio","round","amountForReceiverTwo","logicSig","encodeAddress","tx1","makePaymentTxn","tx2","txns","txGroup","assignGroupID","signedTxns","map","txn","signLogicSigTransactionObject","blob","concatArrays","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require('../encoding/address');\nconst makeTxn = require('../makeTxn');\nconst group = require('../group');\nconst logicsig = require('../logicsig');\nconst logic = require('../logic/logic');\nconst templates = require('./templates');\nconst utils = require('../utils/utils');\n\nclass Split {\n  /**\n   * Split splits money sent to some account to two recipients at some ratio.\n   * This is a contract account.\n   *\n   * This allows either a two-transaction group, for executing a\n   * split, or single transaction, for closing the account.\n   *\n   * Withdrawals from this account are allowed as a group transaction which\n   * sends receiverOne and receiverTwo amounts with exactly the specified ratio:\n   * (rat1*amountForReceiverOne) = (rat2*amountForReceiverTwo)\n   * At least minPay must be sent to receiverOne.\n   * (CloseRemainderTo must be zero.)\n   *\n   * After expiryRound passes, all funds can be refunded to owner.\n   * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {string} receiverOne: the first recipient in the split account\n   * @param {string} receiverTwo: the second recipient in the split account\n   * @param {int} rat1: fraction of money to be paid to the 1st recipient\n   * @param {int} rat2: fraction of money to be paid to the 2nd recipient\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minPay: minimum amount to be paid out of the account\n   * @param {int} maxFee: half of the maximum fee used by each split forwarding group transaction\n   * @returns {Split}\n   */\n  constructor(\n    owner,\n    receiverOne,\n    receiverTwo,\n    rat1,\n    rat2,\n    expiryRound,\n    minPay,\n    maxFee\n  ) {\n    // don't need to validate owner, receiverone, receivertwo - they'll be validated by template.insert\n    if (!Number.isSafeInteger(rat2) || rat2 < 0)\n      throw Error('rat2 must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(rat1) || rat1 < 0)\n      throw Error('rat1 must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)\n      throw Error(\n        'expiryRound must be a positive number and smaller than 2^53-1'\n      );\n    if (!Number.isSafeInteger(minPay) || minPay < 0)\n      throw Error('minPay must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0)\n      throw Error('maxFee must be a positive number and smaller than 2^53-1');\n\n    const referenceProgramB64 =\n      'ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [\n      4 /* timeout */,\n      7 /* rat2 */,\n      8 /* rat1 */,\n      9 /* minPay */,\n      10 /* owner */,\n      14 /* receiver1 */,\n      47 /* receiver2 */,\n      80,\n    ];\n    const injectionVector = [\n      maxFee,\n      expiryRound,\n      rat2,\n      rat1,\n      minPay,\n      owner,\n      receiverOne,\n      receiverTwo,\n    ];\n    const injectionTypes = [\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.ADDRESS,\n      templates.valTypes.ADDRESS,\n      templates.valTypes.ADDRESS,\n    ];\n    const injectedBytes = templates.inject(\n      referenceProgramBytes,\n      referenceOffsets,\n      injectionVector,\n      injectionTypes\n    );\n    this.programBytes = injectedBytes;\n    const lsig = logicsig.makeLogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n  getProgram() {\n    return this.programBytes;\n  }\n\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n  getAddress() {\n    return this.address;\n  }\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: bytes representing the contract in question\n * @param {int} amount: the amount to be transferred\n * @param {int} firstRound: the first round on which the transaction group will be valid\n * @param {int} lastRound: the last round on which the transaction group will be valid\n * @param {int} fee: the fee to pay in microAlgos\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n */\nfunction getSplitFundsTransaction(\n  contract,\n  amount,\n  firstRound,\n  lastRound,\n  fee,\n  genesisHash\n) {\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n  let rat2 = ints[6];\n  let rat1 = ints[5];\n  let amountForReceiverOne = 0;\n  // reduce fractions\n  const gcdFn = (a, b) => {\n    if (typeof a !== 'number' || typeof b !== 'number')\n      throw new Error('gcd operates only on positive integers');\n    if (!b) {\n      return a;\n    }\n    return gcdFn(b, a % b);\n  };\n  const gcd = gcdFn(rat2, rat1);\n  rat2 = Math.floor(rat2 / gcd);\n  rat1 = Math.floor(rat1 / gcd);\n  const ratio = rat1 / rat2;\n  amountForReceiverOne = Math.round(amount / (1 + ratio));\n  const amountForReceiverTwo = amount - amountForReceiverOne;\n  if (rat1 * amountForReceiverOne !== rat2 * amountForReceiverTwo) {\n    throw Error(\n      'could not split funds in a way that satisfied the contract ratio'\n    );\n  }\n\n  const logicSig = logicsig.makeLogicSig(contract, undefined); // no args\n  const from = logicSig.address();\n  const receiverOne = address.encodeAddress(byteArrays[1]);\n  const receiverTwo = address.encodeAddress(byteArrays[2]);\n  const tx1 = makeTxn.makePaymentTxn(\n    from,\n    receiverOne,\n    fee,\n    amountForReceiverOne,\n    undefined,\n    firstRound,\n    lastRound,\n    undefined,\n    genesisHash\n  );\n  const tx2 = makeTxn.makePaymentTxn(\n    from,\n    receiverTwo,\n    fee,\n    amountForReceiverTwo,\n    undefined,\n    firstRound,\n    lastRound,\n    undefined,\n    genesisHash\n  );\n  const txns = [tx1, tx2];\n  const txGroup = group.assignGroupID(txns);\n\n  const signedTxns = txGroup.map(\n    (txn) => logicsig.signLogicSigTransactionObject(txn, logicsig).blob\n  );\n  return utils.concatArrays(signedTxns[0], signedTxns[1]);\n}\n\nmodule.exports = {\n  Split,\n  getSplitFundsTransaction,\n};\n"]},"metadata":{},"sourceType":"script"}