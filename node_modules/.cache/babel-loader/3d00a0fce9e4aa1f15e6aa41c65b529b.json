{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst sha256 = require('js-sha256');\n\nconst {\n  keccak256\n} = require('js-sha3');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst templates = require('./templates');\n\nconst transaction = require('../transaction');\n\nclass HTLC {\n  /**\n   * HTLC allows a user to receive the Algo prior to a deadline (in terms of a round) by proving a knowledge\n   * of a special value or to forfeit the ability to claim, returning it to the payer.\n   * This contract is usually used to perform cross-chained atomic swaps\n   *\n   * More formally -\n   * Algos can be transferred under only two circumstances:\n   * 1. To receiver if hash_function(arg_0) = hash_value\n   * 2. To owner if txn.FirstValid > expiry_round\n   * ...\n   *\n   *Parameters\n   *----------\n   * @param {string} owner: an address that can receive the asset after the expiry round\n   * @param {string} receiver: address to receive Algos\n   * @param {string} hashFunction: the hash function to be used (must be either sha256 or keccak256)\n   * @param {string} hashImage: the hash image in base64\n   * @param {int} expiryRound: the round on which the assets can be transferred back to owner\n   * @param {int} maxFee: the maximum fee that can be paid to the network by the account\n   * @returns {HTLC}\n   */\n  constructor(owner, receiver, hashFunction, hashImage, expiryRound, maxFee) {\n    // don't need to validate owner, receiver - they'll be validated by template.insert\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error('expiryRound must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error('maxFee must be a positive number and smaller than 2^53-1');\n    let referenceProgramB64 = '';\n\n    if (hashFunction === 'sha256') {\n      referenceProgramB64 = 'ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==';\n    } else if (hashFunction === 'keccak256') {\n      referenceProgramB64 = 'ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==';\n    } else {\n      throw Error('hash function unrecognized');\n    } // validate hashImage length\n\n\n    const hashImageBytes = Buffer.from(hashImage, 'base64');\n    if (hashImageBytes.length !== 32) throw Error('hash image must be 32 bytes');\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [3\n    /* expiryRound */\n    , 6\n    /* receiver */\n    , 10\n    /* hashImage */\n    , 42\n    /* owner */\n    , 76];\n    const injectionVector = [maxFee, expiryRound, receiver, hashImage, owner];\n    const injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.BASE64, templates.valTypes.ADDRESS];\n    const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    const lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n *  signTransactionWithHTLCUnlock accepts a transaction, such as a payment, and builds the HTLC-unlocking signature around that transaction\n * @param {Uint8Array} contract : byte representation of the HTLC\n * @param {Object} txn dictionary containing constructor arguments for a transaction\n * @param {string} preImageAsBase64 : preimage of the hash as base64 string\n *\n * @returns {Object} Object containing txID and blob representing signed transaction.\n * @throws error on validation failure\n */\n\n\nfunction signTransactionWithHTLCUnlock(contract, txn, preImageAsBase64) {\n  const preImageBytes = Buffer.from(preImageAsBase64, 'base64'); // hash validation\n\n  const readResult = logic.readProgram(contract, undefined);\n  const ints = readResult[0];\n  const byteArrays = readResult[1];\n  const expectedHashedOutput = byteArrays[1];\n  const hashFunction = contract[contract.length - 15];\n\n  if (hashFunction === 1) {\n    const hash = sha256.create();\n    hash.update(preImageBytes);\n    const actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n\n    if (!actualHashedOutput.equals(expectedHashedOutput)) {\n      throw new Error('sha256 hash of preimage did not match stored contract hash');\n    }\n  } else if (hashFunction === 2) {\n    const hash = keccak256.create();\n    hash.update(preImageBytes);\n    const actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n\n    if (!actualHashedOutput.equals(expectedHashedOutput)) {\n      throw new Error('keccak256 hash of preimage did not match stored contract hash');\n    }\n  } else {\n    throw new Error('hash function in contract unrecognized');\n  }\n\n  const args = [preImageBytes]; // array of one element, the Uint8Array preimage\n\n  const lsig = new logicSig.LogicSig(contract, args); // clear out receiver just in case\n  // eslint-disable-next-line no-param-reassign\n\n  delete txn.to;\n  const maxFee = ints[0]; // check fee\n\n  const tempTxn = new transaction.Transaction(txn);\n\n  if (tempTxn.fee > maxFee) {\n    throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${maxFee.toString()}`);\n  }\n\n  return logicSig.signLogicSigTransaction(txn, lsig);\n}\n\nmodule.exports = {\n  HTLC,\n  signTransactionWithHTLCUnlock\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/algosdk/src/logicTemplates/htlc.js"],"names":["Buffer","require","sha256","keccak256","logic","logicSig","templates","transaction","HTLC","constructor","owner","receiver","hashFunction","hashImage","expiryRound","maxFee","Number","isSafeInteger","Error","referenceProgramB64","hashImageBytes","from","length","referenceProgramBytes","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","BASE64","injectedBytes","inject","programBytes","lsig","LogicSig","undefined","address","getProgram","getAddress","signTransactionWithHTLCUnlock","contract","txn","preImageAsBase64","preImageBytes","readResult","readProgram","ints","byteArrays","expectedHashedOutput","hash","create","update","actualHashedOutput","hex","equals","args","to","tempTxn","Transaction","fee","toString","signLogicSigTransaction","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst sha256 = require('js-sha256');\nconst { keccak256 } = require('js-sha3');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst templates = require('./templates');\nconst transaction = require('../transaction');\n\nclass HTLC {\n  /**\n   * HTLC allows a user to receive the Algo prior to a deadline (in terms of a round) by proving a knowledge\n   * of a special value or to forfeit the ability to claim, returning it to the payer.\n   * This contract is usually used to perform cross-chained atomic swaps\n   *\n   * More formally -\n   * Algos can be transferred under only two circumstances:\n   * 1. To receiver if hash_function(arg_0) = hash_value\n   * 2. To owner if txn.FirstValid > expiry_round\n   * ...\n   *\n   *Parameters\n   *----------\n   * @param {string} owner: an address that can receive the asset after the expiry round\n   * @param {string} receiver: address to receive Algos\n   * @param {string} hashFunction: the hash function to be used (must be either sha256 or keccak256)\n   * @param {string} hashImage: the hash image in base64\n   * @param {int} expiryRound: the round on which the assets can be transferred back to owner\n   * @param {int} maxFee: the maximum fee that can be paid to the network by the account\n   * @returns {HTLC}\n   */\n  constructor(owner, receiver, hashFunction, hashImage, expiryRound, maxFee) {\n    // don't need to validate owner, receiver - they'll be validated by template.insert\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)\n      throw Error(\n        'expiryRound must be a positive number and smaller than 2^53-1'\n      );\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0)\n      throw Error('maxFee must be a positive number and smaller than 2^53-1');\n\n    let referenceProgramB64 = '';\n    if (hashFunction === 'sha256') {\n      referenceProgramB64 =\n        'ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==';\n    } else if (hashFunction === 'keccak256') {\n      referenceProgramB64 =\n        'ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==';\n    } else {\n      throw Error('hash function unrecognized');\n    }\n    // validate hashImage length\n    const hashImageBytes = Buffer.from(hashImage, 'base64');\n    if (hashImageBytes.length !== 32)\n      throw Error('hash image must be 32 bytes');\n\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [\n      3 /* expiryRound */,\n      6 /* receiver */,\n      10 /* hashImage */,\n      42 /* owner */,\n      76,\n    ];\n    const injectionVector = [maxFee, expiryRound, receiver, hashImage, owner];\n    const injectionTypes = [\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.ADDRESS,\n      templates.valTypes.BASE64,\n      templates.valTypes.ADDRESS,\n    ];\n    const injectedBytes = templates.inject(\n      referenceProgramBytes,\n      referenceOffsets,\n      injectionVector,\n      injectionTypes\n    );\n    this.programBytes = injectedBytes;\n    const lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n  getProgram() {\n    return this.programBytes;\n  }\n\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n  getAddress() {\n    return this.address;\n  }\n}\n\n/**\n *  signTransactionWithHTLCUnlock accepts a transaction, such as a payment, and builds the HTLC-unlocking signature around that transaction\n * @param {Uint8Array} contract : byte representation of the HTLC\n * @param {Object} txn dictionary containing constructor arguments for a transaction\n * @param {string} preImageAsBase64 : preimage of the hash as base64 string\n *\n * @returns {Object} Object containing txID and blob representing signed transaction.\n * @throws error on validation failure\n */\nfunction signTransactionWithHTLCUnlock(contract, txn, preImageAsBase64) {\n  const preImageBytes = Buffer.from(preImageAsBase64, 'base64');\n\n  // hash validation\n  const readResult = logic.readProgram(contract, undefined);\n  const ints = readResult[0];\n  const byteArrays = readResult[1];\n  const expectedHashedOutput = byteArrays[1];\n  const hashFunction = contract[contract.length - 15];\n  if (hashFunction === 1) {\n    const hash = sha256.create();\n    hash.update(preImageBytes);\n    const actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n    if (!actualHashedOutput.equals(expectedHashedOutput)) {\n      throw new Error(\n        'sha256 hash of preimage did not match stored contract hash'\n      );\n    }\n  } else if (hashFunction === 2) {\n    const hash = keccak256.create();\n    hash.update(preImageBytes);\n    const actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n    if (!actualHashedOutput.equals(expectedHashedOutput)) {\n      throw new Error(\n        'keccak256 hash of preimage did not match stored contract hash'\n      );\n    }\n  } else {\n    throw new Error('hash function in contract unrecognized');\n  }\n\n  const args = [preImageBytes]; // array of one element, the Uint8Array preimage\n\n  const lsig = new logicSig.LogicSig(contract, args);\n  // clear out receiver just in case\n  // eslint-disable-next-line no-param-reassign\n  delete txn.to;\n\n  const maxFee = ints[0];\n  // check fee\n  const tempTxn = new transaction.Transaction(txn);\n  if (tempTxn.fee > maxFee) {\n    throw new Error(\n      `final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${maxFee.toString()}`\n    );\n  }\n\n  return logicSig.signLogicSigTransaction(txn, lsig);\n}\n\nmodule.exports = {\n  HTLC,\n  signTransactionWithHTLCUnlock,\n};\n"]},"metadata":{},"sourceType":"script"}