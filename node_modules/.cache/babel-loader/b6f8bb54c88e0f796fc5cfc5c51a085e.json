{"ast":null,"code":"// ****************************************************************************\n// standard library needed at runtime by compiled Reach programs\n// ****************************************************************************\nimport ethers from 'ethers';\nimport * as shared from './shared.mjs';\nimport * as CBR from './CBR.mjs';\nimport { labelMaps } from './shared_impl.mjs';\nconst BigNumber = ethers.BigNumber;\nexport const UInt_max = BigNumber.from(2).pow(256).sub(1);\nexport const digest = shared.makeDigest((t, v) => {\n  // Note: abiCoder.encode doesn't correctly handle an empty tuple type\n  if (t.paramType === 'tuple()') {\n    if (Array.isArray(v) && v.length === 0) {\n      return v;\n    } else {\n      throw Error(`impossible: digest tuple() with non-empty array: ${JSON.stringify(v)}`);\n    }\n  }\n\n  return ethers.utils.defaultAbiCoder.encode([t.paramType], [t.munge(v)]);\n});\nconst V_Null = null;\nconst T_Null = { ...CBR.BT_Null,\n  defaultValue: V_Null,\n  // null is represented in solidity as false\n  munge: bv => (void bv, false),\n  unmunge: nv => (void nv, V_Null),\n  paramType: 'bool'\n};\nconst T_Bool = { ...CBR.BT_Bool,\n  defaultValue: false,\n  munge: bv => bv,\n  unmunge: nv => V_Bool(nv),\n  paramType: 'bool'\n};\n\nconst V_Bool = b => {\n  return T_Bool.canonicalize(b);\n};\n\nexport const T_UInt = { ...CBR.BT_UInt,\n  defaultValue: ethers.BigNumber.from(0),\n  munge: bv => bv,\n  unmunge: nv => V_UInt(nv),\n  paramType: 'uint256'\n};\n\nconst V_UInt = n => {\n  return T_UInt.canonicalize(n);\n};\n\nconst T_Bytes = len => {\n  const me = { ...CBR.BT_Bytes(len),\n    defaultValue: ''.padEnd(len, '\\0'),\n    munge: bv => Array.from(ethers.utils.toUtf8Bytes(bv)),\n    unmunge: nv => me.canonicalize(shared.hexToString(ethers.utils.hexlify(nv))),\n    paramType: `uint8[${len}]`\n  };\n  return me;\n};\n\nconst T_Digest = { ...CBR.BT_Digest,\n  defaultValue: ethers.utils.keccak256([]),\n  munge: bv => BigNumber.from(bv),\n  // XXX likely not the correct unmunge type?\n  unmunge: nv => V_Digest(nv.toHexString()),\n  paramType: 'uint256'\n};\n\nconst V_Digest = s => {\n  return T_Digest.canonicalize(s);\n};\n\nfunction addressUnwrapper(x) {\n  // TODO: set it up so that .address is always there\n  // Just putting it here to appease BT_Address.canonicalize\n  if (typeof x === 'string') {\n    // XXX is this actually needed?\n    if (x.slice(0, 2) !== '0x') {\n      return '0x' + x;\n    } else {\n      return x;\n    }\n  } else if (x.networkAccount && x.networkAccount.address) {\n    return x.networkAccount.address;\n  } else if (x.address) {\n    return x.address;\n  } else {\n    throw Error(`Failed to unwrap address ${x}`);\n  }\n}\n\nconst T_Address = { ...CBR.BT_Address,\n  canonicalize: uv => {\n    const val = addressUnwrapper(uv);\n    return CBR.BT_Address.canonicalize(val || uv);\n  },\n  defaultValue: '0x' + Array(40).fill('0').join(''),\n  munge: bv => bv,\n  unmunge: nv => V_Address(nv),\n  paramType: 'address'\n};\n\nconst V_Address = s => {\n  // Uses ETH-specific canonicalize!\n  return T_Address.canonicalize(s);\n};\n\nconst T_Array = (ctc, size) => ({ ...CBR.BT_Array(ctc, size),\n  defaultValue: Array(size).fill(ctc.defaultValue),\n  munge: bv => {\n    if (size == 0) {\n      return false;\n    } else {\n      return bv.map(arg => ctc.munge(arg));\n    }\n  },\n  unmunge: nv => {\n    if (size == 0) {\n      return [];\n    } else {\n      return V_Array(ctc, size)(nv.map(arg => ctc.unmunge(arg)));\n    }\n  },\n  paramType: `${ctc.paramType}[${size}]`\n});\n\nconst V_Array = (ctc, size) => val => {\n  return T_Array(ctc, size).canonicalize(val);\n}; // XXX fix me Dan, I'm type checking wrong!\n\n\nconst T_Tuple = ctcs => ({ ...CBR.BT_Tuple(ctcs),\n  defaultValue: ctcs.map(ctc => ctc.defaultValue),\n  munge: bv => {\n    if (ctcs.length == 0) {\n      return false;\n    } else {\n      return bv.map((arg, i) => ctcs[i].munge(arg));\n    }\n  },\n  unmunge: args => {\n    return V_Tuple(ctcs)(ctcs.map((ctc, i) => ctc.unmunge(args[i])));\n  },\n  paramType: `tuple(${ctcs.map(ctc => ctc.paramType).join(',')})`\n});\n\nconst V_Tuple = ctcs => val => {\n  return T_Tuple(ctcs).canonicalize(val);\n};\n\nconst T_Struct = ctcs => ({ ...CBR.BT_Struct(ctcs),\n  defaultValue: (() => {\n    const obj = {};\n    ctcs.forEach(([prop, co]) => {\n      obj[prop] = co.defaultValue;\n    });\n    return obj;\n  })(),\n  munge: bv => {\n    if (ctcs.length == 0) {\n      return false;\n    } else {\n      return ctcs.map(([k, ctc]) => ctc.munge(bv[k]));\n    }\n  },\n  unmunge: args => {\n    return V_Struct(ctcs)(ctcs.map(([k, ctc], i) => {\n      void k;\n      return ctc.unmunge(args[i]);\n    }));\n  },\n  paramType: `tuple(${ctcs.map(([k, ctc]) => {\n    void k;\n    return ctc.paramType;\n  }).join(',')})`\n});\n\nconst V_Struct = ctcs => val => {\n  return T_Struct(ctcs).canonicalize(val);\n};\n\nconst T_Object = co => ({ ...CBR.BT_Object(co),\n  defaultValue: (() => {\n    const obj = {};\n\n    for (const prop in co) {\n      obj[prop] = co[prop].defaultValue;\n    }\n\n    return obj;\n  })(),\n  munge: bv => {\n    const obj = {};\n    let none = true;\n\n    for (const prop in co) {\n      none = false;\n      obj[prop] = co[prop].munge(bv[prop]);\n    }\n\n    if (none) {\n      return false;\n    } else {\n      return obj;\n    }\n  },\n  unmunge: bv => {\n    const obj = {};\n\n    for (const prop in co) {\n      obj[prop] = co[prop].unmunge(bv[prop]);\n    }\n\n    return V_Object(co)(obj);\n  },\n  paramType: (() => {\n    const {\n      ascLabels\n    } = labelMaps(co);\n    const tupFields = ascLabels.map(label => `${co[label].paramType} ${label}`).join(',');\n    return `tuple(${tupFields})`;\n  })()\n});\n\nconst V_Object = co => val => {\n  return T_Object(co).canonicalize(val);\n};\n\nconst T_Data = co => {\n  // TODO: not duplicate between this and CBR.ts\n  const {\n    ascLabels,\n    labelMap\n  } = labelMaps(co);\n  return { ...CBR.BT_Data(co),\n    defaultValue: (() => {\n      const label = ascLabels[0];\n      return [label, co[label].defaultValue]; // return {ty, val: [label, co[label].defaultValue]};\n    })(),\n    // Data representation in js is a 2-tuple:\n    // [label, val]\n    // where label : string\n    // and val : co[label]\n    //\n    // Data representation in solidity is an N+1-tuple: (actually a struct)\n    // [labelInt, v0, ..., vN]\n    // where labelInt : number, 0 <= labelInt < N\n    // vN : co[ascLabels[i]]\n    //\n    munge: ([label, v]) => {\n      const i = labelMap[label];\n      const vals = ascLabels.map(label => {\n        const vco = co[label];\n        return vco.munge(vco.defaultValue);\n      });\n      vals[i] = co[label].munge(v);\n      const ret = [i];\n      return ret.concat(vals);\n    },\n    // Note: when it comes back from solidity, vs behaves like an N+1-tuple,\n    // but also has secret extra keys you can access,\n    // based on the struct field names.\n    // e.g. Maybe has keys vs[\"which\"], vs[\"_None\"], and vs[\"_Some\"],\n    // corresponding to    vs[0],       vs[1],       and vs[2] respectively.\n    // We don't currently use these, but we could.\n    unmunge: vs => {\n      const i = vs[0];\n      const label = ascLabels[i];\n      const val = vs[i + 1];\n      return V_Data(co)([label, co[label].unmunge(val)]);\n    },\n    paramType: (() => {\n      const {\n        ascLabels\n      } = labelMaps(co); // See comment on unmunge about field names that we could use but currently don't\n\n      const optionTys = ascLabels.map(label => `${co[label].paramType} _${label}`);\n      const tupFields = [`${T_UInt.paramType} which`].concat(optionTys).join(',');\n      return `tuple(${tupFields})`;\n    })()\n  };\n};\n\nconst V_Data = co => val => {\n  return T_Data(co).canonicalize(val);\n};\n\nexport const addressEq = shared.mkAddressEq(T_Address);\nconst T_Token = T_Address;\nexport const tokenEq = addressEq;\nexport const typeDefs = {\n  T_Null,\n  T_Bool,\n  T_UInt,\n  T_Bytes,\n  T_Address,\n  T_Digest,\n  T_Token,\n  T_Object,\n  T_Data,\n  T_Array,\n  T_Tuple,\n  T_Struct\n};\nexport const stdlib = { ...shared,\n  ...typeDefs,\n  addressEq,\n  tokenEq,\n  digest,\n  UInt_max\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/@reach-sh/stdlib/ETH_compiled.mjs"],"names":["ethers","shared","CBR","labelMaps","BigNumber","UInt_max","from","pow","sub","digest","makeDigest","t","v","paramType","Array","isArray","length","Error","JSON","stringify","utils","defaultAbiCoder","encode","munge","V_Null","T_Null","BT_Null","defaultValue","bv","unmunge","nv","T_Bool","BT_Bool","V_Bool","b","canonicalize","T_UInt","BT_UInt","V_UInt","n","T_Bytes","len","me","BT_Bytes","padEnd","toUtf8Bytes","hexToString","hexlify","T_Digest","BT_Digest","keccak256","V_Digest","toHexString","s","addressUnwrapper","x","slice","networkAccount","address","T_Address","BT_Address","uv","val","fill","join","V_Address","T_Array","ctc","size","BT_Array","map","arg","V_Array","T_Tuple","ctcs","BT_Tuple","i","args","V_Tuple","T_Struct","BT_Struct","obj","forEach","prop","co","k","V_Struct","T_Object","BT_Object","none","V_Object","ascLabels","tupFields","label","T_Data","labelMap","BT_Data","vals","vco","ret","concat","vs","V_Data","optionTys","addressEq","mkAddressEq","T_Token","tokenEq","typeDefs","stdlib"],"mappings":"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","sourcesContent":["// ****************************************************************************\n// standard library needed at runtime by compiled Reach programs\n// ****************************************************************************\nimport ethers from 'ethers';\nimport * as shared from './shared.mjs';\nimport * as CBR from './CBR.mjs';\nimport { labelMaps } from './shared_impl.mjs';\nconst BigNumber = ethers.BigNumber;\nexport const UInt_max = BigNumber.from(2).pow(256).sub(1);\nexport const digest = shared.makeDigest((t, v) => {\n  // Note: abiCoder.encode doesn't correctly handle an empty tuple type\n  if (t.paramType === 'tuple()') {\n    if (Array.isArray(v) && v.length === 0) {\n      return v;\n    } else {\n      throw Error(`impossible: digest tuple() with non-empty array: ${JSON.stringify(v)}`);\n    }\n  }\n  return ethers.utils.defaultAbiCoder.encode([t.paramType], [t.munge(v)]);\n});\nconst V_Null = null;\nconst T_Null = {\n  ...CBR.BT_Null,\n  defaultValue: V_Null,\n  // null is represented in solidity as false\n  munge: (bv) => (void(bv), false),\n  unmunge: (nv) => (void(nv), V_Null),\n  paramType: 'bool',\n};\nconst T_Bool = {\n  ...CBR.BT_Bool,\n  defaultValue: false,\n  munge: (bv) => bv,\n  unmunge: (nv) => V_Bool(nv),\n  paramType: 'bool',\n};\nconst V_Bool = (b) => {\n  return T_Bool.canonicalize(b);\n};\nexport const T_UInt = {\n  ...CBR.BT_UInt,\n  defaultValue: ethers.BigNumber.from(0),\n  munge: (bv) => bv,\n  unmunge: (nv) => V_UInt(nv),\n  paramType: 'uint256',\n};\nconst V_UInt = (n) => {\n  return T_UInt.canonicalize(n);\n};\nconst T_Bytes = (len) => {\n  const me = {\n    ...CBR.BT_Bytes(len),\n    defaultValue: ''.padEnd(len, '\\0'),\n    munge: (bv) => Array.from(ethers.utils.toUtf8Bytes(bv)),\n    unmunge: (nv) => me.canonicalize(shared.hexToString(ethers.utils.hexlify(nv))),\n    paramType: `uint8[${len}]`,\n  };\n  return me;\n};\nconst T_Digest = {\n  ...CBR.BT_Digest,\n  defaultValue: ethers.utils.keccak256([]),\n  munge: (bv) => BigNumber.from(bv),\n  // XXX likely not the correct unmunge type?\n  unmunge: (nv) => V_Digest(nv.toHexString()),\n  paramType: 'uint256',\n};\nconst V_Digest = (s) => {\n  return T_Digest.canonicalize(s);\n};\n\nfunction addressUnwrapper(x) {\n  // TODO: set it up so that .address is always there\n  // Just putting it here to appease BT_Address.canonicalize\n  if (typeof x === 'string') {\n    // XXX is this actually needed?\n    if (x.slice(0, 2) !== '0x') {\n      return '0x' + x;\n    } else {\n      return x;\n    }\n  } else if (x.networkAccount && x.networkAccount.address) {\n    return (x.networkAccount.address);\n  } else if (x.address) {\n    return x.address;\n  } else {\n    throw Error(`Failed to unwrap address ${x}`);\n  }\n}\nconst T_Address = {\n  ...CBR.BT_Address,\n  canonicalize: (uv) => {\n    const val = addressUnwrapper(uv);\n    return CBR.BT_Address.canonicalize(val || uv);\n  },\n  defaultValue: '0x' + Array(40).fill('0').join(''),\n  munge: (bv) => bv,\n  unmunge: (nv) => V_Address(nv),\n  paramType: 'address',\n};\nconst V_Address = (s) => {\n  // Uses ETH-specific canonicalize!\n  return T_Address.canonicalize(s);\n};\nconst T_Array = (ctc, size) => ({\n  ...CBR.BT_Array(ctc, size),\n  defaultValue: Array(size).fill(ctc.defaultValue),\n  munge: (bv) => {\n    if (size == 0) {\n      return false;\n    } else {\n      return bv.map((arg) => ctc.munge(arg));\n    }\n  },\n  unmunge: (nv) => {\n    if (size == 0) {\n      return [];\n    } else {\n      return V_Array(ctc, size)(nv.map((arg) => ctc.unmunge(arg)));\n    }\n  },\n  paramType: `${ctc.paramType}[${size}]`,\n});\nconst V_Array = (ctc, size) => (val) => {\n  return T_Array(ctc, size).canonicalize(val);\n};\n// XXX fix me Dan, I'm type checking wrong!\nconst T_Tuple = (ctcs) => ({\n  ...CBR.BT_Tuple(ctcs),\n  defaultValue: ctcs.map(ctc => ctc.defaultValue),\n  munge: (bv) => {\n    if (ctcs.length == 0) {\n      return false;\n    } else {\n      return bv.map((arg, i) => ctcs[i].munge(arg));\n    }\n  },\n  unmunge: (args) => {\n    return V_Tuple(ctcs)(ctcs.map((ctc, i) => ctc.unmunge(args[i])));\n  },\n  paramType: `tuple(${ctcs.map((ctc) => ctc.paramType).join(',')})`,\n});\nconst V_Tuple = (ctcs) => (val) => {\n  return T_Tuple(ctcs).canonicalize(val);\n};\nconst T_Struct = (ctcs) => ({\n  ...CBR.BT_Struct(ctcs),\n  defaultValue: (() => {\n    const obj = {};\n    ctcs.forEach(([prop, co]) => {\n      obj[prop] = co.defaultValue;\n    });\n    return obj;\n  })(),\n  munge: (bv) => {\n    if (ctcs.length == 0) {\n      return false;\n    } else {\n      return ctcs.map(([k, ctc]) => ctc.munge(bv[k]));\n    }\n  },\n  unmunge: (args) => {\n    return V_Struct(ctcs)(ctcs.map(([k, ctc], i) => { void(k); return ctc.unmunge(args[i]); }));\n  },\n  paramType: `tuple(${ctcs.map(([k, ctc]) => { void (k); return ctc.paramType; }).join(',')})`,\n});\nconst V_Struct = (ctcs) => (val) => {\n  return T_Struct(ctcs).canonicalize(val);\n};\nconst T_Object = (co) => ({\n  ...CBR.BT_Object(co),\n  defaultValue: (() => {\n    const obj = {};\n    for (const prop in co) {\n      obj[prop] = co[prop].defaultValue;\n    }\n    return obj;\n  })(),\n  munge: (bv) => {\n    const obj = {};\n    let none = true;\n    for (const prop in co) {\n      none = false;\n      obj[prop] = co[prop].munge(bv[prop]);\n    }\n    if (none) {\n      return false;\n    } else {\n      return obj;\n    }\n  },\n  unmunge: (bv) => {\n    const obj = {};\n    for (const prop in co) {\n      obj[prop] = co[prop].unmunge(bv[prop]);\n    }\n    return V_Object(co)(obj);\n  },\n  paramType: (() => {\n    const { ascLabels } = labelMaps(co);\n    const tupFields = ascLabels.map((label) => `${co[label].paramType} ${label}`).join(',');\n    return `tuple(${tupFields})`;\n  })(),\n});\nconst V_Object = (co) => (val) => {\n  return T_Object(co).canonicalize(val);\n};\nconst T_Data = (co) => {\n  // TODO: not duplicate between this and CBR.ts\n  const { ascLabels, labelMap } = labelMaps(co);\n  return {\n    ...CBR.BT_Data(co),\n    defaultValue: (() => {\n      const label = ascLabels[0];\n      return [label, co[label].defaultValue];\n      // return {ty, val: [label, co[label].defaultValue]};\n    })(),\n    // Data representation in js is a 2-tuple:\n    // [label, val]\n    // where label : string\n    // and val : co[label]\n    //\n    // Data representation in solidity is an N+1-tuple: (actually a struct)\n    // [labelInt, v0, ..., vN]\n    // where labelInt : number, 0 <= labelInt < N\n    // vN : co[ascLabels[i]]\n    //\n    munge: ([label, v]) => {\n      const i = labelMap[label];\n      const vals = ascLabels.map((label) => {\n        const vco = co[label];\n        return vco.munge(vco.defaultValue);\n      });\n      vals[i] = co[label].munge(v);\n      const ret = [i];\n      return ret.concat(vals);\n    },\n    // Note: when it comes back from solidity, vs behaves like an N+1-tuple,\n    // but also has secret extra keys you can access,\n    // based on the struct field names.\n    // e.g. Maybe has keys vs[\"which\"], vs[\"_None\"], and vs[\"_Some\"],\n    // corresponding to    vs[0],       vs[1],       and vs[2] respectively.\n    // We don't currently use these, but we could.\n    unmunge: (vs) => {\n      const i = vs[0];\n      const label = ascLabels[i];\n      const val = vs[i + 1];\n      return V_Data(co)([label, co[label].unmunge(val)]);\n    },\n    paramType: (() => {\n      const { ascLabels } = labelMaps(co);\n      // See comment on unmunge about field names that we could use but currently don't\n      const optionTys = ascLabels.map((label) => `${co[label].paramType} _${label}`);\n      const tupFields = [`${T_UInt.paramType} which`].concat(optionTys).join(',');\n      return `tuple(${tupFields})`;\n    })(),\n  };\n};\nconst V_Data = (co) => (val) => {\n  return T_Data(co).canonicalize(val);\n};\nexport const addressEq = shared.mkAddressEq(T_Address);\nconst T_Token = T_Address;\nexport const tokenEq = addressEq;\nexport const typeDefs = {\n  T_Null,\n  T_Bool,\n  T_UInt,\n  T_Bytes,\n  T_Address,\n  T_Digest,\n  T_Token,\n  T_Object,\n  T_Data,\n  T_Array,\n  T_Tuple,\n  T_Struct,\n};\nexport const stdlib = {\n  ...shared,\n  ...typeDefs,\n  addressEq,\n  tokenEq,\n  digest,\n  UInt_max,\n};\n"]},"metadata":{},"sourceType":"module"}