{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nconst encoding = require('../encoding/encoding');\n\nconst group = require('../group');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst templates = require('./templates');\n\nconst transaction = require('../transaction');\n\nclass DynamicFee {\n  /**\n   * DynamicFee contract allows you to create a transaction without\n   * specifying the fee. The fee will be determined at the moment of\n   * transfer.\n   *\n   * Constructor Parameters:\n   * @param {string} receiver: address to receive the assets\n   * @param {int} amount: amount of assets to transfer\n   * @param {int} firstValid: first valid round for the transaction\n   * @param {int} lastValid:  last valid round for the transaction\n   * @param {string} closeRemainder: if you would like to close the account after the transfer, specify the address that would recieve the remainder, else leave undefined\n   * @param {string} lease: leave undefined to generate a random lease, or supply a lease as base64\n   * @returns {DynamicFee}\n   */\n  constructor(receiver, amount, firstValid, lastValid, closeRemainder, lease) {\n    // don't need to validate receiver, closeremainderto - insert will handle that\n    if (!Number.isSafeInteger(amount) || amount < 0) throw Error('amount must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(firstValid) || firstValid < 0) throw Error('firstValid must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(lastValid) || lastValid < 0) throw Error('lastValid must be a positive number and smaller than 2^53-1');\n\n    if (typeof closeRemainder === 'undefined') {\n      // eslint-disable-next-line no-param-reassign\n      closeRemainder = address.ALGORAND_ZERO_ADDRESS_STRING;\n    }\n\n    if (typeof lease === 'undefined') {\n      const leaseBytes = nacl.randomBytes(32); // eslint-disable-next-line no-param-reassign\n\n      lease = Buffer.from(leaseBytes).toString('base64');\n    }\n\n    const referenceProgramB64 = 'ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [5\n    /* firstValid */\n    , 6\n    /* lastValid */\n    , 7\n    /* receiver */\n    , 11\n    /* closeRemainder */\n    , 44\n    /* lease */\n    , 76];\n    const injectionVector = [amount, firstValid, lastValid, receiver, closeRemainder, lease];\n    const injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS, templates.valTypes.BASE64];\n    const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    const lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * signDynamicFee returns the main transaction and signed logic needed to complete the transfer.\n * These should be sent to the fee payer, who can use GetDynamicFeeTransactions\n * @param {Uint8Array} contract: the bytearray representing the contract\n * @param {Uint8Array} secretKey: the secret key for building the logic sig\n * @param {string} genesisHash: the genesisHash to use for the txn\n * @returns {Object} object containing json of txnbuilder constructor arguments under \"txn\" and signed logicsig under \"lsig\"\n */\n\n\nfunction signDynamicFee(contract, secretKey, genesisHash) {\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n  const keys = nacl.keyPairFromSecretKey(secretKey);\n  const from = address.encodeAddress(keys.publicKey);\n  const to = address.encodeAddress(byteArrays[0]);\n  const fee = 0;\n  const amount = ints[2];\n  const closeRemainderTo = address.encodeAddress(byteArrays[1]);\n  const firstRound = ints[3];\n  const lastRound = ints[4];\n  const lease = new Uint8Array(byteArrays[2]);\n  const txn = {\n    from,\n    to,\n    fee,\n    amount,\n    closeRemainderTo,\n    firstRound,\n    lastRound,\n    genesisHash,\n    type: 'pay',\n    lease\n  };\n  const lsig = new logicSig.LogicSig(contract, undefined);\n  lsig.sign(secretKey);\n  return {\n    txn,\n    lsig\n  };\n}\n/**\n * getDynamicFeeTransactions creates and signs the secondary dynamic fee transaction, updates\n * transaction fields, and signs as the fee payer; it returns both\n * transactions as bytes suitable for sendRaw.\n * Parameters:\n * @param {dict} txn - main transaction from payer's signDynamicFee output (a dict of constructor arguments, NOT a transaction.Transaction)\n * @param {LogicSig} lsig - the signed logic received from the payer's signDynamicFee output\n * @param {Uint8Array} privateKey - the private key for the account that pays the fee\n * @param {int} fee - fee per byte for both transactions\n *\n * @throws on invalid lsig\n */\n\n/* eslint-disable no-param-reassign */\n\n\nfunction getDynamicFeeTransactions(txn, lsig, privateKey, fee) {\n  if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {\n    throw new Error('invalid signature');\n  }\n\n  txn.fee = fee;\n\n  if (txn.fee < transaction.ALGORAND_MIN_TX_FEE) {\n    txn.fee = transaction.ALGORAND_MIN_TX_FEE;\n  }\n\n  const keys = nacl.keyPairFromSecretKey(privateKey);\n  const from = address.encodeAddress(keys.publicKey); // must remove lease and re-add using addLease so that fee calculation will match other SDKs\n\n  const {\n    lease\n  } = txn;\n  delete txn.lease;\n  const txnObj = new transaction.Transaction(txn);\n  txnObj.addLease(lease, fee);\n  const feePayTxn = {\n    from,\n    to: txn.from,\n    fee,\n    amount: txnObj.fee,\n    // calculated after txnObj is built to have the correct fee\n    firstRound: txn.firstRound,\n    lastRound: txn.lastRound,\n    genesisHash: txn.genesisHash,\n    type: 'pay'\n  };\n  const feePayTxnObj = new transaction.Transaction(feePayTxn);\n  feePayTxnObj.addLease(lease, fee);\n  const txnGroup = group.assignGroupID([feePayTxnObj, txnObj], undefined);\n  const feePayTxnWithGroup = txnGroup[0];\n  const txnObjWithGroup = txnGroup[1];\n  const lstx = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txnObjWithGroup.get_obj_for_encoding()\n  };\n  const stx1 = feePayTxnWithGroup.signTxn(privateKey);\n  const stx2 = encoding.encode(lstx);\n  const concatStx = new Uint8Array(stx1.length + stx2.length);\n  concatStx.set(stx1);\n  concatStx.set(stx2, stx1.length);\n  return concatStx;\n}\n/* eslint-enable no-param-reassign */\n\n\nmodule.exports = {\n  DynamicFee,\n  getDynamicFeeTransactions,\n  signDynamicFee\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/logicTemplates/dynamicfee.js"],"names":["Buffer","require","address","encoding","group","logic","logicSig","nacl","templates","transaction","DynamicFee","constructor","receiver","amount","firstValid","lastValid","closeRemainder","lease","Number","isSafeInteger","Error","ALGORAND_ZERO_ADDRESS_STRING","leaseBytes","randomBytes","from","toString","referenceProgramB64","referenceProgramBytes","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","BASE64","injectedBytes","inject","programBytes","lsig","LogicSig","undefined","getProgram","getAddress","signDynamicFee","contract","secretKey","genesisHash","programOutputs","readProgram","ints","byteArrays","keys","keyPairFromSecretKey","encodeAddress","publicKey","to","fee","closeRemainderTo","firstRound","lastRound","Uint8Array","txn","type","sign","getDynamicFeeTransactions","privateKey","verify","decodeAddress","ALGORAND_MIN_TX_FEE","txnObj","Transaction","addLease","feePayTxn","feePayTxnObj","txnGroup","assignGroupID","feePayTxnWithGroup","txnObjWithGroup","lstx","get_obj_for_encoding","stx1","signTxn","stx2","encode","concatStx","length","set","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require('../encoding/address');\nconst encoding = require('../encoding/encoding');\nconst group = require('../group');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst nacl = require('../nacl/naclWrappers');\nconst templates = require('./templates');\nconst transaction = require('../transaction');\n\nclass DynamicFee {\n  /**\n   * DynamicFee contract allows you to create a transaction without\n   * specifying the fee. The fee will be determined at the moment of\n   * transfer.\n   *\n   * Constructor Parameters:\n   * @param {string} receiver: address to receive the assets\n   * @param {int} amount: amount of assets to transfer\n   * @param {int} firstValid: first valid round for the transaction\n   * @param {int} lastValid:  last valid round for the transaction\n   * @param {string} closeRemainder: if you would like to close the account after the transfer, specify the address that would recieve the remainder, else leave undefined\n   * @param {string} lease: leave undefined to generate a random lease, or supply a lease as base64\n   * @returns {DynamicFee}\n   */\n  constructor(receiver, amount, firstValid, lastValid, closeRemainder, lease) {\n    // don't need to validate receiver, closeremainderto - insert will handle that\n    if (!Number.isSafeInteger(amount) || amount < 0)\n      throw Error('amount must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(firstValid) || firstValid < 0)\n      throw Error(\n        'firstValid must be a positive number and smaller than 2^53-1'\n      );\n    if (!Number.isSafeInteger(lastValid) || lastValid < 0)\n      throw Error(\n        'lastValid must be a positive number and smaller than 2^53-1'\n      );\n\n    if (typeof closeRemainder === 'undefined') {\n      // eslint-disable-next-line no-param-reassign\n      closeRemainder = address.ALGORAND_ZERO_ADDRESS_STRING;\n    }\n    if (typeof lease === 'undefined') {\n      const leaseBytes = nacl.randomBytes(32);\n      // eslint-disable-next-line no-param-reassign\n      lease = Buffer.from(leaseBytes).toString('base64');\n    }\n\n    const referenceProgramB64 =\n      'ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [\n      5 /* firstValid */,\n      6 /* lastValid */,\n      7 /* receiver */,\n      11 /* closeRemainder */,\n      44 /* lease */,\n      76,\n    ];\n    const injectionVector = [\n      amount,\n      firstValid,\n      lastValid,\n      receiver,\n      closeRemainder,\n      lease,\n    ];\n    const injectionTypes = [\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.ADDRESS,\n      templates.valTypes.ADDRESS,\n      templates.valTypes.BASE64,\n    ];\n    const injectedBytes = templates.inject(\n      referenceProgramBytes,\n      referenceOffsets,\n      injectionVector,\n      injectionTypes\n    );\n    this.programBytes = injectedBytes;\n    const lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n  getProgram() {\n    return this.programBytes;\n  }\n\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n  getAddress() {\n    return this.address;\n  }\n}\n/**\n * signDynamicFee returns the main transaction and signed logic needed to complete the transfer.\n * These should be sent to the fee payer, who can use GetDynamicFeeTransactions\n * @param {Uint8Array} contract: the bytearray representing the contract\n * @param {Uint8Array} secretKey: the secret key for building the logic sig\n * @param {string} genesisHash: the genesisHash to use for the txn\n * @returns {Object} object containing json of txnbuilder constructor arguments under \"txn\" and signed logicsig under \"lsig\"\n */\nfunction signDynamicFee(contract, secretKey, genesisHash) {\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n  const keys = nacl.keyPairFromSecretKey(secretKey);\n  const from = address.encodeAddress(keys.publicKey);\n  const to = address.encodeAddress(byteArrays[0]);\n  const fee = 0;\n  const amount = ints[2];\n  const closeRemainderTo = address.encodeAddress(byteArrays[1]);\n  const firstRound = ints[3];\n  const lastRound = ints[4];\n  const lease = new Uint8Array(byteArrays[2]);\n  const txn = {\n    from,\n    to,\n    fee,\n    amount,\n    closeRemainderTo,\n    firstRound,\n    lastRound,\n    genesisHash,\n    type: 'pay',\n    lease,\n  };\n\n  const lsig = new logicSig.LogicSig(contract, undefined);\n  lsig.sign(secretKey);\n  return { txn, lsig };\n}\n\n/**\n * getDynamicFeeTransactions creates and signs the secondary dynamic fee transaction, updates\n * transaction fields, and signs as the fee payer; it returns both\n * transactions as bytes suitable for sendRaw.\n * Parameters:\n * @param {dict} txn - main transaction from payer's signDynamicFee output (a dict of constructor arguments, NOT a transaction.Transaction)\n * @param {LogicSig} lsig - the signed logic received from the payer's signDynamicFee output\n * @param {Uint8Array} privateKey - the private key for the account that pays the fee\n * @param {int} fee - fee per byte for both transactions\n *\n * @throws on invalid lsig\n */\n/* eslint-disable no-param-reassign */\nfunction getDynamicFeeTransactions(txn, lsig, privateKey, fee) {\n  if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {\n    throw new Error('invalid signature');\n  }\n\n  txn.fee = fee;\n  if (txn.fee < transaction.ALGORAND_MIN_TX_FEE) {\n    txn.fee = transaction.ALGORAND_MIN_TX_FEE;\n  }\n\n  const keys = nacl.keyPairFromSecretKey(privateKey);\n  const from = address.encodeAddress(keys.publicKey);\n\n  // must remove lease and re-add using addLease so that fee calculation will match other SDKs\n  const { lease } = txn;\n  delete txn.lease;\n\n  const txnObj = new transaction.Transaction(txn);\n  txnObj.addLease(lease, fee);\n\n  const feePayTxn = {\n    from,\n    to: txn.from,\n    fee,\n    amount: txnObj.fee, // calculated after txnObj is built to have the correct fee\n    firstRound: txn.firstRound,\n    lastRound: txn.lastRound,\n    genesisHash: txn.genesisHash,\n    type: 'pay',\n  };\n  const feePayTxnObj = new transaction.Transaction(feePayTxn);\n  feePayTxnObj.addLease(lease, fee);\n\n  const txnGroup = group.assignGroupID([feePayTxnObj, txnObj], undefined);\n  const feePayTxnWithGroup = txnGroup[0];\n  const txnObjWithGroup = txnGroup[1];\n\n  const lstx = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txnObjWithGroup.get_obj_for_encoding(),\n  };\n\n  const stx1 = feePayTxnWithGroup.signTxn(privateKey);\n  const stx2 = encoding.encode(lstx);\n\n  const concatStx = new Uint8Array(stx1.length + stx2.length);\n  concatStx.set(stx1);\n  concatStx.set(stx2, stx1.length);\n\n  return concatStx;\n}\n/* eslint-enable no-param-reassign */\n\nmodule.exports = {\n  DynamicFee,\n  getDynamicFeeTransactions,\n  signDynamicFee,\n};\n"]},"metadata":{},"sourceType":"script"}