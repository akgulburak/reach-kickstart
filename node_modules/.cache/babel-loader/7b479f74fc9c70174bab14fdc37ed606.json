{"ast":null,"code":"/* eslint-disable no-bitwise */\nconst english = require('./wordlists/english');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst address = require('../encoding/address');\n\nconst FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = 'failed to decode mnemonic';\nconst NOT_IN_WORDS_LIST_ERROR_MSG = 'the mnemonic contains a word that is not in the wordlist'; // https://stackoverflow.com/a/51452614\n\nfunction toUint11Array(buffer8) {\n  const buffer11 = [];\n  let acc = 0;\n  let accBits = 0;\n\n  function add(octet) {\n    acc |= octet << accBits;\n    accBits += 8;\n\n    if (accBits >= 11) {\n      buffer11.push(acc & 0x7ff);\n      acc >>= 11;\n      accBits -= 11;\n    }\n  }\n\n  function flush() {\n    if (accBits) {\n      buffer11.push(acc);\n    }\n  }\n\n  buffer8.forEach(add);\n  flush();\n  return buffer11;\n}\n\nfunction applyWords(nums) {\n  return nums.map(n => english[n]);\n}\n\nfunction computeChecksum(seed) {\n  const hashBuffer = nacl.genericHash(seed);\n  const uint11Hash = toUint11Array(hashBuffer);\n  const words = applyWords(uint11Hash);\n  return words[0];\n}\n/**\n * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.\n * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.\n * @param seed 32 bytes long seed\n * @returns {string} 25 words mnemonic\n */\n\n\nfunction mnemonicFromSeed(seed) {\n  // Sanity length check\n  if (seed.length !== nacl.SEED_BTYES_LENGTH) {\n    throw new RangeError(`Seed length must be ${nacl.SEED_BTYES_LENGTH}`);\n  }\n\n  const uint11Array = toUint11Array(seed);\n  const words = applyWords(uint11Array);\n  const checksumWord = computeChecksum(seed);\n  return `${words.join(' ')} ${checksumWord}`;\n} // from Uint11Array\n// https://stackoverflow.com/a/51452614\n\n\nfunction toUint8Array(buffer11) {\n  const buffer8 = [];\n  let acc = 0;\n  let accBits = 0;\n\n  function add(ui11) {\n    acc |= ui11 << accBits;\n    accBits += 11;\n\n    while (accBits >= 8) {\n      buffer8.push(acc & 0xff);\n      acc >>= 8;\n      accBits -= 8;\n    }\n  }\n\n  function flush() {\n    if (accBits) {\n      buffer8.push(acc);\n    }\n  }\n\n  buffer11.forEach(add);\n  flush();\n  return new Uint8Array(buffer8);\n}\n/**\n * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.\n * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one\n * of the passed words is not found in the words list.\n * @param mnemonic 25 words mnemonic\n * @returns {Uint8Array} 32 bytes long seed\n */\n\n\nfunction seedFromMnemonic(mnemonic) {\n  const words = mnemonic.split(' ');\n  const key = words.slice(0, 24); // Check that all words are in list\n\n  for (const w of key) {\n    if (english.indexOf(w) === -1) throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);\n  }\n\n  const checksum = words[words.length - 1];\n  const uint11Array = key.map(word => english.indexOf(word)); // Convert the key to uint8Array\n\n  let uint8Array = toUint8Array(uint11Array); // We need to chop the last byte -\n  // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.\n  // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.\n  // This left gets padded with another 8 bits to the create the 24th word.\n  // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.\n  // check that we have 33 bytes long array as expected\n\n  if (uint8Array.length !== 33) throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG); // check that the last byte is actually 0x0\n\n  if (uint8Array[uint8Array.length - 1] !== 0x0) throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG); // chop it !\n\n  uint8Array = uint8Array.slice(0, uint8Array.length - 1); // compute checksum\n\n  const cs = computeChecksum(uint8Array); // success!\n\n  if (cs === checksum) return uint8Array;\n  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n}\n/**\n * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.\n * @param mn 25 words Algorand mnemonic\n * @returns {{sk: Uint8Array, addr: string}}\n * @throws error if fails to decode the mnemonic\n */\n\n\nfunction mnemonicToSecretKey(mn) {\n  const seed = seedFromMnemonic(mn);\n  const keys = nacl.keyPairFromSeed(seed);\n  const encodedPk = address.encodeAddress(keys.publicKey);\n  return {\n    addr: encodedPk,\n    sk: keys.secretKey\n  };\n}\n/**\n * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.\n * @param sk Uint8Array\n * @returns string mnemonic\n */\n\n\nfunction secretKeyToMnemonic(sk) {\n  // get the seed from the sk\n  const seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);\n  return mnemonicFromSeed(seed);\n}\n/**\n * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.\n * @param mn 25 words Algorand mnemonic\n * @returns Uint8Array\n * @throws error if fails to decode the mnemonic\n */\n\n\nfunction mnemonicToMasterDerivationKey(mn) {\n  return seedFromMnemonic(mn);\n}\n/**\n * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.\n * @param mdk Uint8Array\n * @returns string mnemonic\n */\n\n\nfunction masterDerivationKeyToMnemonic(mdk) {\n  return mnemonicFromSeed(mdk);\n}\n\nmodule.exports = {\n  mnemonicFromSeed,\n  seedFromMnemonic,\n  FAIL_TO_DECODE_MNEMONIC_ERROR_MSG,\n  NOT_IN_WORDS_LIST_ERROR_MSG,\n  mnemonicToSecretKey,\n  secretKeyToMnemonic,\n  mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/mnemonic/mnemonic.js"],"names":["english","require","nacl","address","FAIL_TO_DECODE_MNEMONIC_ERROR_MSG","NOT_IN_WORDS_LIST_ERROR_MSG","toUint11Array","buffer8","buffer11","acc","accBits","add","octet","push","flush","forEach","applyWords","nums","map","n","computeChecksum","seed","hashBuffer","genericHash","uint11Hash","words","mnemonicFromSeed","length","SEED_BTYES_LENGTH","RangeError","uint11Array","checksumWord","join","toUint8Array","ui11","Uint8Array","seedFromMnemonic","mnemonic","split","key","slice","w","indexOf","Error","checksum","word","uint8Array","cs","mnemonicToSecretKey","mn","keys","keyPairFromSeed","encodedPk","encodeAddress","publicKey","addr","sk","secretKey","secretKeyToMnemonic","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","mdk","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-bitwise */\nconst english = require('./wordlists/english');\nconst nacl = require('../nacl/naclWrappers');\nconst address = require('../encoding/address');\n\nconst FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = 'failed to decode mnemonic';\nconst NOT_IN_WORDS_LIST_ERROR_MSG =\n  'the mnemonic contains a word that is not in the wordlist';\n\n// https://stackoverflow.com/a/51452614\nfunction toUint11Array(buffer8) {\n  const buffer11 = [];\n  let acc = 0;\n  let accBits = 0;\n  function add(octet) {\n    acc |= octet << accBits;\n    accBits += 8;\n    if (accBits >= 11) {\n      buffer11.push(acc & 0x7ff);\n      acc >>= 11;\n      accBits -= 11;\n    }\n  }\n  function flush() {\n    if (accBits) {\n      buffer11.push(acc);\n    }\n  }\n\n  buffer8.forEach(add);\n  flush();\n  return buffer11;\n}\n\nfunction applyWords(nums) {\n  return nums.map((n) => english[n]);\n}\n\nfunction computeChecksum(seed) {\n  const hashBuffer = nacl.genericHash(seed);\n  const uint11Hash = toUint11Array(hashBuffer);\n  const words = applyWords(uint11Hash);\n\n  return words[0];\n}\n\n/**\n * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.\n * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.\n * @param seed 32 bytes long seed\n * @returns {string} 25 words mnemonic\n */\nfunction mnemonicFromSeed(seed) {\n  // Sanity length check\n  if (seed.length !== nacl.SEED_BTYES_LENGTH) {\n    throw new RangeError(`Seed length must be ${nacl.SEED_BTYES_LENGTH}`);\n  }\n\n  const uint11Array = toUint11Array(seed);\n  const words = applyWords(uint11Array);\n  const checksumWord = computeChecksum(seed);\n\n  return `${words.join(' ')} ${checksumWord}`;\n}\n\n// from Uint11Array\n// https://stackoverflow.com/a/51452614\nfunction toUint8Array(buffer11) {\n  const buffer8 = [];\n  let acc = 0;\n  let accBits = 0;\n  function add(ui11) {\n    acc |= ui11 << accBits;\n    accBits += 11;\n    while (accBits >= 8) {\n      buffer8.push(acc & 0xff);\n      acc >>= 8;\n      accBits -= 8;\n    }\n  }\n  function flush() {\n    if (accBits) {\n      buffer8.push(acc);\n    }\n  }\n\n  buffer11.forEach(add);\n  flush();\n  return new Uint8Array(buffer8);\n}\n\n/**\n * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.\n * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one\n * of the passed words is not found in the words list.\n * @param mnemonic 25 words mnemonic\n * @returns {Uint8Array} 32 bytes long seed\n */\nfunction seedFromMnemonic(mnemonic) {\n  const words = mnemonic.split(' ');\n  const key = words.slice(0, 24);\n\n  // Check that all words are in list\n  for (const w of key) {\n    if (english.indexOf(w) === -1) throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);\n  }\n\n  const checksum = words[words.length - 1];\n  const uint11Array = key.map((word) => english.indexOf(word));\n\n  // Convert the key to uint8Array\n  let uint8Array = toUint8Array(uint11Array);\n\n  // We need to chop the last byte -\n  // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.\n  // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.\n  // This left gets padded with another 8 bits to the create the 24th word.\n  // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.\n\n  // check that we have 33 bytes long array as expected\n  if (uint8Array.length !== 33)\n    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n\n  // check that the last byte is actually 0x0\n  if (uint8Array[uint8Array.length - 1] !== 0x0)\n    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n\n  // chop it !\n  uint8Array = uint8Array.slice(0, uint8Array.length - 1);\n\n  // compute checksum\n  const cs = computeChecksum(uint8Array);\n\n  // success!\n  if (cs === checksum) return uint8Array;\n\n  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n}\n\n/**\n * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.\n * @param mn 25 words Algorand mnemonic\n * @returns {{sk: Uint8Array, addr: string}}\n * @throws error if fails to decode the mnemonic\n */\nfunction mnemonicToSecretKey(mn) {\n  const seed = seedFromMnemonic(mn);\n  const keys = nacl.keyPairFromSeed(seed);\n  const encodedPk = address.encodeAddress(keys.publicKey);\n  return { addr: encodedPk, sk: keys.secretKey };\n}\n\n/**\n * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.\n * @param sk Uint8Array\n * @returns string mnemonic\n */\nfunction secretKeyToMnemonic(sk) {\n  // get the seed from the sk\n  const seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);\n  return mnemonicFromSeed(seed);\n}\n\n/**\n * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.\n * @param mn 25 words Algorand mnemonic\n * @returns Uint8Array\n * @throws error if fails to decode the mnemonic\n */\nfunction mnemonicToMasterDerivationKey(mn) {\n  return seedFromMnemonic(mn);\n}\n\n/**\n * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.\n * @param mdk Uint8Array\n * @returns string mnemonic\n */\nfunction masterDerivationKeyToMnemonic(mdk) {\n  return mnemonicFromSeed(mdk);\n}\n\nmodule.exports = {\n  mnemonicFromSeed,\n  seedFromMnemonic,\n  FAIL_TO_DECODE_MNEMONIC_ERROR_MSG,\n  NOT_IN_WORDS_LIST_ERROR_MSG,\n  mnemonicToSecretKey,\n  secretKeyToMnemonic,\n  mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic,\n};\n"]},"metadata":{},"sourceType":"script"}