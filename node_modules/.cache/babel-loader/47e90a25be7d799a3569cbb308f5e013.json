{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst address = require('./encoding/address');\n\nconst encoding = require('./encoding/encoding');\n\nconst logic = require('./logic/logic');\n\nconst multisig = require('./multisig');\n\nconst utils = require('./utils/utils');\n\nconst txnBuilder = require('./transaction');\n/**\n LogicSig implementation\n */\n\n\nclass LogicSig {\n  constructor(program, args) {\n    this.tag = Buffer.from('Program');\n\n    if (!logic.checkProgram(program, args)) {\n      throw new Error('Invalid program');\n    }\n\n    function checkType(arg) {\n      const theType = typeof arg;\n      return theType === 'string' || theType === 'number' || arg.constructor === Uint8Array || Buffer.isBuffer(arg);\n    }\n\n    if (args && (!Array.isArray(args) || !args.every(checkType))) {\n      throw new TypeError('Invalid arguments');\n    }\n\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  } // eslint-disable-next-line camelcase\n\n\n  get_obj_for_encoding() {\n    const obj = {\n      l: this.logic\n    };\n\n    if (this.args) {\n      obj.arg = this.args;\n    }\n\n    if (this.sig) {\n      obj.sig = this.sig;\n    } else if (this.msig) {\n      obj.msig = this.msig;\n    }\n\n    return obj;\n  } // eslint-disable-next-line camelcase\n\n\n  static from_obj_for_encoding(encoded) {\n    const lsig = new LogicSig(encoded.l, encoded.arg);\n    lsig.sig = encoded.sig;\n    lsig.msig = encoded.msig;\n    return lsig;\n  }\n  /**\n   * Performs signature verification\n   * @param {Uint8Array} publicKey Verification key (derived from sender address or escrow address)\n   * @returns {boolean}\n   */\n\n\n  verify(publicKey) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n\n    try {\n      logic.checkProgram(this.logic, this.args);\n    } catch (e) {\n      return false;\n    }\n\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n\n    if (!this.sig && !this.msig) {\n      const hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n\n    return multisig.verifyMultisig(toBeSigned, this.msig, publicKey);\n  }\n  /**\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n   * @returns {string} String representation of the address\n   */\n\n\n  address() {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const hash = nacl.genericHash(toBeSigned);\n    return address.encodeAddress(hash);\n  }\n  /**\n   * Creates signature (if no msig provided) or multi signature otherwise\n   * @param {Uint8Array} secretKey Secret key to sign with\n   * @param {Object} msig Multisig account as {version, threshold, addrs}\n   */\n\n\n  sign(secretKey, msig) {\n    if (msig === undefined) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      const subsigs = msig.addrs.map(addr => ({\n        pk: address.decodeAddress(addr).publicKey\n      }));\n      this.msig = {\n        v: msig.version,\n        thr: msig.threshold,\n        subsig: subsigs\n      };\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n  /**\n   * Appends a signature to multi signature\n   * @param {Uint8Array} secretKey Secret key to sign with\n   */\n\n\n  appendToMultisig(secretKey) {\n    if (this.msig === undefined) {\n      throw new Error('no multisig present');\n    }\n\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n\n  signProgram(secretKey) {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n\n  singleSignMultisig(secretKey, msig) {\n    let index = -1;\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n\n    for (let i = 0; i < msig.subsig.length; i++) {\n      const {\n        pk\n      } = msig.subsig[i];\n\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n\n    if (index === -1) {\n      throw new Error('invalid secret key');\n    }\n\n    const sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n\n  static fromByte(encoded) {\n    const decodedObj = encoding.decode(encoded);\n    return LogicSig.from_obj_for_encoding(decodedObj);\n  }\n\n}\n/**\n * makeLogicSig creates LogicSig object from program and arguments\n *\n * @param {Uint8Array} program Program to make LogicSig from\n * @param {[Uint8Array]} args Arguments as array of Uint8Array\n * @returns {LogicSig} LogicSig object\n */\n\n\nfunction makeLogicSig(program, args) {\n  return new LogicSig(program, args);\n}\n/**\n * signLogicSigTransactionObject takes transaction.Transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} txn transaction.Transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n */\n\n\nfunction signLogicSigTransactionObject(txn, lsig) {\n  const lstx = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txn.get_obj_for_encoding()\n  };\n  const isDelegated = lsig.sig || lsig.msig;\n\n  if (isDelegated) {\n    if (!lsig.verify(txn.from.publicKey)) {\n      throw new Error(\"Logic signature verification failed. Ensure the program is valid and the transaction sender is the program's delegated address.\");\n    }\n  } else {\n    // add AuthAddr if signing with a different program than From indicates for non-delegated LogicSig\n    const programAddr = lsig.address();\n\n    if (programAddr !== address.encodeAddress(txn.from.publicKey)) {\n      lstx.sgnr = Buffer.from(address.decodeAddress(programAddr).publicKey);\n    }\n  }\n\n  return {\n    txID: txn.txID().toString(),\n    blob: encoding.encode(lstx)\n  };\n}\n/**\n * signLogicSigTransaction takes  a raw transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} txn containing constructor arguments for a transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\n\n\nfunction signLogicSigTransaction(txn, lsig) {\n  // use signLogicSigTransactionObject directly if transaction already built\n  if (txn instanceof txnBuilder.Transaction) {\n    return signLogicSigTransactionObject(txn, lsig);\n  }\n\n  const algoTxn = new txnBuilder.Transaction(txn);\n  return signLogicSigTransactionObject(algoTxn, lsig);\n}\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\n\n\nfunction logicSigFromByte(encoded) {\n  return LogicSig.fromByte(encoded);\n}\n\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from('ProgData');\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from contract address\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param contractAddress string representation of teal contract address (program hash)\n */\n\nfunction tealSign(sk, data, contractAddress) {\n  const parts = utils.concatArrays(address.decodeAddress(contractAddress).publicKey, data);\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.sign(toBeSigned, sk);\n}\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param program - buffer with teal program\n */\n\n\nfunction tealSignFromProgram(sk, data, program) {\n  const lsig = makeLogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}\n\nmodule.exports = {\n  LogicSig,\n  makeLogicSig,\n  signLogicSigTransaction,\n  signLogicSigTransactionObject,\n  logicSigFromByte,\n  tealSign,\n  tealSignFromProgram\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/logicsig.js"],"names":["Buffer","require","nacl","address","encoding","logic","multisig","utils","txnBuilder","LogicSig","constructor","program","args","tag","from","checkProgram","Error","checkType","arg","theType","Uint8Array","isBuffer","Array","isArray","every","TypeError","sig","undefined","msig","get_obj_for_encoding","obj","l","from_obj_for_encoding","encoded","lsig","verify","publicKey","e","toBeSigned","concatArrays","hash","genericHash","arrayEqual","verifyMultisig","encodeAddress","sign","secretKey","signProgram","subsigs","addrs","map","addr","pk","decodeAddress","v","version","thr","threshold","subsig","index","singleSignMultisig","s","appendToMultisig","myPk","keyPairFromSecretKey","i","length","toByte","encode","fromByte","decodedObj","decode","makeLogicSig","signLogicSigTransactionObject","txn","lstx","isDelegated","programAddr","sgnr","txID","toString","blob","signLogicSigTransaction","Transaction","algoTxn","logicSigFromByte","SIGN_PROGRAM_DATA_PREFIX","tealSign","sk","data","contractAddress","parts","tealSignFromProgram","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst nacl = require('./nacl/naclWrappers');\nconst address = require('./encoding/address');\nconst encoding = require('./encoding/encoding');\nconst logic = require('./logic/logic');\nconst multisig = require('./multisig');\nconst utils = require('./utils/utils');\nconst txnBuilder = require('./transaction');\n\n/**\n LogicSig implementation\n */\n\nclass LogicSig {\n  constructor(program, args) {\n    this.tag = Buffer.from('Program');\n\n    if (!logic.checkProgram(program, args)) {\n      throw new Error('Invalid program');\n    }\n\n    function checkType(arg) {\n      const theType = typeof arg;\n      return (\n        theType === 'string' ||\n        theType === 'number' ||\n        arg.constructor === Uint8Array ||\n        Buffer.isBuffer(arg)\n      );\n    }\n\n    if (args && (!Array.isArray(args) || !args.every(checkType))) {\n      throw new TypeError('Invalid arguments');\n    }\n\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const obj = {\n      l: this.logic,\n    };\n    if (this.args) {\n      obj.arg = this.args;\n    }\n    if (this.sig) {\n      obj.sig = this.sig;\n    } else if (this.msig) {\n      obj.msig = this.msig;\n    }\n    return obj;\n  }\n\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(encoded) {\n    const lsig = new LogicSig(encoded.l, encoded.arg);\n    lsig.sig = encoded.sig;\n    lsig.msig = encoded.msig;\n    return lsig;\n  }\n\n  /**\n   * Performs signature verification\n   * @param {Uint8Array} publicKey Verification key (derived from sender address or escrow address)\n   * @returns {boolean}\n   */\n  verify(publicKey) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n\n    try {\n      logic.checkProgram(this.logic, this.args);\n    } catch (e) {\n      return false;\n    }\n\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n\n    if (!this.sig && !this.msig) {\n      const hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n\n    return multisig.verifyMultisig(toBeSigned, this.msig, publicKey);\n  }\n\n  /**\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n   * @returns {string} String representation of the address\n   */\n  address() {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const hash = nacl.genericHash(toBeSigned);\n    return address.encodeAddress(hash);\n  }\n\n  /**\n   * Creates signature (if no msig provided) or multi signature otherwise\n   * @param {Uint8Array} secretKey Secret key to sign with\n   * @param {Object} msig Multisig account as {version, threshold, addrs}\n   */\n  sign(secretKey, msig) {\n    if (msig === undefined) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      const subsigs = msig.addrs.map((addr) => ({\n        pk: address.decodeAddress(addr).publicKey,\n      }));\n\n      this.msig = {\n        v: msig.version,\n        thr: msig.threshold,\n        subsig: subsigs,\n      };\n\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n\n  /**\n   * Appends a signature to multi signature\n   * @param {Uint8Array} secretKey Secret key to sign with\n   */\n  appendToMultisig(secretKey) {\n    if (this.msig === undefined) {\n      throw new Error('no multisig present');\n    }\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n\n  signProgram(secretKey) {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n\n  singleSignMultisig(secretKey, msig) {\n    let index = -1;\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n    for (let i = 0; i < msig.subsig.length; i++) {\n      const { pk } = msig.subsig[i];\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n    if (index === -1) {\n      throw new Error('invalid secret key');\n    }\n    const sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n\n  static fromByte(encoded) {\n    const decodedObj = encoding.decode(encoded);\n    return LogicSig.from_obj_for_encoding(decodedObj);\n  }\n}\n\n/**\n * makeLogicSig creates LogicSig object from program and arguments\n *\n * @param {Uint8Array} program Program to make LogicSig from\n * @param {[Uint8Array]} args Arguments as array of Uint8Array\n * @returns {LogicSig} LogicSig object\n */\nfunction makeLogicSig(program, args) {\n  return new LogicSig(program, args);\n}\n\n/**\n * signLogicSigTransactionObject takes transaction.Transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} txn transaction.Transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n */\nfunction signLogicSigTransactionObject(txn, lsig) {\n  const lstx = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txn.get_obj_for_encoding(),\n  };\n\n  const isDelegated = lsig.sig || lsig.msig;\n  if (isDelegated) {\n    if (!lsig.verify(txn.from.publicKey)) {\n      throw new Error(\n        \"Logic signature verification failed. Ensure the program is valid and the transaction sender is the program's delegated address.\"\n      );\n    }\n  } else {\n    // add AuthAddr if signing with a different program than From indicates for non-delegated LogicSig\n    const programAddr = lsig.address();\n    if (programAddr !== address.encodeAddress(txn.from.publicKey)) {\n      lstx.sgnr = Buffer.from(address.decodeAddress(programAddr).publicKey);\n    }\n  }\n\n  return {\n    txID: txn.txID().toString(),\n    blob: encoding.encode(lstx),\n  };\n}\n\n/**\n * signLogicSigTransaction takes  a raw transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} txn containing constructor arguments for a transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\nfunction signLogicSigTransaction(txn, lsig) {\n  // use signLogicSigTransactionObject directly if transaction already built\n  if (txn instanceof txnBuilder.Transaction) {\n    return signLogicSigTransactionObject(txn, lsig);\n  }\n  const algoTxn = new txnBuilder.Transaction(txn);\n  return signLogicSigTransactionObject(algoTxn, lsig);\n}\n\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\nfunction logicSigFromByte(encoded) {\n  return LogicSig.fromByte(encoded);\n}\n\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from('ProgData');\n\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from contract address\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param contractAddress string representation of teal contract address (program hash)\n */\nfunction tealSign(sk, data, contractAddress) {\n  const parts = utils.concatArrays(\n    address.decodeAddress(contractAddress).publicKey,\n    data\n  );\n  const toBeSigned = Buffer.from(\n    utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts)\n  );\n  return nacl.sign(toBeSigned, sk);\n}\n\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param program - buffer with teal program\n */\nfunction tealSignFromProgram(sk, data, program) {\n  const lsig = makeLogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}\n\nmodule.exports = {\n  LogicSig,\n  makeLogicSig,\n  signLogicSigTransaction,\n  signLogicSigTransactionObject,\n  logicSigFromByte,\n  tealSign,\n  tealSignFromProgram,\n};\n"]},"metadata":{},"sourceType":"script"}