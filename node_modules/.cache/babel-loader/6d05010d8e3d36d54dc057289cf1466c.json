{"ast":null,"code":"import ethers from 'ethers';\nexport const BV_Null = null;\nexport const BT_Null = {\n  name: 'Null',\n  canonicalize: val => {\n    // Doesn't check with triple eq; we're being lenient here\n    if (val != null) {\n      throw Error(`Expected null, but got ${JSON.stringify(val)}`);\n    }\n\n    return BV_Null;\n  }\n};\nexport const BT_Bool = {\n  name: 'Bool',\n  canonicalize: val => {\n    if (typeof val !== 'boolean') {\n      throw Error(`Expected boolean, but got ${JSON.stringify(val)}`);\n    }\n\n    return val;\n  }\n};\nexport const BV_Bool = val => {\n  return BT_Bool.canonicalize(val);\n};\nexport const BT_UInt = {\n  name: 'UInt',\n  canonicalize: uv => {\n    try {\n      const val = ethers.BigNumber.from(uv);\n      return val;\n    } catch (e) {\n      if (typeof uv === 'string') {\n        throw Error(`String does not represent a BigNumber. ${JSON.stringify(uv)}`);\n      } else {\n        throw Error(`Expected BigNumber, number, or string, but got ${JSON.stringify(uv)}`);\n      }\n    }\n  }\n};\nexport const BV_UInt = val => {\n  return BT_UInt.canonicalize(val);\n};\nexport const BT_Bytes = len => ({\n  name: `Bytes(${len})`,\n  canonicalize: val => {\n    if (typeof val !== 'string') {\n      throw Error(`Bytes expected string, but got ${JSON.stringify(val)}`);\n    }\n\n    const checkLen = (label, alen, fill) => {\n      if (val.length > alen) {\n        throw Error(`Bytes(${len}) must be a ${label}string less than or equal to ${alen}, but given ${label}string of length ${val.length}`);\n      }\n\n      return val.padEnd(alen, fill);\n    };\n\n    if (val.slice(0, 2) === '0x') {\n      return checkLen('hex ', len * 2 + 2, '0');\n    } else {\n      return checkLen('', len, '\\0');\n    }\n  }\n}); // TODO: check digest length, or something similar?\n// That's probably best left to connector-specific code.\n\nexport const BT_Digest = {\n  name: 'Digest',\n  canonicalize: val => {\n    if (typeof val !== 'string') {\n      throw Error(`${JSON.stringify(val)} is not a valid digest`);\n    }\n\n    return val;\n  }\n};\n/** @description You probably don't want to create a BV_Digest manually. */\n\nexport const BV_Digest = val => {\n  return BT_Digest.canonicalize(val);\n};\nexport const BT_Address = {\n  name: 'Address',\n  canonicalize: val => {\n    if (typeof val !== 'string') {\n      throw Error(`Address must be a string, but got: ${JSON.stringify(val)}`);\n    } else if (val.slice(0, 2) !== '0x') {\n      throw Error(`Address must start with 0x, but got: ${JSON.stringify(val)}`);\n    } else if (!ethers.utils.isHexString(val)) {\n      throw Error(`Address must be a valid hex string, but got: ${JSON.stringify(val)}`);\n    }\n\n    return val;\n  }\n}; // XXX: don't use this. Use net-specific ones\n\nexport const BV_Address = val => {\n  return BT_Address.canonicalize(val);\n};\nexport const BT_Array = (ctc, size) => {\n  // TODO: check ctc, sz for sanity\n  return {\n    name: `Array(${ctc.name}, ${size})`,\n    canonicalize: args => {\n      if (!Array.isArray(args)) {\n        throw Error(`Expected an Array, but got ${JSON.stringify(args)}`);\n      }\n\n      if (size != args.length) {\n        throw Error(`Expected array of length ${size}, but got ${args.length}`);\n      }\n\n      const val = args.map(arg => ctc.canonicalize(arg));\n      return val;\n    }\n  };\n}; // Note: curried\n\n/** @example BV_Array(BT_UInt, 3)([1, 2, 3]) */\n\nexport const BV_Array = (ctc, size) => val => {\n  return BT_Array(ctc, size).canonicalize(val);\n};\nexport const BT_Tuple = ctcs => {\n  // TODO: check ctcs for sanity\n  return {\n    name: `Tuple(${ctcs.map(ctc => ` ${ctc.name} `)})`,\n    canonicalize: args => {\n      if (!Array.isArray(args)) {\n        throw Error(`Expected a Tuple, but got ${JSON.stringify(args)}`);\n      }\n\n      if (ctcs.length != args.length) {\n        throw Error(`Expected tuple of size ${ctcs.length}, but got ${args.length}`);\n      }\n\n      const val = args.map((arg, i) => ctcs[i].canonicalize(arg));\n      return val;\n    }\n  };\n}; // Note: curried\n\n/** @example BV_Tuple([BT_UInt, BT_Bytes])([42, 'hello']) */\n\nexport const BV_Tuple = ctcs => val => {\n  return BT_Tuple(ctcs).canonicalize(val);\n};\nexport const BT_Struct = ctcs => {\n  return {\n    name: `Struct([${ctcs.map(([k, ctc]) => ` [${k}, ${ctc.name}] `)}])`,\n    canonicalize: arg => {\n      const obj = {};\n      ctcs.forEach(([k, ctc], i) => {\n        obj[k] = ctc.canonicalize(Array.isArray(arg) ? arg[i] : arg[k]);\n      });\n      return obj;\n    }\n  };\n};\nexport const BV_Struct = ctcs => val => {\n  return BT_Struct(ctcs).canonicalize(val);\n};\nexport const BT_Object = co => {\n  // TODO: check co for sanity\n  return {\n    name: `Object(${Object.keys(co).map(k => ` ${k}: ${co[k].name} `)})`,\n    canonicalize: vo => {\n      if (typeof vo !== 'object') {\n        throw Error(`Expected object, but got ${JSON.stringify(vo)}`);\n      }\n\n      const obj = {};\n\n      for (const prop in co) {\n        // This is dumb but it's how ESLint says to do it\n        // https://eslint.org/docs/rules/no-prototype-builtins\n        if (!{}.hasOwnProperty.call(vo, prop)) {\n          throw Error(`Expected prop ${prop}, but didn't found it in ${Object.keys(vo)}`);\n        }\n\n        obj[prop] = co[prop].canonicalize(vo[prop]);\n      }\n\n      return obj;\n    }\n  };\n}; // Note: curried\n\n/** @example BV_Object({x: BT_UInt})({x: 3}) */\n\nexport const BV_Object = co => val => {\n  return BT_Object(co).canonicalize(val);\n};\nexport const BT_Data = co => {\n  // TODO: check co for sanity\n  return {\n    name: `Data(${Object.keys(co).map(k => ` ${k}: ${co[k].name} `)})`,\n    canonicalize: io => {\n      if (!(Array.isArray(io) && io.length == 2 && typeof io[0] == 'string')) {\n        throw Error(`Expected an array of length two to represent a data instance, but got ${JSON.stringify(io)}`);\n      }\n\n      const vn = io[0];\n\n      if (!{}.hasOwnProperty.call(co, vn)) {\n        throw Error(`Expected a variant in ${Object.keys(co)}, but got ${vn}`);\n      }\n\n      return [vn, co[vn].canonicalize(io[1])];\n    }\n  };\n};\n/** @example BV_Data({x: BT_UInt, y: BT_Bytes})(['x', 3]); */\n\nexport const BV_Data = co => val => {\n  return BT_Data(co).canonicalize(val);\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/@reach-sh/stdlib/CBR.mjs"],"names":["ethers","BV_Null","BT_Null","name","canonicalize","val","Error","JSON","stringify","BT_Bool","BV_Bool","BT_UInt","uv","BigNumber","from","e","BV_UInt","BT_Bytes","len","checkLen","label","alen","fill","length","padEnd","slice","BT_Digest","BV_Digest","BT_Address","utils","isHexString","BV_Address","BT_Array","ctc","size","args","Array","isArray","map","arg","BV_Array","BT_Tuple","ctcs","i","BV_Tuple","BT_Struct","k","obj","forEach","BV_Struct","BT_Object","co","Object","keys","vo","prop","hasOwnProperty","call","BV_Object","BT_Data","io","vn","BV_Data"],"mappings":"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","sourcesContent":["import ethers from 'ethers';\nexport const BV_Null = null;\nexport const BT_Null = {\n  name: 'Null',\n  canonicalize: (val) => {\n    // Doesn't check with triple eq; we're being lenient here\n    if (val != null) {\n      throw Error(`Expected null, but got ${JSON.stringify(val)}`);\n    }\n    return BV_Null;\n  },\n};\nexport const BT_Bool = {\n  name: 'Bool',\n  canonicalize: (val) => {\n    if (typeof(val) !== 'boolean') {\n      throw Error(`Expected boolean, but got ${JSON.stringify(val)}`);\n    }\n    return val;\n  },\n};\nexport const BV_Bool = (val) => {\n  return BT_Bool.canonicalize(val);\n};\nexport const BT_UInt = {\n  name: 'UInt',\n  canonicalize: (uv) => {\n    try {\n      const val = ethers.BigNumber.from(uv);\n      return val;\n    } catch (e) {\n      if (typeof(uv) === 'string') {\n        throw Error(`String does not represent a BigNumber. ${JSON.stringify(uv)}`);\n      } else {\n        throw Error(`Expected BigNumber, number, or string, but got ${JSON.stringify(uv)}`);\n      }\n    }\n  },\n};\nexport const BV_UInt = (val) => {\n  return BT_UInt.canonicalize(val);\n};\nexport const BT_Bytes = (len) => ({\n  name: `Bytes(${len})`,\n  canonicalize: (val) => {\n    if (typeof(val) !== 'string') {\n      throw Error(`Bytes expected string, but got ${JSON.stringify(val)}`);\n    }\n    const checkLen = (label, alen, fill) => {\n      if (val.length > alen) {\n        throw Error(`Bytes(${len}) must be a ${label}string less than or equal to ${alen}, but given ${label}string of length ${val.length}`);\n      }\n      return val.padEnd(alen, fill);\n    };\n    if (val.slice(0, 2) === '0x') {\n      return checkLen('hex ', len * 2 + 2, '0');\n    } else {\n      return checkLen('', len, '\\0');\n    }\n  },\n});\n// TODO: check digest length, or something similar?\n// That's probably best left to connector-specific code.\nexport const BT_Digest = {\n  name: 'Digest',\n  canonicalize: (val) => {\n    if (typeof val !== 'string') {\n      throw Error(`${JSON.stringify(val)} is not a valid digest`);\n    }\n    return val;\n  },\n};\n/** @description You probably don't want to create a BV_Digest manually. */\nexport const BV_Digest = (val) => {\n  return BT_Digest.canonicalize(val);\n};\nexport const BT_Address = ({\n  name: 'Address',\n  canonicalize: (val) => {\n    if (typeof val !== 'string') {\n      throw Error(`Address must be a string, but got: ${JSON.stringify(val)}`);\n    } else if (val.slice(0, 2) !== '0x') {\n      throw Error(`Address must start with 0x, but got: ${JSON.stringify(val)}`);\n    } else if (!ethers.utils.isHexString(val)) {\n      throw Error(`Address must be a valid hex string, but got: ${JSON.stringify(val)}`);\n    }\n    return val;\n  },\n});\n// XXX: don't use this. Use net-specific ones\nexport const BV_Address = (val) => {\n  return BT_Address.canonicalize(val);\n};\nexport const BT_Array = (ctc, size) => {\n  // TODO: check ctc, sz for sanity\n  return {\n    name: `Array(${ctc.name}, ${size})`,\n    canonicalize: (args) => {\n      if (!Array.isArray(args)) {\n        throw Error(`Expected an Array, but got ${JSON.stringify(args)}`);\n      }\n      if (size != args.length) {\n        throw Error(`Expected array of length ${size}, but got ${args.length}`);\n      }\n      const val = args.map((arg) => ctc.canonicalize(arg));\n      return val;\n    },\n  };\n};\n// Note: curried\n/** @example BV_Array(BT_UInt, 3)([1, 2, 3]) */\nexport const BV_Array = (ctc, size) => (val) => {\n  return BT_Array(ctc, size).canonicalize(val);\n};\nexport const BT_Tuple = (ctcs) => {\n  // TODO: check ctcs for sanity\n  return {\n    name: `Tuple(${ctcs.map((ctc) => ` ${ctc.name} `)})`,\n    canonicalize: (args) => {\n      if (!Array.isArray(args)) {\n        throw Error(`Expected a Tuple, but got ${JSON.stringify(args)}`);\n      }\n      if (ctcs.length != args.length) {\n        throw Error(`Expected tuple of size ${ctcs.length}, but got ${args.length}`);\n      }\n      const val = args.map((arg, i) => ctcs[i].canonicalize(arg));\n      return val;\n    },\n  };\n};\n// Note: curried\n/** @example BV_Tuple([BT_UInt, BT_Bytes])([42, 'hello']) */\nexport const BV_Tuple = (ctcs) => (val) => {\n  return BT_Tuple(ctcs).canonicalize(val);\n};\nexport const BT_Struct = (ctcs) => {\n  return {\n    name: `Struct([${ctcs.map(([k, ctc]) => ` [${k}, ${ctc.name}] `)}])`,\n    canonicalize: (arg) => {\n      const obj = {};\n      ctcs.forEach(([k, ctc], i) => {\n        obj[k] = ctc.canonicalize(Array.isArray(arg) ? arg[i] : arg[k]);\n      });\n      return obj;\n    },\n  };\n};\nexport const BV_Struct = (ctcs) => (val) => {\n  return BT_Struct(ctcs).canonicalize(val);\n};\nexport const BT_Object = (co) => {\n  // TODO: check co for sanity\n  return {\n    name: `Object(${Object.keys(co).map((k) => ` ${k}: ${co[k].name} `)})`,\n    canonicalize: (vo) => {\n      if (typeof(vo) !== 'object') {\n        throw Error(`Expected object, but got ${JSON.stringify(vo)}`);\n      }\n      const obj = {};\n      for (const prop in co) {\n        // This is dumb but it's how ESLint says to do it\n        // https://eslint.org/docs/rules/no-prototype-builtins\n        if (!{}.hasOwnProperty.call(vo, prop)) {\n          throw Error(`Expected prop ${prop}, but didn't found it in ${Object.keys(vo)}`);\n        }\n        obj[prop] = co[prop].canonicalize(vo[prop]);\n      }\n      return obj;\n    },\n  };\n};\n// Note: curried\n/** @example BV_Object({x: BT_UInt})({x: 3}) */\nexport const BV_Object = (co) => (val) => {\n  return BT_Object(co).canonicalize(val);\n};\nexport const BT_Data = (co) => {\n  // TODO: check co for sanity\n  return {\n    name: `Data(${Object.keys(co).map((k) => ` ${k}: ${co[k].name} `)})`,\n    canonicalize: (io) => {\n      if (!(Array.isArray(io) && io.length == 2 && typeof io[0] == 'string')) {\n        throw Error(`Expected an array of length two to represent a data instance, but got ${JSON.stringify(io)}`);\n      }\n      const vn = io[0];\n      if (!{}.hasOwnProperty.call(co, vn)) {\n        throw Error(`Expected a variant in ${Object.keys(co)}, but got ${vn}`);\n      }\n      return [vn, co[vn].canonicalize(io[1])];\n    },\n  };\n};\n/** @example BV_Data({x: BT_UInt, y: BT_Bytes})(['x', 3]); */\nexport const BV_Data = (co) => (val) => {\n  return BT_Data(co).canonicalize(val);\n};\n"]},"metadata":{},"sourceType":"module"}