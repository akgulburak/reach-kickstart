{"ast":null,"code":"/* eslint-disable no-bitwise */\n\n/**\n * Utilities for working with program bytes.\n */\nconst langspec = require('./langspec.json');\n\nlet opcodes;\nconst maxCost = 20000;\nconst maxLength = 1000;\n\nfunction parseUvarint(array) {\n  let x = 0;\n  let s = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    const b = array[i];\n\n    if (b < 0x80) {\n      if (i > 9 || i === 9 && b > 1) {\n        return [0, -(i + 1)];\n      }\n\n      return [x | b << s, i + 1];\n    }\n\n    x += (b & 0x7f) << s;\n    s += 7;\n  }\n\n  return [0, 0];\n}\n\nfunction readIntConstBlock(program, pc) {\n  let size = 1;\n  const parsed = parseUvarint(program.slice(pc + size));\n  const numInts = parsed[0];\n  let bytesUsed = parsed[1];\n\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode int const block size at pc=${pc + size}`);\n  }\n\n  const ints = [];\n  size += bytesUsed;\n\n  for (let i = 0; i < numInts; i++) {\n    if (pc + size >= program.length) {\n      throw new Error('intcblock ran past end of program');\n    }\n\n    let numberFound;\n    [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n    if (bytesUsed <= 0) {\n      throw new Error(`could not decode int const[${i}] block size at pc=${pc + size}`);\n    }\n\n    ints.push(numberFound);\n    size += bytesUsed;\n  }\n\n  return [size, ints];\n}\n\nfunction readByteConstBlock(program, pc) {\n  let size = 1;\n  const parsed = parseUvarint(program.slice(pc + size));\n  const numInts = parsed[0];\n  let bytesUsed = parsed[1];\n\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode []byte const block size at pc=${pc + size}`);\n  }\n\n  const byteArrays = [];\n  size += bytesUsed;\n\n  for (let i = 0; i < numInts; i++) {\n    if (pc + size >= program.length) {\n      throw new Error('bytecblock ran past end of program');\n    }\n\n    let itemLen;\n    [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n    if (bytesUsed <= 0) {\n      throw new Error(`could not decode []byte] const[${i}] block size at pc=${pc + size}`);\n    }\n\n    size += bytesUsed;\n\n    if (pc + size + itemLen > program.length) {\n      throw new Error('bytecblock ran past end of program');\n    }\n\n    const byteArray = program.slice(pc + size, pc + size + itemLen);\n    byteArrays.push(byteArray);\n    size += itemLen;\n  }\n\n  return [size, byteArrays];\n}\n\nfunction readPushIntOp(program, pc) {\n  let size = 1;\n  const [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode push int const at pc=${pc + size}`);\n  }\n\n  size += bytesUsed;\n  return [size, numberFound];\n}\n\nfunction readPushByteOp(program, pc) {\n  let size = 1;\n  const [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode push []byte const size at pc=${pc + size}`);\n  }\n\n  size += bytesUsed;\n\n  if (pc + size + itemLen > program.length) {\n    throw new Error('pushbytes ran past end of program');\n  }\n\n  const byteArray = program.slice(pc + size, pc + size + itemLen);\n  size += itemLen;\n  return [size, byteArray];\n}\n/** readProgram validates program for length and running cost,\n * and additionally provides the found int variables and byte blocks\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {[Uint8Array, [Uint8Array], boolean]}\n */\n\n\nfunction readProgram(program, args) {\n  const intcblockOpcode = 32;\n  const bytecblockOpcode = 38;\n  const pushbytesOpcode = 128;\n  const pushintOpcode = 129;\n\n  if (!program) {\n    throw new Error('empty program');\n  }\n\n  if (typeof args === 'undefined') {\n    // eslint-disable-next-line no-param-reassign\n    args = [];\n  }\n\n  if (!Array.isArray(args)) {\n    throw new Error('invalid arguments');\n  }\n\n  const [version, vlen] = parseUvarint(program);\n\n  if (vlen <= 0) {\n    throw new Error('version parsing error');\n  }\n\n  if (version > langspec.EvalMaxVersion) {\n    throw new Error('unsupported version');\n  }\n\n  let cost = 0;\n  let {\n    length\n  } = program;\n\n  for (const arg of args) {\n    length += arg.length;\n  }\n\n  if (length > maxLength) {\n    throw new Error('program too long');\n  }\n\n  if (!opcodes) {\n    opcodes = {};\n\n    for (const op of langspec.Ops) {\n      opcodes[op.Opcode] = op;\n    }\n  }\n\n  let pc = vlen;\n  let ints = [];\n  let byteArrays = [];\n\n  while (pc < program.length) {\n    const op = opcodes[program[pc]];\n\n    if (op === undefined) {\n      throw new Error('invalid instruction');\n    }\n\n    cost += op.Cost;\n    let size = op.Size;\n\n    if (size === 0) {\n      switch (op.Opcode) {\n        case intcblockOpcode:\n          {\n            let foundInts;\n            [size, foundInts] = readIntConstBlock(program, pc);\n            ints = ints.concat(foundInts);\n            break;\n          }\n\n        case bytecblockOpcode:\n          {\n            let foundByteArrays;\n            [size, foundByteArrays] = readByteConstBlock(program, pc);\n            byteArrays = byteArrays.concat(foundByteArrays);\n            break;\n          }\n\n        case pushintOpcode:\n          {\n            let foundInt;\n            [size, foundInt] = readPushIntOp(program, pc);\n            ints.push(foundInt);\n            break;\n          }\n\n        case pushbytesOpcode:\n          {\n            let foundByteArray;\n            [size, foundByteArray] = readPushByteOp(program, pc);\n            byteArrays.push(foundByteArray);\n            break;\n          }\n\n        default:\n          {\n            throw new Error('invalid instruction');\n          }\n      }\n    }\n\n    pc += size;\n  }\n\n  if (cost > maxCost) {\n    throw new Error('program too costly to run');\n  }\n\n  return [ints, byteArrays, true];\n}\n/**\n * checkProgram validates program for length and running cost\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {boolean} true if success\n */\n\n\nfunction checkProgram(program, args) {\n  const [,, success] = readProgram(program, args);\n  return success;\n}\n\nfunction checkIntConstBlock(program, pc) {\n  const [size] = readIntConstBlock(program, pc);\n  return size;\n}\n\nfunction checkByteConstBlock(program, pc) {\n  const [size] = readByteConstBlock(program, pc);\n  return size;\n}\n\nfunction checkPushIntOp(program, pc) {\n  const [size] = readPushIntOp(program, pc);\n  return size;\n}\n\nfunction checkPushByteOp(program, pc) {\n  const [size] = readPushByteOp(program, pc);\n  return size;\n}\n\nmodule.exports = {\n  checkProgram,\n  readProgram,\n  parseUvarint,\n  checkIntConstBlock,\n  checkByteConstBlock,\n  checkPushIntOp,\n  checkPushByteOp,\n  langspecEvalMaxVersion: langspec.EvalMaxVersion,\n  langspecLogicSigVersion: langspec.LogicSigVersion\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/logic/logic.js"],"names":["langspec","require","opcodes","maxCost","maxLength","parseUvarint","array","x","s","i","length","b","readIntConstBlock","program","pc","size","parsed","slice","numInts","bytesUsed","Error","ints","numberFound","push","readByteConstBlock","byteArrays","itemLen","byteArray","readPushIntOp","readPushByteOp","readProgram","args","intcblockOpcode","bytecblockOpcode","pushbytesOpcode","pushintOpcode","Array","isArray","version","vlen","EvalMaxVersion","cost","arg","op","Ops","Opcode","undefined","Cost","Size","foundInts","concat","foundByteArrays","foundInt","foundByteArray","checkProgram","success","checkIntConstBlock","checkByteConstBlock","checkPushIntOp","checkPushByteOp","module","exports","langspecEvalMaxVersion","langspecLogicSigVersion","LogicSigVersion"],"mappings":"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","sourcesContent":["/* eslint-disable no-bitwise */\n/**\n * Utilities for working with program bytes.\n */\n\nconst langspec = require('./langspec.json');\n\nlet opcodes;\n\nconst maxCost = 20000;\nconst maxLength = 1000;\n\nfunction parseUvarint(array) {\n  let x = 0;\n  let s = 0;\n  for (let i = 0; i < array.length; i++) {\n    const b = array[i];\n    if (b < 0x80) {\n      if (i > 9 || (i === 9 && b > 1)) {\n        return [0, -(i + 1)];\n      }\n      return [x | (b << s), i + 1];\n    }\n    x += (b & 0x7f) << s;\n    s += 7;\n  }\n  return [0, 0];\n}\n\nfunction readIntConstBlock(program, pc) {\n  let size = 1;\n  const parsed = parseUvarint(program.slice(pc + size));\n  const numInts = parsed[0];\n  let bytesUsed = parsed[1];\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode int const block size at pc=${pc + size}`);\n  }\n  const ints = [];\n  size += bytesUsed;\n  for (let i = 0; i < numInts; i++) {\n    if (pc + size >= program.length) {\n      throw new Error('intcblock ran past end of program');\n    }\n    let numberFound;\n    [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));\n    if (bytesUsed <= 0) {\n      throw new Error(\n        `could not decode int const[${i}] block size at pc=${pc + size}`\n      );\n    }\n    ints.push(numberFound);\n    size += bytesUsed;\n  }\n  return [size, ints];\n}\n\nfunction readByteConstBlock(program, pc) {\n  let size = 1;\n  const parsed = parseUvarint(program.slice(pc + size));\n  const numInts = parsed[0];\n  let bytesUsed = parsed[1];\n  if (bytesUsed <= 0) {\n    throw new Error(\n      `could not decode []byte const block size at pc=${pc + size}`\n    );\n  }\n  const byteArrays = [];\n  size += bytesUsed;\n  for (let i = 0; i < numInts; i++) {\n    if (pc + size >= program.length) {\n      throw new Error('bytecblock ran past end of program');\n    }\n    let itemLen;\n    [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));\n    if (bytesUsed <= 0) {\n      throw new Error(\n        `could not decode []byte] const[${i}] block size at pc=${pc + size}`\n      );\n    }\n    size += bytesUsed;\n    if (pc + size + itemLen > program.length) {\n      throw new Error('bytecblock ran past end of program');\n    }\n    const byteArray = program.slice(pc + size, pc + size + itemLen);\n    byteArrays.push(byteArray);\n    size += itemLen;\n  }\n  return [size, byteArrays];\n}\n\nfunction readPushIntOp(program, pc) {\n  let size = 1;\n  const [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode push int const at pc=${pc + size}`);\n  }\n  size += bytesUsed;\n  return [size, numberFound];\n}\n\nfunction readPushByteOp(program, pc) {\n  let size = 1;\n  const [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));\n  if (bytesUsed <= 0) {\n    throw new Error(\n      `could not decode push []byte const size at pc=${pc + size}`\n    );\n  }\n  size += bytesUsed;\n  if (pc + size + itemLen > program.length) {\n    throw new Error('pushbytes ran past end of program');\n  }\n  const byteArray = program.slice(pc + size, pc + size + itemLen);\n  size += itemLen;\n  return [size, byteArray];\n}\n\n/** readProgram validates program for length and running cost,\n * and additionally provides the found int variables and byte blocks\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {[Uint8Array, [Uint8Array], boolean]}\n */\nfunction readProgram(program, args) {\n  const intcblockOpcode = 32;\n  const bytecblockOpcode = 38;\n  const pushbytesOpcode = 128;\n  const pushintOpcode = 129;\n\n  if (!program) {\n    throw new Error('empty program');\n  }\n\n  if (typeof args === 'undefined') {\n    // eslint-disable-next-line no-param-reassign\n    args = [];\n  }\n  if (!Array.isArray(args)) {\n    throw new Error('invalid arguments');\n  }\n\n  const [version, vlen] = parseUvarint(program);\n  if (vlen <= 0) {\n    throw new Error('version parsing error');\n  }\n  if (version > langspec.EvalMaxVersion) {\n    throw new Error('unsupported version');\n  }\n\n  let cost = 0;\n  let { length } = program;\n  for (const arg of args) {\n    length += arg.length;\n  }\n  if (length > maxLength) {\n    throw new Error('program too long');\n  }\n\n  if (!opcodes) {\n    opcodes = {};\n    for (const op of langspec.Ops) {\n      opcodes[op.Opcode] = op;\n    }\n  }\n\n  let pc = vlen;\n  let ints = [];\n  let byteArrays = [];\n  while (pc < program.length) {\n    const op = opcodes[program[pc]];\n    if (op === undefined) {\n      throw new Error('invalid instruction');\n    }\n\n    cost += op.Cost;\n    let size = op.Size;\n    if (size === 0) {\n      switch (op.Opcode) {\n        case intcblockOpcode: {\n          let foundInts;\n          [size, foundInts] = readIntConstBlock(program, pc);\n          ints = ints.concat(foundInts);\n          break;\n        }\n        case bytecblockOpcode: {\n          let foundByteArrays;\n          [size, foundByteArrays] = readByteConstBlock(program, pc);\n          byteArrays = byteArrays.concat(foundByteArrays);\n          break;\n        }\n        case pushintOpcode: {\n          let foundInt;\n          [size, foundInt] = readPushIntOp(program, pc);\n          ints.push(foundInt);\n          break;\n        }\n        case pushbytesOpcode: {\n          let foundByteArray;\n          [size, foundByteArray] = readPushByteOp(program, pc);\n          byteArrays.push(foundByteArray);\n          break;\n        }\n        default: {\n          throw new Error('invalid instruction');\n        }\n      }\n    }\n    pc += size;\n  }\n\n  if (cost > maxCost) {\n    throw new Error('program too costly to run');\n  }\n\n  return [ints, byteArrays, true];\n}\n\n/**\n * checkProgram validates program for length and running cost\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {boolean} true if success\n */\nfunction checkProgram(program, args) {\n  const [, , success] = readProgram(program, args);\n  return success;\n}\n\nfunction checkIntConstBlock(program, pc) {\n  const [size] = readIntConstBlock(program, pc);\n  return size;\n}\n\nfunction checkByteConstBlock(program, pc) {\n  const [size] = readByteConstBlock(program, pc);\n  return size;\n}\n\nfunction checkPushIntOp(program, pc) {\n  const [size] = readPushIntOp(program, pc);\n  return size;\n}\n\nfunction checkPushByteOp(program, pc) {\n  const [size] = readPushByteOp(program, pc);\n  return size;\n}\n\nmodule.exports = {\n  checkProgram,\n  readProgram,\n  parseUvarint,\n  checkIntConstBlock,\n  checkByteConstBlock,\n  checkPushIntOp,\n  checkPushByteOp,\n  langspecEvalMaxVersion: langspec.EvalMaxVersion,\n  langspecLogicSigVersion: langspec.LogicSigVersion,\n};\n"]},"metadata":{},"sourceType":"script"}