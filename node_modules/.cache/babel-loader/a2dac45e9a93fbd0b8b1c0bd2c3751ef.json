{"ast":null,"code":"const JSONbig = require('json-bigint')({\n  useNativeBigInt: true,\n  strict: true\n});\n/**\n * Parse JSON with additional options.\n * @param {string} str The JSON string to parse.\n * @param {object} options Parsing options.\n * @param {\"default\" | \"safe\" | \"mixed\" | \"bigint\"} options.intDecoding Configure how integers in\n *   this request's JSON response will be decoded.\n *\n *   The options are:\n *   * \"default\": All integers will be decoded as Numbers, meaning any values greater than\n *     Number.MAX_SAFE_INTEGER will lose precision.\n *   * \"safe\": All integers will be decoded as Numbers, but if any values are greater than\n *     Number.MAX_SAFE_INTEGER an error will be thrown.\n *   * \"mixed\": Integers will be decoded as Numbers if they are less than or equal to\n *     Number.MAX_SAFE_INTEGER, otherwise they will be decoded as BigInts.\n *   * \"bigint\": All integers will be decoded as BigInts.\n *\n *   Defaults to \"default\" if not included.\n */\n\n\nfunction parseJSON(str, options = undefined) {\n  const intDecoding = options && options.intDecoding ? options.intDecoding : 'default';\n  const parsed = JSONbig.parse(str, (_, value) => {\n    if (value != null && typeof value === 'object' && Object.getPrototypeOf(value) == null) {\n      // for some reason the Objects returned by JSONbig.parse have a null prototype, so we\n      // need to fix that.\n      Object.setPrototypeOf(value, Object.prototype);\n    }\n\n    if (typeof value === 'bigint') {\n      if (intDecoding === 'bigint' || intDecoding === 'mixed' && value > Number.MAX_SAFE_INTEGER) {\n        return value;\n      } // JSONbig.parse converts number to BigInts if they are >= 10**15. This is smaller than\n      // Number.MAX_SAFE_INTEGER, so we can convert some BigInts back to normal numbers.\n\n\n      if (intDecoding === 'default' || intDecoding === 'mixed') {\n        return Number(value);\n      }\n\n      throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);\n    }\n\n    if (typeof value === 'number') {\n      if (intDecoding === 'bigint' && Number.isInteger(value)) {\n        return BigInt(value);\n      }\n    }\n\n    return value;\n  });\n  return parsed;\n}\n/**\n * ArrayEqual takes two arrays and return true if equal, false otherwise\n * @return {boolean}\n */\n\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return a.every((val, i) => val === b[i]);\n}\n/**\n * ConcatArrays takes two array and returns a joint array of both\n * @param a\n * @param b\n * @returns {Uint8Array} [a,b]\n */\n\n\nfunction concatArrays(a, b) {\n  const c = new Uint8Array(a.length + b.length);\n  c.set(a);\n  c.set(b, a.length);\n  return c;\n}\n\nmodule.exports = {\n  parseJSON,\n  arrayEqual,\n  concatArrays\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/utils/utils.js"],"names":["JSONbig","require","useNativeBigInt","strict","parseJSON","str","options","undefined","intDecoding","parsed","parse","_","value","Object","getPrototypeOf","setPrototypeOf","prototype","Number","MAX_SAFE_INTEGER","Error","toString","isInteger","BigInt","arrayEqual","a","b","length","every","val","i","concatArrays","c","Uint8Array","set","module","exports"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,aAAD,CAAP,CAAuB;AAAEC,EAAAA,eAAe,EAAE,IAAnB;AAAyBC,EAAAA,MAAM,EAAE;AAAjC,CAAvB,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,SAAT,CAAmBC,GAAnB,EAAwBC,OAAO,GAAGC,SAAlC,EAA6C;AAC3C,QAAMC,WAAW,GACfF,OAAO,IAAIA,OAAO,CAACE,WAAnB,GAAiCF,OAAO,CAACE,WAAzC,GAAuD,SADzD;AAEA,QAAMC,MAAM,GAAGT,OAAO,CAACU,KAAR,CAAcL,GAAd,EAAmB,CAACM,CAAD,EAAIC,KAAJ,KAAc;AAC9C,QACEA,KAAK,IAAI,IAAT,IACA,OAAOA,KAAP,KAAiB,QADjB,IAEAC,MAAM,CAACC,cAAP,CAAsBF,KAAtB,KAAgC,IAHlC,EAIE;AACA;AACA;AACAC,MAAAA,MAAM,CAACE,cAAP,CAAsBH,KAAtB,EAA6BC,MAAM,CAACG,SAApC;AACD;;AAED,QAAI,OAAOJ,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UACEJ,WAAW,KAAK,QAAhB,IACCA,WAAW,KAAK,OAAhB,IAA2BI,KAAK,GAAGK,MAAM,CAACC,gBAF7C,EAGE;AACA,eAAON,KAAP;AACD,OAN4B,CAQ7B;AACA;;;AACA,UAAIJ,WAAW,KAAK,SAAhB,IAA6BA,WAAW,KAAK,OAAjD,EAA0D;AACxD,eAAOS,MAAM,CAACL,KAAD,CAAb;AACD;;AAED,YAAM,IAAIO,KAAJ,CACH,yCAAwCP,KAAK,CAACQ,QAAN,EAAiB,oDADtD,CAAN;AAGD;;AAED,QAAI,OAAOR,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAIJ,WAAW,KAAK,QAAhB,IAA4BS,MAAM,CAACI,SAAP,CAAiBT,KAAjB,CAAhC,EAAyD;AACvD,eAAOU,MAAM,CAACV,KAAD,CAAb;AACD;AACF;;AAED,WAAOA,KAAP;AACD,GArCc,CAAf;AAsCA,SAAOH,MAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASc,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0B;AACxB,MAAID,CAAC,CAACE,MAAF,KAAaD,CAAC,CAACC,MAAnB,EAA2B;AACzB,WAAO,KAAP;AACD;;AACD,SAAOF,CAAC,CAACG,KAAF,CAAQ,CAACC,GAAD,EAAMC,CAAN,KAAYD,GAAG,KAAKH,CAAC,CAACI,CAAD,CAA7B,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,CAAsBN,CAAtB,EAAyBC,CAAzB,EAA4B;AAC1B,QAAMM,CAAC,GAAG,IAAIC,UAAJ,CAAeR,CAAC,CAACE,MAAF,GAAWD,CAAC,CAACC,MAA5B,CAAV;AACAK,EAAAA,CAAC,CAACE,GAAF,CAAMT,CAAN;AACAO,EAAAA,CAAC,CAACE,GAAF,CAAMR,CAAN,EAASD,CAAC,CAACE,MAAX;AACA,SAAOK,CAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiB;AACf/B,EAAAA,SADe;AAEfmB,EAAAA,UAFe;AAGfO,EAAAA;AAHe,CAAjB","sourcesContent":["const JSONbig = require('json-bigint')({ useNativeBigInt: true, strict: true });\n\n/**\n * Parse JSON with additional options.\n * @param {string} str The JSON string to parse.\n * @param {object} options Parsing options.\n * @param {\"default\" | \"safe\" | \"mixed\" | \"bigint\"} options.intDecoding Configure how integers in\n *   this request's JSON response will be decoded.\n *\n *   The options are:\n *   * \"default\": All integers will be decoded as Numbers, meaning any values greater than\n *     Number.MAX_SAFE_INTEGER will lose precision.\n *   * \"safe\": All integers will be decoded as Numbers, but if any values are greater than\n *     Number.MAX_SAFE_INTEGER an error will be thrown.\n *   * \"mixed\": Integers will be decoded as Numbers if they are less than or equal to\n *     Number.MAX_SAFE_INTEGER, otherwise they will be decoded as BigInts.\n *   * \"bigint\": All integers will be decoded as BigInts.\n *\n *   Defaults to \"default\" if not included.\n */\nfunction parseJSON(str, options = undefined) {\n  const intDecoding =\n    options && options.intDecoding ? options.intDecoding : 'default';\n  const parsed = JSONbig.parse(str, (_, value) => {\n    if (\n      value != null &&\n      typeof value === 'object' &&\n      Object.getPrototypeOf(value) == null\n    ) {\n      // for some reason the Objects returned by JSONbig.parse have a null prototype, so we\n      // need to fix that.\n      Object.setPrototypeOf(value, Object.prototype);\n    }\n\n    if (typeof value === 'bigint') {\n      if (\n        intDecoding === 'bigint' ||\n        (intDecoding === 'mixed' && value > Number.MAX_SAFE_INTEGER)\n      ) {\n        return value;\n      }\n\n      // JSONbig.parse converts number to BigInts if they are >= 10**15. This is smaller than\n      // Number.MAX_SAFE_INTEGER, so we can convert some BigInts back to normal numbers.\n      if (intDecoding === 'default' || intDecoding === 'mixed') {\n        return Number(value);\n      }\n\n      throw new Error(\n        `Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`\n      );\n    }\n\n    if (typeof value === 'number') {\n      if (intDecoding === 'bigint' && Number.isInteger(value)) {\n        return BigInt(value);\n      }\n    }\n\n    return value;\n  });\n  return parsed;\n}\n\n/**\n * ArrayEqual takes two arrays and return true if equal, false otherwise\n * @return {boolean}\n */\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  return a.every((val, i) => val === b[i]);\n}\n\n/**\n * ConcatArrays takes two array and returns a joint array of both\n * @param a\n * @param b\n * @returns {Uint8Array} [a,b]\n */\nfunction concatArrays(a, b) {\n  const c = new Uint8Array(a.length + b.length);\n  c.set(a);\n  c.set(b, a.length);\n  return c;\n}\n\nmodule.exports = {\n  parseJSON,\n  arrayEqual,\n  concatArrays,\n};\n"]},"metadata":{},"sourceType":"script"}