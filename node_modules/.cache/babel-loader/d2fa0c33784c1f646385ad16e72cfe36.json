{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nconst makeTxn = require('../makeTxn');\n\nconst group = require('../group');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst templates = require('./templates');\n\nconst utils = require('../utils/utils');\n\nclass LimitOrder {\n  /**\n   * MakeLimitOrder allows a user to exchange some number of assets for some number of algos.\n   * Fund the contract with some number of Algos to limit the maximum number of\n   * Algos you're willing to trade for some other asset.\n   *\n   * Works on two cases:\n   * * trading Algos for some other asset\n   * * closing out Algos back to the originator after a timeout\n   *\n   * trade case, a 2 transaction group:\n   * gtxn[0] (this txn) Algos from Me to Other\n   * gtxn[1] asset from Other to Me\n   *\n   * We want to get _at least_ some amount of the other asset per our Algos\n   * gtxn[1].AssetAmount / gtxn[0].Amount >= N / D\n   * ===\n   * gtxn[1].AssetAmount * D >= gtxn[0].Amount * N\n   *\n   * close-out case:\n   * txn alone, close out value after timeout\n   * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {int} assetid: the ID of the transferred asset\n   * @param {int} ratn: exchange rate (N asset per D Algos, or better)\n   * @param {int} ratd: exchange rate (N asset per D Algos, or better)\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minTrade: the minimum amount (of Algos) to be traded away\n   * @param {int} maxFee: maximum fee used by the limit order transaction\n   * @returns {LimitOrder}\n   */\n  constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {\n    // don't need to validate owner - it will be validated by template.insert\n    if (!Number.isSafeInteger(assetid) || assetid < 0) throw Error('assetid must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(ratn) || ratn < 0) throw Error('ratn must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(ratd) || ratd < 0) throw Error('ratd must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error('expiryRound must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(minTrade) || minTrade < 0) throw Error('minTrade must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error('maxFee must be a positive number and smaller than 2^53-1');\n    const referenceProgramB64 = 'ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [5\n    /* minTrade */\n    , 7\n    /* assetID */\n    , 9\n    /* ratd */\n    , 10\n    /* ratn */\n    , 11\n    /* expiryRound */\n    , 12\n    /* owner */\n    , 16];\n    const injectionVector = [maxFee, minTrade, assetid, ratd, ratn, expiryRound, owner];\n    const injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS];\n    const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    const lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n    this.owner = owner;\n    this.assetid = assetid;\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: byteform of the contract from the payer\n * @param {int} assetAmount: the amount of assets to be sent\n * @param {int} microAlgoAmount: number of microAlgos to transfer\n * @param {Uint8Array} secretKey: secret key for signing transaction\n * @param {int} fee: the fee per byte to pay in microAlgos\n * @param {int} firstRound: the first round on which these txns will be valid\n * @param {int} lastRound: the last round on which these txns will be valid\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n * the first payment sends money (Algos) from contract to the recipient (we'll call him Buyer), closing the rest of the account to Owner\n * the second payment sends money (the asset) from Buyer to the Owner\n * these transactions will be rejected if they do not meet the restrictions set by the contract\n * @throws error if arguments fail contract validation\n */\n\n\nfunction getSwapAssetsTransaction(contract, assetAmount, microAlgoAmount, secretKey, fee, firstRound, lastRound, genesisHash) {\n  const buyerKeyPair = nacl.keyPairFromSecretKey(secretKey);\n  const buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n  let noCloseRemainder;\n  let noAssetRevocationTarget;\n  const contractAssetID = ints[6];\n  const contractOwner = address.encodeAddress(byteArrays[0]);\n  const lsig = logicSig.makeLogicSig(contract, undefined);\n  const contractAddress = lsig.address();\n  const algosForAssets = makeTxn.makePaymentTxn(contractAddress, buyerAddr, fee, microAlgoAmount, noCloseRemainder, firstRound, lastRound, undefined, genesisHash, undefined);\n  const assetsForAlgos = makeTxn.makeAssetTransferTxn(buyerAddr, contractOwner, noCloseRemainder, noAssetRevocationTarget, fee, assetAmount, firstRound, lastRound, undefined, genesisHash, undefined, contractAssetID);\n  const txns = [algosForAssets, assetsForAlgos];\n  const txGroup = group.assignGroupID(txns);\n  const ratd = ints[7];\n  const ratn = ints[8];\n\n  if (assetAmount * ratd < microAlgoAmount * ratn) {\n    throw new Error(`bad payment ratio, ${assetAmount.toString()}*${ratd.toString()} !>= ${microAlgoAmount.toString()}*${ratn.toString()}`);\n  }\n\n  const minTrade = ints[4];\n\n  if (microAlgoAmount < minTrade) {\n    throw new Error(`payment amount ${microAlgoAmount.toString()} less than minimum trade ${minTrade.toString()}`);\n  }\n\n  const maxFee = ints[2];\n\n  if (txGroup[0].fee > maxFee) {\n    throw new Error(`final fee of payment transaction ${txGroup[0].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);\n  }\n\n  if (txGroup[1].fee > maxFee) {\n    throw new Error(`final fee of asset transaction ${txGroup[1].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);\n  }\n\n  const algosForAssetsSigned = logicSig.signLogicSigTransactionObject(txGroup[0], lsig);\n  const assetsForAlgosSigned = txGroup[1].signTxn(secretKey);\n  return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);\n}\n\nmodule.exports = {\n  LimitOrder,\n  getSwapAssetsTransaction\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/logicTemplates/limitorder.js"],"names":["Buffer","require","address","makeTxn","group","logic","logicSig","nacl","templates","utils","LimitOrder","constructor","owner","assetid","ratn","ratd","expiryRound","minTrade","maxFee","Number","isSafeInteger","Error","referenceProgramB64","referenceProgramBytes","from","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","injectedBytes","inject","programBytes","lsig","LogicSig","undefined","getProgram","getAddress","getSwapAssetsTransaction","contract","assetAmount","microAlgoAmount","secretKey","fee","firstRound","lastRound","genesisHash","buyerKeyPair","keyPairFromSecretKey","buyerAddr","encodeAddress","publicKey","programOutputs","readProgram","ints","byteArrays","noCloseRemainder","noAssetRevocationTarget","contractAssetID","contractOwner","makeLogicSig","contractAddress","algosForAssets","makePaymentTxn","assetsForAlgos","makeAssetTransferTxn","txns","txGroup","assignGroupID","toString","algosForAssetsSigned","signLogicSigTransactionObject","assetsForAlgosSigned","signTxn","concatArrays","blob","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require('../encoding/address');\nconst makeTxn = require('../makeTxn');\nconst group = require('../group');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst nacl = require('../nacl/naclWrappers');\nconst templates = require('./templates');\nconst utils = require('../utils/utils');\n\nclass LimitOrder {\n  /**\n   * MakeLimitOrder allows a user to exchange some number of assets for some number of algos.\n   * Fund the contract with some number of Algos to limit the maximum number of\n   * Algos you're willing to trade for some other asset.\n   *\n   * Works on two cases:\n   * * trading Algos for some other asset\n   * * closing out Algos back to the originator after a timeout\n   *\n   * trade case, a 2 transaction group:\n   * gtxn[0] (this txn) Algos from Me to Other\n   * gtxn[1] asset from Other to Me\n   *\n   * We want to get _at least_ some amount of the other asset per our Algos\n   * gtxn[1].AssetAmount / gtxn[0].Amount >= N / D\n   * ===\n   * gtxn[1].AssetAmount * D >= gtxn[0].Amount * N\n   *\n   * close-out case:\n   * txn alone, close out value after timeout\n   * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {int} assetid: the ID of the transferred asset\n   * @param {int} ratn: exchange rate (N asset per D Algos, or better)\n   * @param {int} ratd: exchange rate (N asset per D Algos, or better)\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minTrade: the minimum amount (of Algos) to be traded away\n   * @param {int} maxFee: maximum fee used by the limit order transaction\n   * @returns {LimitOrder}\n   */\n  constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {\n    // don't need to validate owner - it will be validated by template.insert\n    if (!Number.isSafeInteger(assetid) || assetid < 0)\n      throw Error('assetid must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(ratn) || ratn < 0)\n      throw Error('ratn must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(ratd) || ratd < 0)\n      throw Error('ratd must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)\n      throw Error(\n        'expiryRound must be a positive number and smaller than 2^53-1'\n      );\n    if (!Number.isSafeInteger(minTrade) || minTrade < 0)\n      throw Error('minTrade must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0)\n      throw Error('maxFee must be a positive number and smaller than 2^53-1');\n\n    const referenceProgramB64 =\n      'ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [\n      5 /* minTrade */,\n      7 /* assetID */,\n      9 /* ratd */,\n      10 /* ratn */,\n      11 /* expiryRound */,\n      12 /* owner */,\n      16,\n    ];\n    const injectionVector = [\n      maxFee,\n      minTrade,\n      assetid,\n      ratd,\n      ratn,\n      expiryRound,\n      owner,\n    ];\n    const injectionTypes = [\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.ADDRESS,\n    ];\n    const injectedBytes = templates.inject(\n      referenceProgramBytes,\n      referenceOffsets,\n      injectionVector,\n      injectionTypes\n    );\n    this.programBytes = injectedBytes;\n    const lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n    this.owner = owner;\n    this.assetid = assetid;\n  }\n\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n  getProgram() {\n    return this.programBytes;\n  }\n\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n  getAddress() {\n    return this.address;\n  }\n}\n\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: byteform of the contract from the payer\n * @param {int} assetAmount: the amount of assets to be sent\n * @param {int} microAlgoAmount: number of microAlgos to transfer\n * @param {Uint8Array} secretKey: secret key for signing transaction\n * @param {int} fee: the fee per byte to pay in microAlgos\n * @param {int} firstRound: the first round on which these txns will be valid\n * @param {int} lastRound: the last round on which these txns will be valid\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n * the first payment sends money (Algos) from contract to the recipient (we'll call him Buyer), closing the rest of the account to Owner\n * the second payment sends money (the asset) from Buyer to the Owner\n * these transactions will be rejected if they do not meet the restrictions set by the contract\n * @throws error if arguments fail contract validation\n */\nfunction getSwapAssetsTransaction(\n  contract,\n  assetAmount,\n  microAlgoAmount,\n  secretKey,\n  fee,\n  firstRound,\n  lastRound,\n  genesisHash\n) {\n  const buyerKeyPair = nacl.keyPairFromSecretKey(secretKey);\n  const buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n\n  let noCloseRemainder;\n  let noAssetRevocationTarget;\n  const contractAssetID = ints[6];\n  const contractOwner = address.encodeAddress(byteArrays[0]);\n  const lsig = logicSig.makeLogicSig(contract, undefined);\n  const contractAddress = lsig.address();\n  const algosForAssets = makeTxn.makePaymentTxn(\n    contractAddress,\n    buyerAddr,\n    fee,\n    microAlgoAmount,\n    noCloseRemainder,\n    firstRound,\n    lastRound,\n    undefined,\n    genesisHash,\n    undefined\n  );\n  const assetsForAlgos = makeTxn.makeAssetTransferTxn(\n    buyerAddr,\n    contractOwner,\n    noCloseRemainder,\n    noAssetRevocationTarget,\n    fee,\n    assetAmount,\n    firstRound,\n    lastRound,\n    undefined,\n    genesisHash,\n    undefined,\n    contractAssetID\n  );\n  const txns = [algosForAssets, assetsForAlgos];\n  const txGroup = group.assignGroupID(txns);\n\n  const ratd = ints[7];\n  const ratn = ints[8];\n  if (assetAmount * ratd < microAlgoAmount * ratn) {\n    throw new Error(\n      `bad payment ratio, ${assetAmount.toString()}*${ratd.toString()} !>= ${microAlgoAmount.toString()}*${ratn.toString()}`\n    );\n  }\n  const minTrade = ints[4];\n  if (microAlgoAmount < minTrade) {\n    throw new Error(\n      `payment amount ${microAlgoAmount.toString()} less than minimum trade ${minTrade.toString()}`\n    );\n  }\n  const maxFee = ints[2];\n  if (txGroup[0].fee > maxFee) {\n    throw new Error(\n      `final fee of payment transaction ${txGroup[0].fee.toString()} greater than transaction max fee ${maxFee.toString()}`\n    );\n  }\n  if (txGroup[1].fee > maxFee) {\n    throw new Error(\n      `final fee of asset transaction ${txGroup[1].fee.toString()} greater than transaction max fee ${maxFee.toString()}`\n    );\n  }\n\n  const algosForAssetsSigned = logicSig.signLogicSigTransactionObject(\n    txGroup[0],\n    lsig\n  );\n  const assetsForAlgosSigned = txGroup[1].signTxn(secretKey);\n  return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);\n}\n\nmodule.exports = {\n  LimitOrder,\n  getSwapAssetsTransaction,\n};\n"]},"metadata":{},"sourceType":"script"}