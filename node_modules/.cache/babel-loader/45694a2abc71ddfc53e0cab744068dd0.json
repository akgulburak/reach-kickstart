{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst address = require('./encoding/address');\n\nconst encoding = require('./encoding/encoding');\n\nconst txnBuilder = require('./transaction');\n\nconst utils = require('./utils/utils');\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\n\nconst MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';\nconst MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nconst MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';\nconst MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_BAD_FROM_FIELD_ERROR_MSG = 'The transaction from field and multisig preimage do not match.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nconst MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nconst MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\n/**\n * createMultisigTransaction creates a multisig transaction blob.\n * @param txnForEncoding the actual transaction to sign.\n * @param rawSig a Buffer raw signature of that transaction\n * @param myPk a public key that corresponds with rawSig\n * @param version multisig version\n * @param threshold mutlisig threshold\n * @param pks ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\n\nfunction createMultisigTransaction(txnForEncoding, {\n  rawSig,\n  myPk\n}, {\n  version,\n  threshold,\n  pks\n}) {\n  let keyExist = false; // construct the appendable multisigned transaction format\n\n  const subsigs = pks.map(pk => {\n    if (nacl.bytesEqual(pk, myPk)) {\n      keyExist = true;\n      return {\n        pk: Buffer.from(pk),\n        s: rawSig\n      };\n    }\n\n    return {\n      pk: Buffer.from(pk)\n    };\n  });\n\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n\n  const msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs\n  };\n  const sTxn = {\n    msig,\n    txn: txnForEncoding\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\n\n\nclass MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n\n\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  /**\n   * Override inherited method to throw an error, as traditional signing is not allowed\n   */\n\n\n  signTxn() {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version multisig version\n   * @param threshold multisig threshold\n   * @param pks multisig public key list, order is important.\n   * @param sk an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n\n\n  partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk) {\n    const expectedFromRaw = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    });\n\n    if (address.encodeAddress(this.from.publicKey) !== address.encodeAddress(expectedFromRaw)) {\n      throw new Error(MULTISIG_BAD_FROM_FIELD_ERROR_MSG);\n    } // get signature verifier\n\n\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransaction(this.get_obj_for_encoding(), {\n      rawSig: this.rawSignTxn(sk),\n      myPk\n    }, {\n      version,\n      threshold,\n      pks\n    });\n  }\n\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\n\n\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refSigAlgoTx = MultisigTransaction.from_obj_for_encoding(refSigTx.txn);\n  const refTxIDStr = refSigAlgoTx.txID().toString();\n  const from = address.encodeAddress(refSigTx.txn.snd);\n  let newSubsigs = refSigTx.msig.subsig;\n\n  for (let i = 0; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(multisigTxnBlobs[i]);\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n\n    if (unisigAlgoTxn.txID().toString() !== refTxIDStr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    } // check multisig has same preimage as reference\n\n\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n\n    const preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map(subsig => subsig.pk)\n    };\n\n    if (from !== address.encodeAddress(address.fromMultisigPreImg(preimg))) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    } // now, we can merge\n\n\n    newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {\n      const current = refSigTx.msig.subsig[index];\n\n      if (current.s) {\n        // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n        // of Dec 2020) React overrides the buffer package with an older version that does\n        // not support Uint8Arrays in the comparison function. See this thread for more\n        // info: https://github.com/algorand/js-algorand-sdk/issues/252\n        if (uniSubsig.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {\n          // mismatch\n          throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n        }\n\n        return {\n          pk: current.pk,\n          s: current.s\n        };\n      }\n\n      if (uniSubsig.s) {\n        return {\n          pk: current.pk,\n          s: uniSubsig.s\n        };\n      }\n\n      return current;\n    });\n  }\n\n  const msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs\n  };\n  const sTxn = {\n    msig,\n    txn: refSigTx.txn\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n\nfunction verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n  const pks = subsigs.map(subsig => subsig.pk);\n\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n\n  let pk;\n\n  try {\n    pk = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    });\n  } catch (e) {\n    return false;\n  }\n\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n\n  let counter = 0;\n\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n\n  if (counter < threshold) {\n    return false;\n  }\n\n  let verifiedCounter = 0;\n\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = {\n  MultisigTransaction,\n  mergeMultisigTransactions,\n  createMultisigTransaction,\n  verifyMultisig,\n  MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG,\n  MULTISIG_MERGE_MISMATCH_ERROR_MSG,\n  MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG,\n  MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG,\n  MULTISIG_NO_MUTATE_ERROR_MSG,\n  MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/algosdk/src/multisig.js"],"names":["Buffer","require","nacl","address","encoding","txnBuilder","utils","MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG","MULTISIG_MERGE_MISMATCH_ERROR_MSG","MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG","MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG","MULTISIG_BAD_FROM_FIELD_ERROR_MSG","MULTISIG_KEY_NOT_EXIST_ERROR_MSG","MULTISIG_NO_MUTATE_ERROR_MSG","MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG","createMultisigTransaction","txnForEncoding","rawSig","myPk","version","threshold","pks","keyExist","subsigs","map","pk","bytesEqual","from","s","Error","msig","v","thr","subsig","sTxn","txn","Uint8Array","encode","MultisigTransaction","Transaction","addLease","addRekey","signTxn","partialSignTxn","sk","expectedFromRaw","fromMultisigPreImg","encodeAddress","publicKey","keyPairFromSecretKey","get_obj_for_encoding","rawSignTxn","mergeMultisigTransactions","multisigTxnBlobs","length","refSigTx","decode","refSigAlgoTx","from_obj_for_encoding","refTxIDStr","txID","toString","snd","newSubsigs","i","unisig","unisigAlgoTxn","preimg","uniSubsig","index","current","compare","verifyMultisig","toBeVerified","e","arrayEqual","counter","undefined","verifiedCounter","verify","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst nacl = require('./nacl/naclWrappers');\nconst address = require('./encoding/address');\nconst encoding = require('./encoding/encoding');\nconst txnBuilder = require('./transaction');\nconst utils = require('./utils/utils');\n\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\nconst MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG =\n  'Not enough multisig transactions to merge. Need at least two';\nconst MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nconst MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG =\n  'Cannot merge txs. Multisig preimages differ';\nconst MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_BAD_FROM_FIELD_ERROR_MSG =\n  'The transaction from field and multisig preimage do not match.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nconst MULTISIG_NO_MUTATE_ERROR_MSG =\n  'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nconst MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG =\n  'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\n\n/**\n * createMultisigTransaction creates a multisig transaction blob.\n * @param txnForEncoding the actual transaction to sign.\n * @param rawSig a Buffer raw signature of that transaction\n * @param myPk a public key that corresponds with rawSig\n * @param version multisig version\n * @param threshold mutlisig threshold\n * @param pks ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransaction(\n  txnForEncoding,\n  { rawSig, myPk },\n  { version, threshold, pks }\n) {\n  let keyExist = false;\n  // construct the appendable multisigned transaction format\n  const subsigs = pks.map((pk) => {\n    if (nacl.bytesEqual(pk, myPk)) {\n      keyExist = true;\n      return {\n        pk: Buffer.from(pk),\n        s: rawSig,\n      };\n    }\n    return { pk: Buffer.from(pk) };\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n  const msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs,\n  };\n  const sTxn = {\n    msig,\n    txn: txnForEncoding,\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nclass MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this */\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as traditional signing is not allowed\n   */\n  signTxn() {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version multisig version\n   * @param threshold multisig threshold\n   * @param pks multisig public key list, order is important.\n   * @param sk an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignTxn({ version, threshold, pks }, sk) {\n    const expectedFromRaw = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks,\n    });\n    if (\n      address.encodeAddress(this.from.publicKey) !==\n      address.encodeAddress(expectedFromRaw)\n    ) {\n      throw new Error(MULTISIG_BAD_FROM_FIELD_ERROR_MSG);\n    }\n\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransaction(\n      this.get_obj_for_encoding(),\n      { rawSig: this.rawSignTxn(sk), myPk },\n      { version, threshold, pks }\n    );\n  }\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refSigAlgoTx = MultisigTransaction.from_obj_for_encoding(refSigTx.txn);\n  const refTxIDStr = refSigAlgoTx.txID().toString();\n  const from = address.encodeAddress(refSigTx.txn.snd);\n\n  let newSubsigs = refSigTx.msig.subsig;\n  for (let i = 0; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(multisigTxnBlobs[i]);\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID().toString() !== refTxIDStr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map((subsig) => subsig.pk),\n    };\n    if (from !== address.encodeAddress(address.fromMultisigPreImg(preimg))) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    // now, we can merge\n    newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {\n      const current = refSigTx.msig.subsig[index];\n      if (current.s) {\n        // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n        // of Dec 2020) React overrides the buffer package with an older version that does\n        // not support Uint8Arrays in the comparison function. See this thread for more\n        // info: https://github.com/algorand/js-algorand-sdk/issues/252\n        if (\n          uniSubsig.s &&\n          Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0\n        ) {\n          // mismatch\n          throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n        }\n        return {\n          pk: current.pk,\n          s: current.s,\n        };\n      }\n      if (uniSubsig.s) {\n        return {\n          pk: current.pk,\n          s: uniSubsig.s,\n        };\n      }\n      return current;\n    });\n  }\n  const msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs,\n  };\n  const sTxn = {\n    msig,\n    txn: refSigTx.txn,\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n\nfunction verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n\n  const pks = subsigs.map((subsig) => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n\n  let pk;\n  try {\n    pk = address.fromMultisigPreImg({ version, threshold, pks });\n  } catch (e) {\n    return false;\n  }\n\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = {\n  MultisigTransaction,\n  mergeMultisigTransactions,\n  createMultisigTransaction,\n  verifyMultisig,\n  MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG,\n  MULTISIG_MERGE_MISMATCH_ERROR_MSG,\n  MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG,\n  MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG,\n  MULTISIG_NO_MUTATE_ERROR_MSG,\n  MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG,\n};\n"]},"metadata":{},"sourceType":"script"}