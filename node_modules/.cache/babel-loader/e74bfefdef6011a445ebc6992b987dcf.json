{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst client = require('./client');\n\nconst {\n  setSendTransactionHeaders\n} = require('./v2/algod/sendRawTransaction');\n\nfunction Algod(token = '', baseServer = 'http://r2.algorand.network', port = 4180, headers = {}) {\n  // workaround to allow backwards compatibility for multiple headers\n  let tokenHeader = token;\n\n  if (typeof tokenHeader === 'string') {\n    tokenHeader = {\n      'X-Algo-API-Token': tokenHeader\n    };\n  } // Get client\n\n\n  const c = new client.HTTPClient(tokenHeader, baseServer, port, headers);\n  /**\n   * Takes an object and convert its note field to Buffer, if exist.\n   * @param o\n   * @returns {*}\n   */\n\n  function noteb64ToNote(o) {\n    if (!(o.noteb64 === undefined || o.noteb64 === null)) {\n      // eslint-disable-next-line no-param-reassign\n      o.note = Buffer.from(o.noteb64, 'base64');\n    }\n\n    return o;\n  }\n  /**\n   * status retrieves the StatusResponse from the running node\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.status = async (headerObj = {}) => {\n    const res = await c.get('/v1/status', {}, headerObj);\n    return res.body;\n  };\n  /**\n   * healthCheck returns an empty object iff the node is running\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.healthCheck = async (headerObj = {}) => {\n    const res = await c.get('/health', {}, headerObj);\n\n    if (!res.ok) {\n      throw new Error(`Health response: ${res.status}`);\n    }\n\n    return {};\n  };\n  /**\n   * statusAfterBlock waits for round roundNumber to occur then returns the StatusResponse for this round.\n   * This call blocks\n   * @param roundNumber\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.statusAfterBlock = async (roundNumber, headerObj = {}) => {\n    if (!Number.isInteger(roundNumber)) throw Error('roundNumber should be an integer');\n    const res = await c.get(`/v1/status/wait-for-block-after/${roundNumber}`, {}, headerObj);\n    return res.body;\n  };\n  /**\n   * pendingTransactions asks algod for a snapshot of current pending txns on the node, bounded by maxTxns.\n   * If maxTxns = 0, fetches as many transactions as possible.\n   * @param maxTxns number\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactions = async (maxTxns, headerObj = {}) => {\n    if (!Number.isInteger(maxTxns)) throw Error('maxTxns should be an integer');\n    const res = await c.get('/v1/transactions/pending', {\n      max: maxTxns\n    }, headerObj);\n\n    if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== undefined) {\n      for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {\n        res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * versions retrieves the VersionResponse from the running node\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.versions = async (headerObj = {}) => {\n    const res = await c.get('/versions', {}, headerObj);\n    return res.body;\n  };\n  /**\n   * LedgerSupply gets the supply details for the specified node's Ledger\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.ledgerSupply = async (headerObj = {}) => {\n    const res = await c.get('/v1/ledger/supply', {}, headerObj);\n    return res.body;\n  };\n  /**\n   * transactionsByAddress returns all transactions for a PK [addr] in the [first, last] rounds range.\n   * @param addr string\n   * @param first number, optional\n   * @param last number, optional\n   * @param maxTxns number, optional\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionByAddress = async (addr, first = null, last = null, maxTxns = null, headerObj = {}) => {\n    if (first !== null && !Number.isInteger(first)) {\n      throw Error('first round should be an integer');\n    }\n\n    if (last !== null && !Number.isInteger(last)) {\n      throw Error('last round should be an integer');\n    }\n\n    const res = await c.get(`/v1/account/${addr}/transactions`, {\n      firstRound: first,\n      lastRound: last,\n      max: maxTxns\n    }, headerObj);\n\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionsByAddressAndDate returns all transactions for a PK [addr] in the [fromDate, toDate] date range.\n   * The date is a string in the YYYY-MM-DD format.\n   * @param addr string\n   * @param fromDate string\n   * @param toDate string\n   * @param maxTxns number, optional\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionByAddressAndDate = async (addr, fromDate, toDate, maxTxns = null, headerObj = {}) => {\n    const res = await c.get(`/v1/account/${addr}/transactions`, {\n      fromDate,\n      toDate,\n      max: maxTxns\n    }, headerObj);\n\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionById returns the a transaction information of a specific txid [txId]\n   * Note - This method is allowed only when Indexer is enabled.\n   * @param txid\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionById = async (txid, headerObj = {}) => {\n    const res = await c.get(`/v1/transaction/${txid}`, {}, headerObj);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionInformation returns the transaction information of a specific txid and an address\n   * @param addr\n   * @param txid\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionInformation = async (addr, txid, headerObj = {}) => {\n    const res = await c.get(`/v1/account/${addr}/transaction/${txid}`, {}, headerObj);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * pendingTransactionInformation returns the transaction information for a specific txid of a pending transaction\n   * @param txid\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactionInformation = async (txid, headerObj = {}) => {\n    const res = await c.get(`/v1/transactions/pending/${txid}`, {}, headerObj);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * accountInformation returns the passed account's information\n   * @param addr string\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.accountInformation = async (addr, headerObj = {}) => {\n    const res = await c.get(`/v1/account/${addr}`, {}, headerObj);\n    return res.body;\n  };\n  /**\n   * assetInformation returns the information for the asset with the passed creator and index\n   * @param index number\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.assetInformation = async (index, headerObj = {}) => {\n    const res = await c.get(`/v1/asset/${index}`, {}, headerObj);\n    return res.body;\n  };\n  /**\n   * suggestedFee gets the recommended transaction fee from the node\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.suggestedFee = async (headerObj = {}) => {\n    const res = await c.get('/v1/transactions/fee', {}, headerObj);\n    return res.body;\n  };\n  /**\n   * sendRawTransaction gets an encoded SignedTxn and broadcasts it to the network\n   * @param txn Uin8Array\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.sendRawTransaction = async (txn, headerObj = {}) => {\n    const txHeaders = setSendTransactionHeaders(headerObj);\n    const res = await c.post('/v1/transactions', Buffer.from(txn), txHeaders);\n    return res.body;\n  };\n  /**\n   * sendRawTransactions gets a list of encoded SignedTxns and broadcasts it to the network\n   * @param txn Array of Uin8Array\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.sendRawTransactions = async (txns, headerObj = {}) => {\n    const txHeaders = setSendTransactionHeaders(headerObj);\n    const merged = Array.prototype.concat(...txns.map(arr => Array.from(arr)));\n    const res = await c.post('/v1/transactions', Buffer.from(merged), txHeaders);\n    return res.body;\n  };\n  /**\n   * getTransactionParams returns to common needed parameters for a new transaction\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.getTransactionParams = async (headerObj = {}) => {\n    const res = await c.get('/v1/transactions/params', {}, headerObj);\n    return res.body;\n  };\n  /**\n   * suggestParams returns to common needed parameters for a new transaction, in a format the transaction builder expects\n   * @param headerObj, optional\n   * @returns {Object}\n   */\n\n\n  this.suggestParams = async (headerObj = {}) => {\n    const result = await this.getTransactionParams(headerObj);\n    return {\n      flatFee: false,\n      fee: result.fee,\n      firstRound: result.lastRound,\n      lastRound: result.lastRound + 1000,\n      genesisID: result.genesisID,\n      genesisHash: result.genesishashb64\n    };\n  };\n  /**\n   * block gets the block info for the given round This call blocks\n   * @param roundNumber\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.block = async (roundNumber, headerObj = {}) => {\n    if (!Number.isInteger(roundNumber)) throw Error('roundNumber should be an integer');\n    const res = await c.get(`/v1/block/${roundNumber}`, {}, headerObj);\n\n    if (res.statusCode === 200 && res.body.txns.transactions !== undefined) {\n      for (let i = 0; i < res.body.txns.transactions.length; i++) {\n        res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n}\n\nmodule.exports = {\n  Algod\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/client/algod.js"],"names":["Buffer","require","client","setSendTransactionHeaders","Algod","token","baseServer","port","headers","tokenHeader","c","HTTPClient","noteb64ToNote","o","noteb64","undefined","note","from","status","headerObj","res","get","body","healthCheck","ok","Error","statusAfterBlock","roundNumber","Number","isInteger","pendingTransactions","maxTxns","max","statusCode","truncatedTxns","transactions","i","length","versions","ledgerSupply","transactionByAddress","addr","first","last","firstRound","lastRound","transactionByAddressAndDate","fromDate","toDate","transactionById","txid","transactionInformation","pendingTransactionInformation","accountInformation","assetInformation","index","suggestedFee","sendRawTransaction","txn","txHeaders","post","sendRawTransactions","txns","merged","Array","prototype","concat","map","arr","getTransactionParams","suggestParams","result","flatFee","fee","genesisID","genesisHash","genesishashb64","block","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst client = require('./client');\nconst { setSendTransactionHeaders } = require('./v2/algod/sendRawTransaction');\n\nfunction Algod(\n  token = '',\n  baseServer = 'http://r2.algorand.network',\n  port = 4180,\n  headers = {}\n) {\n  // workaround to allow backwards compatibility for multiple headers\n  let tokenHeader = token;\n  if (typeof tokenHeader === 'string') {\n    tokenHeader = { 'X-Algo-API-Token': tokenHeader };\n  }\n\n  // Get client\n  const c = new client.HTTPClient(tokenHeader, baseServer, port, headers);\n\n  /**\n   * Takes an object and convert its note field to Buffer, if exist.\n   * @param o\n   * @returns {*}\n   */\n  function noteb64ToNote(o) {\n    if (!(o.noteb64 === undefined || o.noteb64 === null)) {\n      // eslint-disable-next-line no-param-reassign\n      o.note = Buffer.from(o.noteb64, 'base64');\n    }\n    return o;\n  }\n\n  /**\n   * status retrieves the StatusResponse from the running node\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.status = async (headerObj = {}) => {\n    const res = await c.get('/v1/status', {}, headerObj);\n    return res.body;\n  };\n\n  /**\n   * healthCheck returns an empty object iff the node is running\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.healthCheck = async (headerObj = {}) => {\n    const res = await c.get('/health', {}, headerObj);\n    if (!res.ok) {\n      throw new Error(`Health response: ${res.status}`);\n    }\n    return {};\n  };\n\n  /**\n   * statusAfterBlock waits for round roundNumber to occur then returns the StatusResponse for this round.\n   * This call blocks\n   * @param roundNumber\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.statusAfterBlock = async (roundNumber, headerObj = {}) => {\n    if (!Number.isInteger(roundNumber))\n      throw Error('roundNumber should be an integer');\n    const res = await c.get(\n      `/v1/status/wait-for-block-after/${roundNumber}`,\n      {},\n      headerObj\n    );\n    return res.body;\n  };\n\n  /**\n   * pendingTransactions asks algod for a snapshot of current pending txns on the node, bounded by maxTxns.\n   * If maxTxns = 0, fetches as many transactions as possible.\n   * @param maxTxns number\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.pendingTransactions = async (maxTxns, headerObj = {}) => {\n    if (!Number.isInteger(maxTxns)) throw Error('maxTxns should be an integer');\n    const res = await c.get(\n      '/v1/transactions/pending',\n      { max: maxTxns },\n      headerObj\n    );\n    if (\n      res.statusCode === 200 &&\n      res.body.truncatedTxns.transactions !== undefined\n    ) {\n      for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {\n        res.body.truncatedTxns.transactions[i] = noteb64ToNote(\n          res.body.truncatedTxns.transactions[i]\n        );\n      }\n    }\n    return res.body;\n  };\n\n  /**\n   * versions retrieves the VersionResponse from the running node\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.versions = async (headerObj = {}) => {\n    const res = await c.get('/versions', {}, headerObj);\n    return res.body;\n  };\n\n  /**\n   * LedgerSupply gets the supply details for the specified node's Ledger\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.ledgerSupply = async (headerObj = {}) => {\n    const res = await c.get('/v1/ledger/supply', {}, headerObj);\n    return res.body;\n  };\n\n  /**\n   * transactionsByAddress returns all transactions for a PK [addr] in the [first, last] rounds range.\n   * @param addr string\n   * @param first number, optional\n   * @param last number, optional\n   * @param maxTxns number, optional\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n  this.transactionByAddress = async (\n    addr,\n    first = null,\n    last = null,\n    maxTxns = null,\n    headerObj = {}\n  ) => {\n    if (first !== null && !Number.isInteger(first)) {\n      throw Error('first round should be an integer');\n    }\n    if (last !== null && !Number.isInteger(last)) {\n      throw Error('last round should be an integer');\n    }\n    const res = await c.get(\n      `/v1/account/${addr}/transactions`,\n      { firstRound: first, lastRound: last, max: maxTxns },\n      headerObj\n    );\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n    return res.body;\n  };\n\n  /**\n   * transactionsByAddressAndDate returns all transactions for a PK [addr] in the [fromDate, toDate] date range.\n   * The date is a string in the YYYY-MM-DD format.\n   * @param addr string\n   * @param fromDate string\n   * @param toDate string\n   * @param maxTxns number, optional\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.transactionByAddressAndDate = async (\n    addr,\n    fromDate,\n    toDate,\n    maxTxns = null,\n    headerObj = {}\n  ) => {\n    const res = await c.get(\n      `/v1/account/${addr}/transactions`,\n      { fromDate, toDate, max: maxTxns },\n      headerObj\n    );\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n    return res.body;\n  };\n\n  /**\n   * transactionById returns the a transaction information of a specific txid [txId]\n   * Note - This method is allowed only when Indexer is enabled.\n   * @param txid\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.transactionById = async (txid, headerObj = {}) => {\n    const res = await c.get(`/v1/transaction/${txid}`, {}, headerObj);\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n    return res.body;\n  };\n\n  /**\n   * transactionInformation returns the transaction information of a specific txid and an address\n   * @param addr\n   * @param txid\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.transactionInformation = async (addr, txid, headerObj = {}) => {\n    const res = await c.get(\n      `/v1/account/${addr}/transaction/${txid}`,\n      {},\n      headerObj\n    );\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n    return res.body;\n  };\n\n  /**\n   * pendingTransactionInformation returns the transaction information for a specific txid of a pending transaction\n   * @param txid\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.pendingTransactionInformation = async (txid, headerObj = {}) => {\n    const res = await c.get(`/v1/transactions/pending/${txid}`, {}, headerObj);\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n    return res.body;\n  };\n\n  /**\n   * accountInformation returns the passed account's information\n   * @param addr string\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.accountInformation = async (addr, headerObj = {}) => {\n    const res = await c.get(`/v1/account/${addr}`, {}, headerObj);\n    return res.body;\n  };\n\n  /**\n   * assetInformation returns the information for the asset with the passed creator and index\n   * @param index number\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.assetInformation = async (index, headerObj = {}) => {\n    const res = await c.get(`/v1/asset/${index}`, {}, headerObj);\n    return res.body;\n  };\n\n  /**\n   * suggestedFee gets the recommended transaction fee from the node\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.suggestedFee = async (headerObj = {}) => {\n    const res = await c.get('/v1/transactions/fee', {}, headerObj);\n    return res.body;\n  };\n\n  /**\n   * sendRawTransaction gets an encoded SignedTxn and broadcasts it to the network\n   * @param txn Uin8Array\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.sendRawTransaction = async (txn, headerObj = {}) => {\n    const txHeaders = setSendTransactionHeaders(headerObj);\n    const res = await c.post('/v1/transactions', Buffer.from(txn), txHeaders);\n    return res.body;\n  };\n\n  /**\n   * sendRawTransactions gets a list of encoded SignedTxns and broadcasts it to the network\n   * @param txn Array of Uin8Array\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.sendRawTransactions = async (txns, headerObj = {}) => {\n    const txHeaders = setSendTransactionHeaders(headerObj);\n    const merged = Array.prototype.concat(\n      ...txns.map((arr) => Array.from(arr))\n    );\n    const res = await c.post(\n      '/v1/transactions',\n      Buffer.from(merged),\n      txHeaders\n    );\n    return res.body;\n  };\n\n  /**\n   * getTransactionParams returns to common needed parameters for a new transaction\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.getTransactionParams = async (headerObj = {}) => {\n    const res = await c.get('/v1/transactions/params', {}, headerObj);\n    return res.body;\n  };\n\n  /**\n   * suggestParams returns to common needed parameters for a new transaction, in a format the transaction builder expects\n   * @param headerObj, optional\n   * @returns {Object}\n   */\n  this.suggestParams = async (headerObj = {}) => {\n    const result = await this.getTransactionParams(headerObj);\n    return {\n      flatFee: false,\n      fee: result.fee,\n      firstRound: result.lastRound,\n      lastRound: result.lastRound + 1000,\n      genesisID: result.genesisID,\n      genesisHash: result.genesishashb64,\n    };\n  };\n\n  /**\n   * block gets the block info for the given round This call blocks\n   * @param roundNumber\n   * @param headerObj, optional\n   * @returns {Promise<*>}\n   */\n  this.block = async (roundNumber, headerObj = {}) => {\n    if (!Number.isInteger(roundNumber))\n      throw Error('roundNumber should be an integer');\n    const res = await c.get(`/v1/block/${roundNumber}`, {}, headerObj);\n    if (res.statusCode === 200 && res.body.txns.transactions !== undefined) {\n      for (let i = 0; i < res.body.txns.transactions.length; i++) {\n        res.body.txns.transactions[i] = noteb64ToNote(\n          res.body.txns.transactions[i]\n        );\n      }\n    }\n    return res.body;\n  };\n}\n\nmodule.exports = { Algod };\n"]},"metadata":{},"sourceType":"script"}