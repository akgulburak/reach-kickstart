{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nconst makeTxn = require('../makeTxn');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst templates = require('./templates');\n\nclass PeriodicPayment {\n  /**\n   * MakePeriodicPayment allows some account to execute periodic withdrawal of funds.\n   * This is a contract account.\n   *\n   * This allows receiver to withdraw amount every\n   * period rounds for withdrawWindow after every multiple\n   * of period.\n   *\n   * After expiryRound, all remaining funds in the escrow\n   * are available to receiver.\n   *\n   * Constructor Parameters:\n   * @param {string} receiver: address which is authorized to receive withdrawals\n   * @param {int} amount: the amount to send each period\n   * @param {int} withdrawalWindow: the duration of a withdrawal period\n   * @param {int} period: the time between a pair of withdrawal periods\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} maxFee: maximum fee used by the withdrawal transaction\n   * @param {string} lease: b64 representation of lease to use, or leave undefined to generate one\n   * @returns {PeriodicPayment}\n   */\n  constructor(receiver, amount, withdrawalWindow, period, expiryRound, maxFee, lease) {\n    // don't need to validate receiver or lease, it's validated by template insert\n    this.receiver = receiver;\n    if (!Number.isSafeInteger(amount) || amount < 0) throw Error('amount must be a positive number and smaller than 2^53-1');\n    this.amount = amount;\n    if (!Number.isSafeInteger(withdrawalWindow) || withdrawalWindow < 0) throw Error('withdrawalWindow must be a positive number and smaller than 2^53-1');\n    this.withdrawalWindow = withdrawalWindow;\n    if (!Number.isSafeInteger(period) || period < 0) throw Error('period must be a positive number and smaller than 2^53-1');\n    this.period = period;\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error('expiryRound must be a positive number and smaller than 2^53-1');\n    this.expiryRound = expiryRound;\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error('maxFee must be a positive number and smaller than 2^53-1');\n    this.maxFee = maxFee;\n\n    if (lease === undefined) {\n      const leaseBytes = nacl.randomBytes(32);\n      this.lease = Buffer.from(leaseBytes).toString('base64');\n    } else {\n      this.lease = lease;\n    }\n\n    this.programBytes = this.getProgram();\n    const lsig = new logicSig.LogicSig(this.programBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    const referenceProgramB64 = 'ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [4\n    /* period */\n    , 5\n    /* withdrawWindow */\n    , 7\n    /* amount */\n    , 8\n    /* expiryRound */\n    , 9\n    /* lease */\n    , 12\n    /* receiver */\n    , 46];\n    const injectionVector = [this.maxFee, this.period, this.withdrawalWindow, this.amount, this.expiryRound, this.lease, this.receiver];\n    const injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.BASE64, templates.valTypes.ADDRESS];\n    return templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * getPeriodicPaymentWithdrawalTransaction returns a signed transaction extracting funds form the contract\n * @param {Uint8Array} contract: the bytearray defining the contract, received from the payer\n * @param {int} fee: the fee per byte for the transaction\n * @param {int} firstValid: the first round on which the txn will be valid\n * @param {string} genesisHash: the hash representing the network for the txn\n * @returns {Object} Object containing txID and blob representing signed transaction\n * @throws error on failure\n */\n\n\nfunction getPeriodicPaymentWithdrawalTransaction(contract, fee, firstValid, genesisHash) {\n  const readResult = logic.readProgram(contract, undefined);\n  const ints = readResult[0];\n  const byteArrays = readResult[1];\n  const period = ints[2];\n  const duration = ints[4];\n  const amount = ints[5];\n\n  if (firstValid % period !== 0) {\n    throw new Error(`firstValid round ${firstValid.toString()} was not a multiple of contract period ${period.toString()}`);\n  } // extract receiver and convert as needed\n\n\n  const receiverBytes = byteArrays[1];\n  const receiver = address.encodeAddress(receiverBytes); // extract lease and convert\n\n  const leaseBuffer = byteArrays[0];\n  const lease = new Uint8Array(leaseBuffer);\n  const lastValid = firstValid + duration;\n  const to = receiver;\n  let noCloseRemainder;\n  let noNote;\n  const lsig = logicSig.makeLogicSig(contract, undefined);\n  const from = lsig.address();\n  const txn = {\n    from,\n    to,\n    fee,\n    amount,\n    closeRemainderTo: noCloseRemainder,\n    firstRound: firstValid,\n    lastRound: lastValid,\n    note: noNote,\n    genesisHash,\n    genesisID: '',\n    type: 'pay',\n    lease\n  }; // check fee\n\n  const tempTxn = makeTxn.makePaymentTxn(from, to, fee, amount, noCloseRemainder, firstValid, lastValid, noNote, genesisHash, '');\n\n  if (tempTxn.fee > ints[1]) {\n    throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${ints[1].toString()}`);\n  }\n\n  return logicSig.signLogicSigTransaction(txn, lsig);\n}\n\nmodule.exports = {\n  PeriodicPayment,\n  getPeriodicPaymentWithdrawalTransaction\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/logicTemplates/periodicpayment.js"],"names":["Buffer","require","address","makeTxn","logic","logicSig","nacl","templates","PeriodicPayment","constructor","receiver","amount","withdrawalWindow","period","expiryRound","maxFee","lease","Number","isSafeInteger","Error","undefined","leaseBytes","randomBytes","from","toString","programBytes","getProgram","lsig","LogicSig","referenceProgramB64","referenceProgramBytes","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","BASE64","ADDRESS","inject","getAddress","getPeriodicPaymentWithdrawalTransaction","contract","fee","firstValid","genesisHash","readResult","readProgram","ints","byteArrays","duration","receiverBytes","encodeAddress","leaseBuffer","Uint8Array","lastValid","to","noCloseRemainder","noNote","makeLogicSig","txn","closeRemainderTo","firstRound","lastRound","note","genesisID","type","tempTxn","makePaymentTxn","signLogicSigTransaction","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require('../encoding/address');\nconst makeTxn = require('../makeTxn');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst nacl = require('../nacl/naclWrappers');\nconst templates = require('./templates');\n\nclass PeriodicPayment {\n  /**\n   * MakePeriodicPayment allows some account to execute periodic withdrawal of funds.\n   * This is a contract account.\n   *\n   * This allows receiver to withdraw amount every\n   * period rounds for withdrawWindow after every multiple\n   * of period.\n   *\n   * After expiryRound, all remaining funds in the escrow\n   * are available to receiver.\n   *\n   * Constructor Parameters:\n   * @param {string} receiver: address which is authorized to receive withdrawals\n   * @param {int} amount: the amount to send each period\n   * @param {int} withdrawalWindow: the duration of a withdrawal period\n   * @param {int} period: the time between a pair of withdrawal periods\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} maxFee: maximum fee used by the withdrawal transaction\n   * @param {string} lease: b64 representation of lease to use, or leave undefined to generate one\n   * @returns {PeriodicPayment}\n   */\n  constructor(\n    receiver,\n    amount,\n    withdrawalWindow,\n    period,\n    expiryRound,\n    maxFee,\n    lease\n  ) {\n    // don't need to validate receiver or lease, it's validated by template insert\n    this.receiver = receiver;\n    if (!Number.isSafeInteger(amount) || amount < 0)\n      throw Error('amount must be a positive number and smaller than 2^53-1');\n    this.amount = amount;\n    if (!Number.isSafeInteger(withdrawalWindow) || withdrawalWindow < 0)\n      throw Error(\n        'withdrawalWindow must be a positive number and smaller than 2^53-1'\n      );\n    this.withdrawalWindow = withdrawalWindow;\n    if (!Number.isSafeInteger(period) || period < 0)\n      throw Error('period must be a positive number and smaller than 2^53-1');\n    this.period = period;\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)\n      throw Error(\n        'expiryRound must be a positive number and smaller than 2^53-1'\n      );\n    this.expiryRound = expiryRound;\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0)\n      throw Error('maxFee must be a positive number and smaller than 2^53-1');\n    this.maxFee = maxFee;\n\n    if (lease === undefined) {\n      const leaseBytes = nacl.randomBytes(32);\n      this.lease = Buffer.from(leaseBytes).toString('base64');\n    } else {\n      this.lease = lease;\n    }\n\n    this.programBytes = this.getProgram();\n    const lsig = new logicSig.LogicSig(this.programBytes, undefined);\n    this.address = lsig.address();\n  }\n\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n  getProgram() {\n    const referenceProgramB64 =\n      'ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [\n      4 /* period */,\n      5 /* withdrawWindow */,\n      7 /* amount */,\n      8 /* expiryRound */,\n      9 /* lease */,\n      12 /* receiver */,\n      46,\n    ];\n    const injectionVector = [\n      this.maxFee,\n      this.period,\n      this.withdrawalWindow,\n      this.amount,\n      this.expiryRound,\n      this.lease,\n      this.receiver,\n    ];\n    const injectionTypes = [\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.INT,\n      templates.valTypes.BASE64,\n      templates.valTypes.ADDRESS,\n    ];\n    return templates.inject(\n      referenceProgramBytes,\n      referenceOffsets,\n      injectionVector,\n      injectionTypes\n    );\n  }\n\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n  getAddress() {\n    return this.address;\n  }\n}\n\n/**\n * getPeriodicPaymentWithdrawalTransaction returns a signed transaction extracting funds form the contract\n * @param {Uint8Array} contract: the bytearray defining the contract, received from the payer\n * @param {int} fee: the fee per byte for the transaction\n * @param {int} firstValid: the first round on which the txn will be valid\n * @param {string} genesisHash: the hash representing the network for the txn\n * @returns {Object} Object containing txID and blob representing signed transaction\n * @throws error on failure\n */\nfunction getPeriodicPaymentWithdrawalTransaction(\n  contract,\n  fee,\n  firstValid,\n  genesisHash\n) {\n  const readResult = logic.readProgram(contract, undefined);\n  const ints = readResult[0];\n  const byteArrays = readResult[1];\n  const period = ints[2];\n  const duration = ints[4];\n  const amount = ints[5];\n  if (firstValid % period !== 0) {\n    throw new Error(\n      `firstValid round ${firstValid.toString()} was not a multiple of contract period ${period.toString()}`\n    );\n  }\n\n  // extract receiver and convert as needed\n  const receiverBytes = byteArrays[1];\n  const receiver = address.encodeAddress(receiverBytes);\n  // extract lease and convert\n  const leaseBuffer = byteArrays[0];\n  const lease = new Uint8Array(leaseBuffer);\n  const lastValid = firstValid + duration;\n  const to = receiver;\n  let noCloseRemainder;\n  let noNote;\n  const lsig = logicSig.makeLogicSig(contract, undefined);\n  const from = lsig.address();\n  const txn = {\n    from,\n    to,\n    fee,\n    amount,\n    closeRemainderTo: noCloseRemainder,\n    firstRound: firstValid,\n    lastRound: lastValid,\n    note: noNote,\n    genesisHash,\n    genesisID: '',\n    type: 'pay',\n    lease,\n  };\n\n  // check fee\n  const tempTxn = makeTxn.makePaymentTxn(\n    from,\n    to,\n    fee,\n    amount,\n    noCloseRemainder,\n    firstValid,\n    lastValid,\n    noNote,\n    genesisHash,\n    ''\n  );\n  if (tempTxn.fee > ints[1]) {\n    throw new Error(\n      `final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${ints[1].toString()}`\n    );\n  }\n\n  return logicSig.signLogicSigTransaction(txn, lsig);\n}\nmodule.exports = {\n  PeriodicPayment,\n  getPeriodicPaymentWithdrawalTransaction,\n};\n"]},"metadata":{},"sourceType":"script"}