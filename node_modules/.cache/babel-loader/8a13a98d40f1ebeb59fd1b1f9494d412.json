{"ast":null,"code":"const base32 = require('hi-base32');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst utils = require('../utils/utils');\n\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nconst ALGORAND_ZERO_ADDRESS_STRING = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ'; // Convert \"MultisigAddr\" UTF-8 to byte array\n\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\nconst MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nconst CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\nconst INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nconst INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nconst INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';\nconst UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param {string} address an Algorand address with checksum.\n * @returns {{publicKey: Uint8Array, checksum: Uint8Array}} the decoded form of the address's public key and checksum\n */\n\nfunction decodeAddress(address) {\n  if (!(typeof address === 'string' || address instanceof String) || address.length !== ALGORAND_ADDRESS_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG); // try to decode\n\n  const decoded = base32.decode.asBytes(address); // Sanity check\n\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG); // Find publickey and checksum\n\n  const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n  const cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH)); // Compute checksum\n\n  const checksum = nacl.genericHash(pk).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH); // Check if the checksum and the address are equal\n\n  if (!utils.arrayEqual(checksum, cs)) throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n  return {\n    publicKey: pk,\n    checksum: cs\n  };\n}\n/**\n * isValidAddress checks if a string is a valid Algorand address.\n * @param {string} address an Algorand address with checksum.\n * @returns {boolean} true if valid, false otherwise\n */\n\n\nfunction isValidAddress(address) {\n  // Try to decode\n  try {\n    decodeAddress(address);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param {Uint8Array} address a raw Algorand address\n * @returns {string} the address and checksum encoded as a string.\n */\n\n\nfunction encodeAddress(address) {\n  // compute checksum\n  const checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);\n  const addr = base32.encode(utils.concatArrays(address, checksum));\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param pks array of typed array public keys\n */\n\n\nfunction fromMultisigPreImg({\n  version,\n  threshold,\n  pks\n}) {\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n\n  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n\n  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n\n  for (let i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n\n  return nacl.genericHash(merged);\n}\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs array of encoded addresses\n */\n\n\nfunction fromMultisigPreImgAddrs({\n  version,\n  threshold,\n  addrs\n}) {\n  const pks = addrs.map(addr => decodeAddress(addr).publicKey);\n  return encodeAddress(fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  }));\n}\n\nmodule.exports = {\n  isValidAddress,\n  decodeAddress,\n  encodeAddress,\n  fromMultisigPreImg,\n  fromMultisigPreImgAddrs,\n  MALFORMED_ADDRESS_ERROR_MSG,\n  CHECKSUM_ADDRESS_ERROR_MSG,\n  INVALID_MSIG_VERSION_ERROR_MSG,\n  INVALID_MSIG_THRESHOLD_ERROR_MSG,\n  INVALID_MSIG_PK_ERROR_MSG,\n  UNEXPECTED_PK_LEN_ERROR_MSG,\n  ALGORAND_ZERO_ADDRESS_STRING\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/encoding/address.js"],"names":["base32","require","nacl","utils","ALGORAND_ADDRESS_BYTE_LENGTH","ALGORAND_CHECKSUM_BYTE_LENGTH","ALGORAND_ADDRESS_LENGTH","ALGORAND_ZERO_ADDRESS_STRING","MULTISIG_PREIMG2ADDR_PREFIX","Uint8Array","MALFORMED_ADDRESS_ERROR_MSG","CHECKSUM_ADDRESS_ERROR_MSG","INVALID_MSIG_VERSION_ERROR_MSG","INVALID_MSIG_THRESHOLD_ERROR_MSG","INVALID_MSIG_PK_ERROR_MSG","UNEXPECTED_PK_LEN_ERROR_MSG","decodeAddress","address","String","length","Error","decoded","decode","asBytes","pk","slice","cs","PUBLIC_KEY_LENGTH","checksum","genericHash","HASH_BYTES_LENGTH","arrayEqual","publicKey","isValidAddress","e","encodeAddress","addr","encode","concatArrays","toString","fromMultisigPreImg","version","threshold","pks","pkLen","merged","set","i","fromMultisigPreImgAddrs","addrs","map","module","exports"],"mappings":"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","sourcesContent":["const base32 = require('hi-base32');\nconst nacl = require('../nacl/naclWrappers');\nconst utils = require('../utils/utils');\n\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nconst ALGORAND_ZERO_ADDRESS_STRING =\n  'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\n\n// Convert \"MultisigAddr\" UTF-8 to byte array\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([\n  77,\n  117,\n  108,\n  116,\n  105,\n  115,\n  105,\n  103,\n  65,\n  100,\n  100,\n  114,\n]);\n\nconst MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nconst CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\nconst INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nconst INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nconst INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';\nconst UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';\n\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param {string} address an Algorand address with checksum.\n * @returns {{publicKey: Uint8Array, checksum: Uint8Array}} the decoded form of the address's public key and checksum\n */\nfunction decodeAddress(address) {\n  if (\n    !(typeof address === 'string' || address instanceof String) ||\n    address.length !== ALGORAND_ADDRESS_LENGTH\n  )\n    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n\n  // try to decode\n  const decoded = base32.decode.asBytes(address);\n\n  // Sanity check\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)\n    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n\n  // Find publickey and checksum\n  const pk = new Uint8Array(\n    decoded.slice(\n      0,\n      ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH\n    )\n  );\n  const cs = new Uint8Array(\n    decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH)\n  );\n\n  // Compute checksum\n  const checksum = nacl\n    .genericHash(pk)\n    .slice(\n      nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\n      nacl.HASH_BYTES_LENGTH\n    );\n\n  // Check if the checksum and the address are equal\n  if (!utils.arrayEqual(checksum, cs))\n    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n\n  return { publicKey: pk, checksum: cs };\n}\n\n/**\n * isValidAddress checks if a string is a valid Algorand address.\n * @param {string} address an Algorand address with checksum.\n * @returns {boolean} true if valid, false otherwise\n */\nfunction isValidAddress(address) {\n  // Try to decode\n  try {\n    decodeAddress(address);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param {Uint8Array} address a raw Algorand address\n * @returns {string} the address and checksum encoded as a string.\n */\nfunction encodeAddress(address) {\n  // compute checksum\n  const checksum = nacl\n    .genericHash(address)\n    .slice(\n      nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\n      nacl.PUBLIC_KEY_LENGTH\n    );\n  const addr = base32.encode(utils.concatArrays(address, checksum));\n\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param pks array of typed array public keys\n */\nfunction fromMultisigPreImg({ version, threshold, pks }) {\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n  if (\n    threshold === 0 ||\n    pks.length === 0 ||\n    threshold > pks.length ||\n    threshold > 255\n  ) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n  const merged = new Uint8Array(\n    MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length\n  );\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n  for (let i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n  return nacl.genericHash(merged);\n}\n\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs array of encoded addresses\n */\nfunction fromMultisigPreImgAddrs({ version, threshold, addrs }) {\n  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);\n  return encodeAddress(fromMultisigPreImg({ version, threshold, pks }));\n}\n\nmodule.exports = {\n  isValidAddress,\n  decodeAddress,\n  encodeAddress,\n  fromMultisigPreImg,\n  fromMultisigPreImgAddrs,\n  MALFORMED_ADDRESS_ERROR_MSG,\n  CHECKSUM_ADDRESS_ERROR_MSG,\n  INVALID_MSIG_VERSION_ERROR_MSG,\n  INVALID_MSIG_THRESHOLD_ERROR_MSG,\n  INVALID_MSIG_PK_ERROR_MSG,\n  UNEXPECTED_PK_LEN_ERROR_MSG,\n  ALGORAND_ZERO_ADDRESS_STRING,\n};\n"]},"metadata":{},"sourceType":"script"}