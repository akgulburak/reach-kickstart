{"ast":null,"code":"/* eslint-disable no-bitwise */\nconst {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nfunction putUvarint(buf, x) {\n  let i = 0;\n\n  while (x > 0x80) {\n    buf.push(x & 0xff | 0x80); // eslint-disable-next-line no-param-reassign\n\n    x >>= 7;\n    i += 1;\n  }\n\n  buf.push(x & 0xff);\n  return i + 1;\n}\n\nconst valTypes = {\n  INT: 1,\n  ADDRESS: 2,\n  BASE64: 3\n};\n\nfunction inject(orig, offsets, values, valueTypes) {\n  if (offsets.length !== values.length || offsets.length !== valueTypes.length) {\n    throw new Error('Lengths do not match');\n  }\n\n  let res = orig;\n\n  function replace(arr, newVal, offset, placeholderLength) {\n    const beforeReplacement = arr.slice(0, offset);\n    const afterReplacement = arr.slice(offset + placeholderLength, arr.length);\n    const chunks = [beforeReplacement, Buffer.from(newVal), afterReplacement];\n    return Buffer.concat(chunks);\n  }\n\n  for (let i = 0; i < offsets.length; i++) {\n    let decodedLength = 0;\n    let val = values[i];\n    const valType = valueTypes[i];\n\n    switch (valType) {\n      case valTypes.INT:\n        // eslint-disable-next-line no-case-declarations\n        const intBuf = [];\n        decodedLength = putUvarint(intBuf, val);\n        res = replace(res, intBuf, offsets[i], 1);\n        break;\n\n      case valTypes.ADDRESS:\n        val = address.decodeAddress(val);\n        res = replace(res, val.publicKey, offsets[i], 32);\n        break;\n\n      case valTypes.BASE64:\n        // eslint-disable-next-line no-case-declarations\n        const lenBuf = [];\n        val = Buffer.from(val, 'base64');\n        putUvarint(lenBuf, val.length);\n        val = Buffer.concat([Buffer.from(lenBuf), val]);\n        res = replace(res, val, offsets[i], 33);\n        break;\n\n      default:\n        throw new Error('unrecognized value type');\n    }\n\n    if (decodedLength !== 0) {\n      for (let o = 0; o < offsets.length; o++) {\n        // eslint-disable-next-line no-param-reassign\n        offsets[o] += decodedLength - 1;\n      }\n    }\n  }\n\n  return res;\n}\n\nmodule.exports = {\n  inject,\n  valTypes\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/logicTemplates/templates.js"],"names":["Buffer","require","address","putUvarint","buf","x","i","push","valTypes","INT","ADDRESS","BASE64","inject","orig","offsets","values","valueTypes","length","Error","res","replace","arr","newVal","offset","placeholderLength","beforeReplacement","slice","afterReplacement","chunks","from","concat","decodedLength","val","valType","intBuf","decodeAddress","publicKey","lenBuf","o","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-bitwise */\nconst { Buffer } = require('buffer');\nconst address = require('../encoding/address');\n\nfunction putUvarint(buf, x) {\n  let i = 0;\n  while (x > 0x80) {\n    buf.push((x & 0xff) | 0x80);\n    // eslint-disable-next-line no-param-reassign\n    x >>= 7;\n    i += 1;\n  }\n  buf.push(x & 0xff);\n  return i + 1;\n}\n\nconst valTypes = {\n  INT: 1,\n  ADDRESS: 2,\n  BASE64: 3,\n};\n\nfunction inject(orig, offsets, values, valueTypes) {\n  if (\n    offsets.length !== values.length ||\n    offsets.length !== valueTypes.length\n  ) {\n    throw new Error('Lengths do not match');\n  }\n\n  let res = orig;\n\n  function replace(arr, newVal, offset, placeholderLength) {\n    const beforeReplacement = arr.slice(0, offset);\n    const afterReplacement = arr.slice(offset + placeholderLength, arr.length);\n    const chunks = [beforeReplacement, Buffer.from(newVal), afterReplacement];\n    return Buffer.concat(chunks);\n  }\n\n  for (let i = 0; i < offsets.length; i++) {\n    let decodedLength = 0;\n    let val = values[i];\n    const valType = valueTypes[i];\n\n    switch (valType) {\n      case valTypes.INT:\n        // eslint-disable-next-line no-case-declarations\n        const intBuf = [];\n        decodedLength = putUvarint(intBuf, val);\n        res = replace(res, intBuf, offsets[i], 1);\n        break;\n      case valTypes.ADDRESS:\n        val = address.decodeAddress(val);\n        res = replace(res, val.publicKey, offsets[i], 32);\n        break;\n      case valTypes.BASE64:\n        // eslint-disable-next-line no-case-declarations\n        const lenBuf = [];\n        val = Buffer.from(val, 'base64');\n        putUvarint(lenBuf, val.length);\n        val = Buffer.concat([Buffer.from(lenBuf), val]);\n        res = replace(res, val, offsets[i], 33);\n        break;\n      default:\n        throw new Error('unrecognized value type');\n    }\n\n    if (decodedLength !== 0) {\n      for (let o = 0; o < offsets.length; o++) {\n        // eslint-disable-next-line no-param-reassign\n        offsets[o] += decodedLength - 1;\n      }\n    }\n  }\n\n  return res;\n}\n\nmodule.exports = { inject, valTypes };\n"]},"metadata":{},"sourceType":"script"}