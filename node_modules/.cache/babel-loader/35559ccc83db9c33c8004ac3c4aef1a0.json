{"ast":null,"code":"import * as stdlib_ETH from './ETH.mjs';\nimport * as stdlib_ALGO from './ALGO.mjs';\nimport { getConnectorMode, canonicalizeConnectorMode, getConnector } from './ConnectorMode.mjs';\nimport { process, window } from './shim.mjs';\nexport { getConnectorMode, getConnector }; // XXX make an interface for Stdlib, return Promise<Stdlib>\n// The connectorMode arg is optional;\n// It will use REACH_CONNECTOR_MODE if 0 args.\n\nexport async function loadStdlib(connectorModeOrEnv) {\n  if (!connectorModeOrEnv) {\n    // @ts-ignore // XXX why doesn't TS understand that Env satisfies {[key: string}: string} ?\n    return await loadStdlib(process.env);\n  }\n\n  let connectorModeStr;\n\n  if (typeof connectorModeOrEnv === 'string') {\n    connectorModeStr = connectorModeOrEnv;\n  } else if (connectorModeOrEnv['REACH_CONNECTOR_MODE']) {\n    connectorModeStr = connectorModeOrEnv['REACH_CONNECTOR_MODE'];\n  } else if (connectorModeOrEnv['REACT_APP_REACH_CONNECTOR_MODE']) {\n    connectorModeStr = connectorModeOrEnv['REACT_APP_REACH_CONNECTOR_MODE'];\n  } else {\n    // TODO: also check {REACT_APP_,}REACH_DEFAULT_NETWORK\n    connectorModeStr = 'ETH'; // If absolutely none specified/found, just default to 'ETH'\n  }\n\n  const connectorMode = canonicalizeConnectorMode(connectorModeStr);\n  const connector = getConnector(connectorMode);\n  let stdlib;\n\n  switch (connector) {\n    case 'ETH':\n      stdlib = stdlib_ETH;\n      break;\n\n    case 'ALGO':\n      stdlib = stdlib_ALGO;\n      break;\n\n    default:\n      throw Error(`impossible: unknown connector ${connector}`);\n  }\n\n  if (connectorModeOrEnv && typeof connectorModeOrEnv !== 'string') {\n    let debug = connectorModeOrEnv['REACH_DEBUG'] || connectorModeOrEnv['REACT_APP_REACH_DEBUG'] ? true : false;\n    stdlib.setDEBUG(debug);\n  } // also just inject ourselves into the window for ease of use\n\n\n  window.reach = stdlib;\n  return stdlib;\n}","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/@reach-sh/stdlib/loader.mjs"],"names":["stdlib_ETH","stdlib_ALGO","getConnectorMode","canonicalizeConnectorMode","getConnector","process","window","loadStdlib","connectorModeOrEnv","env","connectorModeStr","connectorMode","connector","stdlib","Error","debug","setDEBUG","reach"],"mappings":"AAAA,OAAO,KAAKA,UAAZ,MAA4B,WAA5B;AACA,OAAO,KAAKC,WAAZ,MAA6B,YAA7B;AACA,SAASC,gBAAT,EAA2BC,yBAA3B,EAAsDC,YAAtD,QAA0E,qBAA1E;AACA,SAASC,OAAT,EAAkBC,MAAlB,QAAgC,YAAhC;AACA,SAASJ,gBAAT,EAA2BE,YAA3B,G,CACA;AACA;AACA;;AACA,OAAO,eAAeG,UAAf,CAA0BC,kBAA1B,EAA8C;AACnD,MAAI,CAACA,kBAAL,EAAyB;AACvB;AACA,WAAO,MAAMD,UAAU,CAACF,OAAO,CAACI,GAAT,CAAvB;AACD;;AACD,MAAIC,gBAAJ;;AACA,MAAI,OAAOF,kBAAP,KAA8B,QAAlC,EAA4C;AAC1CE,IAAAA,gBAAgB,GAAGF,kBAAnB;AACD,GAFD,MAEO,IAAIA,kBAAkB,CAAC,sBAAD,CAAtB,EAAgD;AACrDE,IAAAA,gBAAgB,GAAGF,kBAAkB,CAAC,sBAAD,CAArC;AACD,GAFM,MAEA,IAAIA,kBAAkB,CAAC,gCAAD,CAAtB,EAA0D;AAC/DE,IAAAA,gBAAgB,GAAGF,kBAAkB,CAAC,gCAAD,CAArC;AACD,GAFM,MAEA;AACL;AACAE,IAAAA,gBAAgB,GAAG,KAAnB,CAFK,CAEqB;AAC3B;;AACD,QAAMC,aAAa,GAAGR,yBAAyB,CAACO,gBAAD,CAA/C;AACA,QAAME,SAAS,GAAGR,YAAY,CAACO,aAAD,CAA9B;AACA,MAAIE,MAAJ;;AACA,UAAQD,SAAR;AACE,SAAK,KAAL;AACEC,MAAAA,MAAM,GAAGb,UAAT;AACA;;AACF,SAAK,MAAL;AACEa,MAAAA,MAAM,GAAGZ,WAAT;AACA;;AACF;AACE,YAAMa,KAAK,CAAE,iCAAgCF,SAAU,EAA5C,CAAX;AARJ;;AAUA,MAAIJ,kBAAkB,IAAI,OAAOA,kBAAP,KAA8B,QAAxD,EAAkE;AAChE,QAAIO,KAAK,GAAIP,kBAAkB,CAAC,aAAD,CAAlB,IAAqCA,kBAAkB,CAAC,uBAAD,CAAxD,GAAqF,IAArF,GAA4F,KAAxG;AACAK,IAAAA,MAAM,CAACG,QAAP,CAAgBD,KAAhB;AACD,GAhCkD,CAiCnD;;;AACAT,EAAAA,MAAM,CAACW,KAAP,GAAeJ,MAAf;AACA,SAAOA,MAAP;AACD","sourcesContent":["import * as stdlib_ETH from './ETH.mjs';\nimport * as stdlib_ALGO from './ALGO.mjs';\nimport { getConnectorMode, canonicalizeConnectorMode, getConnector } from './ConnectorMode.mjs';\nimport { process, window } from './shim.mjs';\nexport { getConnectorMode, getConnector };\n// XXX make an interface for Stdlib, return Promise<Stdlib>\n// The connectorMode arg is optional;\n// It will use REACH_CONNECTOR_MODE if 0 args.\nexport async function loadStdlib(connectorModeOrEnv) {\n  if (!connectorModeOrEnv) {\n    // @ts-ignore // XXX why doesn't TS understand that Env satisfies {[key: string}: string} ?\n    return await loadStdlib(process.env);\n  }\n  let connectorModeStr;\n  if (typeof connectorModeOrEnv === 'string') {\n    connectorModeStr = connectorModeOrEnv;\n  } else if (connectorModeOrEnv['REACH_CONNECTOR_MODE']) {\n    connectorModeStr = connectorModeOrEnv['REACH_CONNECTOR_MODE'];\n  } else if (connectorModeOrEnv['REACT_APP_REACH_CONNECTOR_MODE']) {\n    connectorModeStr = connectorModeOrEnv['REACT_APP_REACH_CONNECTOR_MODE'];\n  } else {\n    // TODO: also check {REACT_APP_,}REACH_DEFAULT_NETWORK\n    connectorModeStr = 'ETH'; // If absolutely none specified/found, just default to 'ETH'\n  }\n  const connectorMode = canonicalizeConnectorMode(connectorModeStr);\n  const connector = getConnector(connectorMode);\n  let stdlib;\n  switch (connector) {\n    case 'ETH':\n      stdlib = stdlib_ETH;\n      break;\n    case 'ALGO':\n      stdlib = stdlib_ALGO;\n      break;\n    default:\n      throw Error(`impossible: unknown connector ${connector}`);\n  }\n  if (connectorModeOrEnv && typeof connectorModeOrEnv !== 'string') {\n    let debug = (connectorModeOrEnv['REACH_DEBUG'] || connectorModeOrEnv['REACT_APP_REACH_DEBUG']) ? true : false;\n    stdlib.setDEBUG(debug);\n  }\n  // also just inject ourselves into the window for ease of use\n  window.reach = stdlib;\n  return stdlib;\n}\n"]},"metadata":{},"sourceType":"module"}