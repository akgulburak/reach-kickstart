{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n/**\n * Sets the default header (if not previously set) for sending a raw\n * transaction.\n * @param headers\n * @returns {*}\n */\n\n\nfunction setSendTransactionHeaders(headers) {\n  let hdrs = headers;\n\n  if (Object.keys(hdrs).every(key => key.toLowerCase() !== 'content-type')) {\n    hdrs = { ...headers\n    };\n    hdrs['Content-Type'] = 'application/x-binary';\n  }\n\n  return hdrs;\n}\n\nclass SendRawTransaction {\n  constructor(c, stxOrStxs) {\n    let forPosting = stxOrStxs;\n\n    function isByteArray(array) {\n      return !!(array && array.byteLength !== undefined);\n    }\n\n    if (Array.isArray(stxOrStxs)) {\n      if (!stxOrStxs.every(isByteArray)) {\n        throw new TypeError('Array elements must be byte arrays');\n      }\n\n      forPosting = Array.prototype.concat(...stxOrStxs.map(arr => Array.from(arr)));\n    } else if (!isByteArray(forPosting)) {\n      throw new TypeError('Argument must be byte array');\n    }\n\n    this.txnBytesToPost = forPosting;\n    this.c = c;\n  }\n  /**\n   * broadcasts the passed signed txns to the network\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  async do(headers = {}) {\n    const txHeaders = setSendTransactionHeaders(headers);\n    const res = await this.c.post('/v2/transactions', Buffer.from(this.txnBytesToPost), txHeaders);\n    return res.body;\n  }\n\n}\n\nmodule.exports = {\n  SendRawTransaction,\n  setSendTransactionHeaders\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/algosdk/src/client/v2/algod/sendRawTransaction.js"],"names":["Buffer","require","setSendTransactionHeaders","headers","hdrs","Object","keys","every","key","toLowerCase","SendRawTransaction","constructor","c","stxOrStxs","forPosting","isByteArray","array","byteLength","undefined","Array","isArray","TypeError","prototype","concat","map","arr","from","txnBytesToPost","do","txHeaders","res","post","body","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,yBAAT,CAAmCC,OAAnC,EAA4C;AAC1C,MAAIC,IAAI,GAAGD,OAAX;;AACA,MAAIE,MAAM,CAACC,IAAP,CAAYF,IAAZ,EAAkBG,KAAlB,CAAyBC,GAAD,IAASA,GAAG,CAACC,WAAJ,OAAsB,cAAvD,CAAJ,EAA4E;AAC1EL,IAAAA,IAAI,GAAG,EAAE,GAAGD;AAAL,KAAP;AACAC,IAAAA,IAAI,CAAC,cAAD,CAAJ,GAAuB,sBAAvB;AACD;;AACD,SAAOA,IAAP;AACD;;AAED,MAAMM,kBAAN,CAAyB;AACvBC,EAAAA,WAAW,CAACC,CAAD,EAAIC,SAAJ,EAAe;AACxB,QAAIC,UAAU,GAAGD,SAAjB;;AACA,aAASE,WAAT,CAAqBC,KAArB,EAA4B;AAC1B,aAAO,CAAC,EAAEA,KAAK,IAAIA,KAAK,CAACC,UAAN,KAAqBC,SAAhC,CAAR;AACD;;AACD,QAAIC,KAAK,CAACC,OAAN,CAAcP,SAAd,CAAJ,EAA8B;AAC5B,UAAI,CAACA,SAAS,CAACN,KAAV,CAAgBQ,WAAhB,CAAL,EAAmC;AACjC,cAAM,IAAIM,SAAJ,CAAc,oCAAd,CAAN;AACD;;AACDP,MAAAA,UAAU,GAAGK,KAAK,CAACG,SAAN,CAAgBC,MAAhB,CACX,GAAGV,SAAS,CAACW,GAAV,CAAeC,GAAD,IAASN,KAAK,CAACO,IAAN,CAAWD,GAAX,CAAvB,CADQ,CAAb;AAGD,KAPD,MAOO,IAAI,CAACV,WAAW,CAACD,UAAD,CAAhB,EAA8B;AACnC,YAAM,IAAIO,SAAJ,CAAc,6BAAd,CAAN;AACD;;AACD,SAAKM,cAAL,GAAsBb,UAAtB;AACA,SAAKF,CAAL,GAASA,CAAT;AACD;AAED;AACF;AACA;AACA;AACA;;;AACU,QAAFgB,EAAE,CAACzB,OAAO,GAAG,EAAX,EAAe;AACrB,UAAM0B,SAAS,GAAG3B,yBAAyB,CAACC,OAAD,CAA3C;AACA,UAAM2B,GAAG,GAAG,MAAM,KAAKlB,CAAL,CAAOmB,IAAP,CAChB,kBADgB,EAEhB/B,MAAM,CAAC0B,IAAP,CAAY,KAAKC,cAAjB,CAFgB,EAGhBE,SAHgB,CAAlB;AAKA,WAAOC,GAAG,CAACE,IAAX;AACD;;AAjCsB;;AAoCzBC,MAAM,CAACC,OAAP,GAAiB;AAAExB,EAAAA,kBAAF;AAAsBR,EAAAA;AAAtB,CAAjB","sourcesContent":["const { Buffer } = require('buffer');\n\n/**\n * Sets the default header (if not previously set) for sending a raw\n * transaction.\n * @param headers\n * @returns {*}\n */\nfunction setSendTransactionHeaders(headers) {\n  let hdrs = headers;\n  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== 'content-type')) {\n    hdrs = { ...headers };\n    hdrs['Content-Type'] = 'application/x-binary';\n  }\n  return hdrs;\n}\n\nclass SendRawTransaction {\n  constructor(c, stxOrStxs) {\n    let forPosting = stxOrStxs;\n    function isByteArray(array) {\n      return !!(array && array.byteLength !== undefined);\n    }\n    if (Array.isArray(stxOrStxs)) {\n      if (!stxOrStxs.every(isByteArray)) {\n        throw new TypeError('Array elements must be byte arrays');\n      }\n      forPosting = Array.prototype.concat(\n        ...stxOrStxs.map((arr) => Array.from(arr))\n      );\n    } else if (!isByteArray(forPosting)) {\n      throw new TypeError('Argument must be byte array');\n    }\n    this.txnBytesToPost = forPosting;\n    this.c = c;\n  }\n\n  /**\n   * broadcasts the passed signed txns to the network\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n  async do(headers = {}) {\n    const txHeaders = setSendTransactionHeaders(headers);\n    const res = await this.c.post(\n      '/v2/transactions',\n      Buffer.from(this.txnBytesToPost),\n      txHeaders\n    );\n    return res.body;\n  }\n}\n\nmodule.exports = { SendRawTransaction, setSendTransactionHeaders };\n"]},"metadata":{},"sourceType":"script"}