{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CachedKeyDecoder = void 0;\n\nconst utf8_1 = require(\"./utils/utf8\");\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nclass CachedKeyDecoder {\n  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n    this.hit = 0;\n    this.miss = 0; // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n\n    this.caches = [];\n\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  canBeCached(byteLength) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  find(bytes, inputOffset, byteLength) {\n    const records = this.caches[byteLength - 1];\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n\n      return record.str;\n    }\n\n    return null;\n  }\n\n  store(bytes, value) {\n    const records = this.caches[bytes.length - 1];\n    const record = {\n      bytes,\n      str: value\n    };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[Math.random() * records.length | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  decode(bytes, inputOffset, byteLength) {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n\n    this.miss++;\n    const str = utf8_1.utf8DecodeJs(bytes, inputOffset, byteLength); // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n\n}\n\nexports.CachedKeyDecoder = CachedKeyDecoder;","map":{"version":3,"sources":["../src/CachedKeyDecoder.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,MAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAEA,MAAM,sBAAsB,GAAG,EAA/B;AACA,MAAM,0BAA0B,GAAG,EAAnC;;AAWA,MAAa,gBAAb,CAA6B;AAK3B,EAAA,WAAA,CAAqB,YAAA,GAAe,sBAApC,EAAqE,eAAA,GAAkB,0BAAvF,EAAiH;AAA5F,SAAA,YAAA,GAAA,YAAA;AAAgD,SAAA,eAAA,GAAA,eAAA;AAJrE,SAAA,GAAA,GAAM,CAAN;AACA,SAAA,IAAA,GAAO,CAAP,CAGiH,CAC/G;AACA;;AACA,SAAK,MAAL,GAAc,EAAd;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,YAAzB,EAAuC,CAAC,EAAxC,EAA4C;AAC1C,WAAK,MAAL,CAAY,IAAZ,CAAiB,EAAjB;AACD;AACF;;AAEM,EAAA,WAAW,CAAC,UAAD,EAAmB;AACnC,WAAO,UAAU,GAAG,CAAb,IAAkB,UAAU,IAAI,KAAK,YAA5C;AACD;;AAEO,EAAA,IAAI,CAAC,KAAD,EAAoB,WAApB,EAAyC,UAAzC,EAA2D;AACrE,UAAM,OAAO,GAAG,KAAK,MAAL,CAAY,UAAU,GAAG,CAAzB,CAAhB;;AAEA,IAAA,UAAU,EAAE,KAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AACxC,YAAM,WAAW,GAAG,MAAM,CAAC,KAA3B;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACnC,YAAI,WAAW,CAAC,CAAD,CAAX,KAAmB,KAAK,CAAC,WAAW,GAAG,CAAf,CAA5B,EAA+C;AAC7C,mBAAS,UAAT;AACD;AACF;;AACD,aAAO,MAAM,CAAC,GAAd;AACD;;AACD,WAAO,IAAP;AACD;;AAEO,EAAA,KAAK,CAAC,KAAD,EAAoB,KAApB,EAAiC;AAC5C,UAAM,OAAO,GAAG,KAAK,MAAL,CAAY,KAAK,CAAC,MAAN,GAAe,CAA3B,CAAhB;AACA,UAAM,MAAM,GAAmB;AAAE,MAAA,KAAF;AAAS,MAAA,GAAG,EAAE;AAAd,KAA/B;;AAEA,QAAI,OAAO,CAAC,MAAR,IAAkB,KAAK,eAA3B,EAA4C;AAC1C;AACA;AACA,MAAA,OAAO,CAAE,IAAI,CAAC,MAAL,KAAgB,OAAO,CAAC,MAAzB,GAAmC,CAApC,CAAP,GAAgD,MAAhD;AACD,KAJD,MAIO;AACL,MAAA,OAAO,CAAC,IAAR,CAAa,MAAb;AACD;AACF;;AAEM,EAAA,MAAM,CAAC,KAAD,EAAoB,WAApB,EAAyC,UAAzC,EAA2D;AACtE,UAAM,WAAW,GAAG,KAAK,IAAL,CAAU,KAAV,EAAiB,WAAjB,EAA8B,UAA9B,CAApB;;AACA,QAAI,WAAW,IAAI,IAAnB,EAAyB;AACvB,WAAK,GAAL;AACA,aAAO,WAAP;AACD;;AACD,SAAK,IAAL;AAEA,UAAM,GAAG,GAAG,MAAA,CAAA,YAAA,CAAa,KAAb,EAAoB,WAApB,EAAiC,UAAjC,CAAZ,CARsE,CAStE;;AACA,UAAM,iBAAiB,GAAG,UAAU,CAAC,SAAX,CAAqB,KAArB,CAA2B,IAA3B,CAAgC,KAAhC,EAAuC,WAAvC,EAAoD,WAAW,GAAG,UAAlE,CAA1B;AACA,SAAK,KAAL,CAAW,iBAAX,EAA8B,GAA9B;AACA,WAAO,GAAP;AACD;;AA5D0B;;AAA7B,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CachedKeyDecoder = void 0;\nconst utf8_1 = require(\"./utils/utf8\");\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\nclass CachedKeyDecoder {\n    constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (let i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    canBeCached(byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    }\n    find(bytes, inputOffset, byteLength) {\n        const records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (const record of records) {\n            const recordBytes = record.bytes;\n            for (let j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    }\n    store(bytes, value) {\n        const records = this.caches[bytes.length - 1];\n        const record = { bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    }\n    decode(bytes, inputOffset, byteLength) {\n        const cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        const str = utf8_1.utf8DecodeJs(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    }\n}\nexports.CachedKeyDecoder = CachedKeyDecoder;\n//# sourceMappingURL=CachedKeyDecoder.js.map"]},"metadata":{},"sourceType":"script"}