{"ast":null,"code":"const debug = require('debug')('wait-port');\n\nconst net = require('net');\n\nconst outputFunctions = require('./output-functions');\n\nconst validateParameters = require('./validate-parameters');\n\nconst ConnectionError = require('./errors/connection-error');\n\nfunction createConnectionWithTimeout({\n  host,\n  port\n}, timeout, callback) {\n  //  Variable to hold the timer we'll use to kill the socket if we don't\n  //  connect in time.\n  let timer = null; //  Try and open the socket, with the params and callback.\n\n  const socket = net.createConnection({\n    host,\n    port\n  }, err => {\n    if (!err) clearTimeout(timer);\n    return callback(err);\n  }); //  TODO: Check for the socket ECONNREFUSED event.\n\n  socket.on('error', error => {\n    debug(`Socket error: ${error}`);\n    clearTimeout(timer);\n    socket.destroy();\n    callback(error);\n  }); //  Kill the socket if we don't open in time.\n\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout trying to open socket to ${host}:${port}`);\n    error.code = 'ECONNTIMEOUT';\n    callback(error);\n  }, timeout); //  Return the socket.\n\n  return socket;\n}\n\nfunction checkHttp(socket, params, timeout, callback) {\n  //  Create the HTTP request.\n  const request = `GET ${params.path} HTTP/1.1\nHost: ${params.host}\n\n`;\n  let timer = null;\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout waiting for data from ${params.host}:${params.port}`);\n    error.code = 'EREQTIMEOUT';\n    callback(error);\n  }, timeout); //  Get ready for a response.\n\n  socket.on('data', function (data) {\n    //  Get the response as text.\n    const response = data.toString();\n    const statusLine = response.split('\\n')[0]; //  Stop the timer.\n\n    clearTimeout(timer); //  Check the data. Remember an HTTP response is:\n    //  HTTP/1.1 XXX Stuff\n\n    const statusLineParts = statusLine.split(' ');\n\n    if (statusLineParts < 2 || statusLineParts[1].startsWith('2') === false) {\n      debug(`Invalid HTTP status line: ${statusLine}`);\n      const error = new Error('Invalid response from server');\n      error.code = 'ERESPONSE';\n      callback(error);\n    } //  ALL good!\n\n\n    debug(`Successful HTTP status line: ${statusLine}`);\n    callback();\n  }); //  Send the request.\n\n  socket.write(request);\n} //  This function attempts to open a connection, given a limited time window.\n//  This is the function which we will run repeatedly until we connect.\n\n\nfunction tryConnect(options, timeout) {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = createConnectionWithTimeout(options, timeout, err => {\n        if (err) {\n          if (err.code === 'ECONNREFUSED') {\n            //  We successfully *tried* to connect, so resolve with false so\n            //  that we try again.\n            debug('Socket not open: ECONNREFUSED');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNTIMEOUT') {\n            //  We've successfully *tried* to connect, but we're timing out\n            //  establishing the connection. This is not ideal (either\n            //  the port is open or it ain't).\n            debug('Socket not open: ECONNTIMEOUT');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNRESET') {\n            //  This can happen if the target server kills its connection before\n            //  we can read from it, we can normally just try again.\n            debug('Socket not open: ECONNRESET');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ENOTFOUND') {\n            //  This will occur if the address is not found, i.e. due to a dns\n            //  lookup fail (normally a problem if the domain is wrong).\n            debug('Socket cannot be opened: ENOTFOUND');\n            socket.destroy(); //  If we are going to wait for DNS records, we can actually just try\n            //  again...\n\n            if (options.waitForDns === true) return resolve(false); // ...otherwise, we will explicitly fail with a meaningful error for\n            //  the user.\n\n            return reject(new ConnectionError(`The address '${options.host}' cannot be found`));\n          } //  Trying to open the socket has resulted in an error we don't\n          //  understand. Better give up.\n\n\n          debug(`Unexpected error trying to open socket: ${err}`);\n          socket.destroy();\n          return reject(err);\n        } //  Boom, we connected!\n\n\n        debug('Socket connected!'); //  If we are not dealing with http, we're done.\n\n        if (options.protocol !== 'http') {\n          //  Disconnect, stop the timer and resolve.\n          socket.destroy();\n          return resolve(true);\n        } //  TODO: we should only use the portion of the timeout for this interval which is still left to us.\n        //  Now we've got to wait for a HTTP response.\n\n\n        checkHttp(socket, options, timeout, err => {\n          if (err) {\n            if (err.code === 'EREQTIMEOUT') {\n              debug('HTTP error: EREQTIMEOUT');\n              socket.destroy();\n              return resolve(false);\n            } else if (err.code === 'ERESPONSE') {\n              debug('HTTP error: ERESPONSE');\n              socket.destroy();\n              return resolve(false);\n            }\n\n            debug(`Unexpected error checking http response: ${err}`);\n            socket.destroy();\n            return reject(err);\n          }\n\n          socket.destroy();\n          return resolve(true);\n        });\n      });\n    } catch (err) {\n      //  Trying to open the socket has resulted in an exception we don't\n      //  understand. Better give up.\n      debug(`Unexpected exception trying to open socket: ${err}`);\n      return reject(err);\n    }\n  });\n}\n\nfunction waitPort(params) {\n  return new Promise((resolve, reject) => {\n    const {\n      protocol,\n      host,\n      port,\n      path,\n      interval,\n      timeout,\n      output,\n      waitForDns\n    } = validateParameters(params); //  Keep track of the start time (needed for timeout calcs).\n\n    const startTime = new Date(); //  Don't wait for more than connectTimeout to try and connect.\n\n    const connectTimeout = 1000; //  Grab the object for output.\n\n    const outputFunction = outputFunctions[output];\n    outputFunction.starting({\n      host,\n      port\n    }); //  Start trying to connect.\n\n    const loop = () => {\n      outputFunction.tryConnect();\n      tryConnect({\n        protocol,\n        host,\n        port,\n        path,\n        waitForDns\n      }, connectTimeout).then(open => {\n        debug(`Socket status is: ${open}`); //  The socket is open, we're done.\n\n        if (open) {\n          outputFunction.connected();\n          return resolve(true);\n        } //  If we have a timeout, and we've passed it, we're done.\n\n\n        if (timeout && new Date() - startTime > timeout) {\n          outputFunction.timeout();\n          return resolve(false);\n        } //  Run the loop again.\n\n\n        return setTimeout(loop, interval);\n      }).catch(err => {\n        debug(`Unhandled error occured trying to connect: ${err}`);\n        return reject(err);\n      });\n    }; //  Start the loop.\n\n\n    loop();\n  });\n}\n\nmodule.exports = waitPort;","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/wait-port/lib/wait-port.js"],"names":["debug","require","net","outputFunctions","validateParameters","ConnectionError","createConnectionWithTimeout","host","port","timeout","callback","timer","socket","createConnection","err","clearTimeout","on","error","destroy","setTimeout","Error","code","checkHttp","params","request","path","data","response","toString","statusLine","split","statusLineParts","startsWith","write","tryConnect","options","Promise","resolve","reject","waitForDns","protocol","waitPort","interval","output","startTime","Date","connectTimeout","outputFunction","starting","loop","then","open","connected","catch","module","exports"],"mappings":"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","sourcesContent":["const debug = require('debug')('wait-port');\nconst net = require('net');\nconst outputFunctions = require('./output-functions');\nconst validateParameters = require('./validate-parameters');\nconst ConnectionError = require('./errors/connection-error');\n\nfunction createConnectionWithTimeout({ host, port }, timeout, callback) {\n  //  Variable to hold the timer we'll use to kill the socket if we don't\n  //  connect in time.\n  let timer = null;\n\n  //  Try and open the socket, with the params and callback.\n  const socket = net.createConnection({ host, port }, (err) => {\n    if (!err) clearTimeout(timer);\n    return callback(err);\n  });\n\n  //  TODO: Check for the socket ECONNREFUSED event.\n  socket.on('error', (error) => {\n    debug(`Socket error: ${error}`);\n    clearTimeout(timer);\n    socket.destroy();\n    callback(error);\n  });\n\n  //  Kill the socket if we don't open in time.\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout trying to open socket to ${host}:${port}`);\n    error.code = 'ECONNTIMEOUT';\n    callback(error);\n  }, timeout);\n\n  //  Return the socket.\n  return socket;\n}\n\nfunction checkHttp(socket, params, timeout, callback) {\n  //  Create the HTTP request.\n  const request = \n`GET ${params.path} HTTP/1.1\nHost: ${params.host}\n\n`;\n\n  let timer = null;\n  timer = setTimeout(() => {\n    socket.destroy();\n    const error = new Error(`Timeout waiting for data from ${params.host}:${params.port}`);\n    error.code = 'EREQTIMEOUT';\n    callback(error);\n  }, timeout);\n\n  //  Get ready for a response.\n  socket.on('data', function(data) {\n    //  Get the response as text.\n    const response = data.toString();\n    const statusLine = response.split('\\n')[0];\n\n    //  Stop the timer.\n    clearTimeout(timer);\n\n    //  Check the data. Remember an HTTP response is:\n    //  HTTP/1.1 XXX Stuff\n    const statusLineParts = statusLine.split(' ');\n    if (statusLineParts < 2 || statusLineParts[1].startsWith('2') === false) {\n      debug(`Invalid HTTP status line: ${statusLine}`);\n      const error = new Error('Invalid response from server');\n      error.code = 'ERESPONSE';\n      callback(error);\n    }\n\n    //  ALL good!\n    debug(`Successful HTTP status line: ${statusLine}`);\n    callback();\n  });\n\n  //  Send the request.\n  socket.write(request);\n}\n\n//  This function attempts to open a connection, given a limited time window.\n//  This is the function which we will run repeatedly until we connect.\nfunction tryConnect(options, timeout) {\n  return new Promise((resolve, reject) => {\n    try {\n      const socket = createConnectionWithTimeout(options, timeout, (err) => {\n        if (err) {\n          if (err.code === 'ECONNREFUSED') {\n            //  We successfully *tried* to connect, so resolve with false so\n            //  that we try again.\n            debug('Socket not open: ECONNREFUSED');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNTIMEOUT') {\n            //  We've successfully *tried* to connect, but we're timing out\n            //  establishing the connection. This is not ideal (either\n            //  the port is open or it ain't).\n            debug('Socket not open: ECONNTIMEOUT');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ECONNRESET') {\n            //  This can happen if the target server kills its connection before\n            //  we can read from it, we can normally just try again.\n            debug('Socket not open: ECONNRESET');\n            socket.destroy();\n            return resolve(false);\n          } else if (err.code === 'ENOTFOUND') {\n            //  This will occur if the address is not found, i.e. due to a dns\n            //  lookup fail (normally a problem if the domain is wrong).\n            debug('Socket cannot be opened: ENOTFOUND');\n            socket.destroy();\n\n            //  If we are going to wait for DNS records, we can actually just try\n            //  again...\n            if (options.waitForDns === true) return resolve(false);\n\n            // ...otherwise, we will explicitly fail with a meaningful error for\n            //  the user.\n            return reject(new ConnectionError(`The address '${options.host}' cannot be found`));\n          }\n\n          //  Trying to open the socket has resulted in an error we don't\n          //  understand. Better give up.\n          debug(`Unexpected error trying to open socket: ${err}`);\n          socket.destroy();\n          return reject(err);\n        }\n      \n        //  Boom, we connected!\n        debug('Socket connected!');\n\n        //  If we are not dealing with http, we're done.\n        if (options.protocol !== 'http') {\n          //  Disconnect, stop the timer and resolve.\n          socket.destroy();\n          return resolve(true);\n        }\n\n        //  TODO: we should only use the portion of the timeout for this interval which is still left to us.\n\n        //  Now we've got to wait for a HTTP response.\n        checkHttp(socket, options, timeout, (err) => {\n          if (err) {\n            if (err.code === 'EREQTIMEOUT') {\n              debug('HTTP error: EREQTIMEOUT');\n              socket.destroy();\n              return resolve(false);\n            } else if (err.code === 'ERESPONSE') {\n              debug('HTTP error: ERESPONSE');\n              socket.destroy();\n              return resolve(false);\n            }\n            debug(`Unexpected error checking http response: ${err}`);\n            socket.destroy();\n            return reject(err);\n          }\n\n          socket.destroy();\n          return resolve(true);\n        });\n      });\n    } catch (err) {\n      //  Trying to open the socket has resulted in an exception we don't\n      //  understand. Better give up.\n      debug(`Unexpected exception trying to open socket: ${err}`);\n      return reject(err);\n    }\n  });\n}\n\nfunction waitPort(params) {\n  return new Promise((resolve, reject) => {\n    const {\n      protocol,\n      host,\n      port,\n      path,\n      interval,\n      timeout,\n      output,\n      waitForDns,\n    } = validateParameters(params);\n\n    //  Keep track of the start time (needed for timeout calcs).\n    const startTime = new Date();\n\n    //  Don't wait for more than connectTimeout to try and connect.\n    const connectTimeout = 1000;\n\n    //  Grab the object for output.\n    const outputFunction = outputFunctions[output];\n    outputFunction.starting({ host, port });\n\n    //  Start trying to connect.\n    const loop = () => {\n      outputFunction.tryConnect();\n      tryConnect({ protocol, host, port, path, waitForDns }, connectTimeout)\n        .then((open) => {\n          debug(`Socket status is: ${open}`);\n\n          //  The socket is open, we're done.\n          if (open) {\n            outputFunction.connected();\n            return resolve(true);\n          }\n\n          //  If we have a timeout, and we've passed it, we're done.\n          if (timeout && (new Date() - startTime) > timeout) {\n            outputFunction.timeout();\n            return resolve(false);\n          }\n\n          //  Run the loop again.\n          return setTimeout(loop, interval);\n        })\n        .catch((err) => {\n          debug(`Unhandled error occured trying to connect: ${err}`);\n          return reject(err);\n        });\n    };\n\n    //  Start the loop.\n    loop();\n  });\n}\n\nmodule.exports = waitPort;\n"]},"metadata":{},"sourceType":"script"}