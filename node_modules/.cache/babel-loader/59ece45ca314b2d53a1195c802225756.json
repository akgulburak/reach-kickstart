{"ast":null,"code":"// ****************************************************************************\n// standard library for Javascript users\n// ****************************************************************************\nimport Timeout from 'await-timeout';\nimport ethers from 'ethers';\nimport http from 'http';\nimport url from 'url';\nimport { window, process } from './shim.mjs';\nimport { getConnectorMode } from './ConnectorMode.mjs';\nimport { add, assert, bigNumberify, debug, envDefault, eq, ge, getDEBUG, lt, getViewsHelper, deferContract, makeRandom, argsSplit } from './shared.mjs';\nimport { memoizeThunk, replaceableThunk } from './shared_impl.mjs';\nexport * from './shared.mjs';\nimport { stdlib as compiledStdlib, typeDefs } from './ETH_compiled.mjs';\nimport waitPort from './waitPort.mjs';\n\nfunction isNone(m) {\n  return m.length === 0;\n}\n\nfunction isSome(m) {\n  return !isNone(m);\n}\n\nconst Some = m => [m];\n\nconst None = [];\nvoid isSome;\nconst connectorMode = getConnectorMode(); // Certain functions either behave differently,\n// or are only available on an \"isolated\" network.\n// Note: ETH-browser is NOT considered isolated.\n\nconst isIsolatedNetwork = connectorMode.startsWith('ETH-test-dockerized') || // @ts-ignore\nprocess.env['REACH_ISOLATED_NETWORK'];\nconst networkDesc = connectorMode == 'ETH-test-dockerized-geth' || connectorMode == 'ETH-live' ? {\n  type: 'uri',\n  uri: envDefault(process.env.ETH_NODE_URI, 'http://localhost:8545'),\n  network: envDefault(process.env.ETH_NODE_NETWORK, 'unspecified')\n} : connectorMode == 'ETH-browser' ? {\n  type: 'window'\n} : {\n  type: 'skip'\n};\nconst getPortConnection = memoizeThunk(async () => {\n  debug('getPortConnection');\n\n  if (networkDesc.type != 'uri') {\n    return;\n  }\n\n  await waitPort(networkDesc.uri);\n}); // XXX: doesn't even retry, just returns the first attempt\n\nconst doHealthcheck = async () => {\n  debug('doHealthcheck');\n\n  if (networkDesc.type != 'uri') {\n    return;\n  }\n\n  const uriObj = url.parse(networkDesc.uri); // XXX the code below only supports http\n\n  if (uriObj.protocol !== 'http:') {\n    return;\n  }\n\n  await new Promise((resolve, reject) => {\n    const data = JSON.stringify({\n      jsonrpc: '2.0',\n      method: 'web3_clientVersion',\n      params: [],\n      id: 67\n    });\n    debug('Sending health check request...');\n    const opts = { ...uriObj,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length\n      }\n    };\n    const req = http.request(opts, res => {\n      debug(`statusCode:`, res.statusCode);\n      res.on('data', d => {\n        debug('rpc health check succeeded');\n\n        if (getDEBUG()) {\n          process.stdout.write(d);\n        }\n\n        resolve({\n          res,\n          d\n        });\n      });\n    });\n    req.on('error', e => {\n      console.log('rpc health check failed');\n      console.log(e);\n      reject(e);\n    });\n    req.write(data);\n    debug('attached all the handlers...');\n    req.end();\n    debug('req.end...');\n  });\n};\n\nconst getDevnet = memoizeThunk(async () => {\n  await getPortConnection();\n  return await doHealthcheck();\n});\n/** @description convenience function for drilling down to the actual address */\n\nconst getAddr = async acc => {\n  if (!acc.networkAccount) throw Error(`Expected acc.networkAccount`); // TODO better type design here\n  // @ts-ignore\n\n  if (acc.networkAccount.address) {\n    // @ts-ignore\n    return acc.networkAccount.address;\n  }\n\n  if (acc.networkAccount.getAddress) {\n    return await acc.networkAccount.getAddress();\n  }\n\n  throw Error(`Expected acc.networkAccount.address or acc.networkAccount.getAddress`);\n};\n\nconst rejectInvalidReceiptFor = async (txHash, r) => new Promise((resolve, reject) => !r ? reject(`No receipt for txHash: ${txHash}`) : r.transactionHash !== txHash ? reject(`Bad txHash; ${txHash} !== ${r.transactionHash}`) : !r.status ? reject(`Transaction: ${txHash} was reverted by EVM\\n${r}`) : resolve(r));\n\nconst fetchAndRejectInvalidReceiptFor = async txHash => {\n  const provider = await getProvider();\n  const r = await provider.getTransactionReceipt(txHash);\n  return await rejectInvalidReceiptFor(txHash, r);\n};\n\nconst [getProvider, setProvider] = replaceableThunk(async () => {\n  if (networkDesc.type == 'uri') {\n    await getDevnet();\n    const provider = new ethers.providers.JsonRpcProvider(networkDesc.uri);\n    provider.pollingInterval = 500; // ms\n\n    return provider;\n  } else if (networkDesc.type == 'window') {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(window.ethereum); // The proper way to ask MetaMask to enable itself is eth_requestAccounts\n      // https://eips.ethereum.org/EIPS/eip-1102\n\n      await provider.send('eth_requestAccounts', []);\n      return provider;\n    } else {\n      throw Error(`window.ethereum is not defined`);\n    }\n  } else {\n    // This lib was imported, but not for its net connection.\n    throw Error(`Using stdlib/ETH is incompatible with REACH_CONNECTOR_MODE=${connectorMode}`);\n  }\n});\n\nconst getNetworkTimeNumber = async () => {\n  const provider = await getProvider();\n  return await provider.getBlockNumber();\n};\n\nconst fastForwardTo = async (targetTime, onProgress) => {\n  // console.log(`>>> FFWD TO: ${targetTime}`);\n  const onProg = onProgress || (() => {});\n\n  requireIsolatedNetwork('fastForwardTo');\n  let currentTime;\n\n  while (lt(currentTime = await getNetworkTime(), targetTime)) {\n    onProg({\n      currentTime,\n      targetTime\n    });\n    await stepTime();\n  } // Also report progress at completion time\n\n\n  onProg({\n    currentTime,\n    targetTime\n  }); // console.log(`<<< FFWD TO: ${targetTime} complete. It's ${currentTime}`);\n\n  return currentTime;\n};\n\nconst requireIsolatedNetwork = label => {\n  if (!isIsolatedNetwork) {\n    throw Error(`Invalid operation ${label} in REACH_CONNECTOR_MODE=${connectorMode}`);\n  }\n};\n\nconst initOrDefaultArgs = init => ({\n  argsMay: init ? Some(init.args) : None,\n  value: init ? init.value : bigNumberify(0)\n}); // onProgress callback is optional, it will be given an obj\n// {currentTime, targetTime}\n\n\nconst actuallyWaitUntilTime = async (targetTime, onProgress) => {\n  const onProg = onProgress || (() => {});\n\n  const provider = await getProvider();\n  return await new Promise(resolve => {\n    const onBlock = async currentTimeNum => {\n      const currentTime = bigNumberify(currentTimeNum); // Does not block on the progress fn if it is async\n\n      onProg({\n        currentTime,\n        targetTime\n      });\n\n      if (ge(currentTime, targetTime)) {\n        provider.off('block', onBlock);\n        resolve(currentTime);\n      }\n    };\n\n    provider.on('block', onBlock); // Also \"re-emit\" the current block\n    // Note: this sometimes causes the starting block\n    // to be processed twice, which should be harmless.\n\n    getNetworkTime().then(onBlock);\n  });\n};\n\nconst getDummyAccount = memoizeThunk(async () => {\n  const provider = await getProvider();\n  const networkAccount = ethers.Wallet.createRandom().connect(provider);\n  const acc = await connectAccount(networkAccount);\n  return acc;\n});\n\nconst stepTime = async () => {\n  requireIsolatedNetwork('stepTime');\n  const faucet = await getFaucet();\n  const acc = await getDummyAccount();\n  return await transfer(faucet, acc, parseCurrency(0));\n}; // ****************************************************************************\n// Common Interface Exports\n// ****************************************************************************\n\n\nexport const {\n  addressEq,\n  digest\n} = compiledStdlib;\nexport const {\n  T_Null,\n  T_Bool,\n  T_UInt,\n  T_Tuple,\n  T_Array,\n  T_Object,\n  T_Data,\n  T_Bytes,\n  T_Address,\n  T_Digest,\n  T_Struct\n} = typeDefs;\nexport const {\n  randomUInt,\n  hasRandom\n} = makeRandom(32);\nexport { getProvider, setProvider }; // TODO\n\nexport function setProviderByEnv(env) {\n  void env;\n  throw Error(`setProviderByEnv not yet supported on ETH`);\n} // TODO\n\nexport function setProviderByName(providerName) {\n  void providerName;\n  throw Error(`setProviderByName not yet supported on ETH`);\n} // TODO\n\nexport function providerEnvByName(providerName) {\n  void providerName;\n  throw Error(`providerEnvByName not yet supported on ETH`);\n}\nexport const balanceOf = async acc => {\n  const {\n    networkAccount\n  } = acc;\n  if (!networkAccount) throw Error(`acc.networkAccount missing. Got: ${acc}`);\n\n  if (networkAccount.getBalance) {\n    return bigNumberify(await networkAccount.getBalance());\n  }\n\n  const addr = await getAddr(acc);\n\n  if (addr) {\n    const provider = await getProvider();\n    return bigNumberify(await provider.getBalance(addr));\n  }\n\n  throw Error(`address missing. Got: ${networkAccount}`);\n};\n\nconst doTxn = async (dhead, tp) => {\n  debug({ ...dhead,\n    step: `pre call`\n  });\n  const rt = await tp;\n  debug({ ...dhead,\n    rt,\n    step: `pre wait`\n  });\n  const rm = await rt.wait();\n  debug({ ...dhead,\n    rt,\n    rm,\n    step: `pre receipt`\n  });\n  assert(rm !== null, `receipt wait null`);\n  const ro = await fetchAndRejectInvalidReceiptFor(rm.transactionHash);\n  debug({ ...dhead,\n    rt,\n    rm,\n    ro,\n    step: `post receipt`\n  }); // ro's blockNumber might be interesting\n\n  void ro;\n};\n\nconst doCall = async (dhead, ctc, funcName, args, value, gasLimit) => {\n  const dpre = { ...dhead,\n    funcName,\n    args,\n    value\n  };\n  debug({ ...dpre,\n    step: `pre call`\n  });\n  return await doTxn(dpre, ctc[funcName](...args, {\n    value,\n    gasLimit\n  }));\n};\n/** @description Arg order follows \"src before dst\" convention */\n\n\nexport const transfer = async (from, to, value, token = false) => {\n  const sender = from.networkAccount;\n  const receiver = getAddr(to);\n  const valueb = bigNumberify(value);\n  const dhead = {\n    kind: 'transfer'\n  };\n\n  if (!token) {\n    const txn = {\n      to: receiver,\n      value: valueb\n    };\n    debug('sender.sendTransaction(', txn, ')');\n    return await doTxn(dhead, sender.sendTransaction(txn));\n  } else {\n    const tokCtc = new ethers.Contract(token, ERC20_ABI, sender);\n    return await doCall(dhead, tokCtc, 'transfer', [receiver, valueb], bigNumberify(0), undefined);\n  }\n};\nconst ERC20_ABI = [{\n  'constant': false,\n  'inputs': [{\n    'name': '_spender',\n    'type': 'address'\n  }, {\n    'name': '_value',\n    'type': 'uint256'\n  }],\n  'name': 'approve',\n  'outputs': [{\n    'name': '',\n    'type': 'bool'\n  }],\n  'payable': false,\n  'stateMutability': 'nonpayable',\n  'type': 'function'\n}, {\n  'constant': true,\n  'inputs': [{\n    'name': 'account',\n    'type': 'address'\n  }],\n  'name': 'balanceOf',\n  'outputs': [{\n    'name': '',\n    'type': 'uint256'\n  }],\n  'payable': false,\n  'stateMutability': 'view',\n  'type': 'function'\n}, {\n  'constant': false,\n  'inputs': [{\n    'name': '_recipient',\n    'type': 'address'\n  }, {\n    'name': '_amount',\n    'type': 'uint256'\n  }],\n  'name': 'transfer',\n  'outputs': [{\n    'name': '',\n    'type': 'bool'\n  }],\n  'payable': false,\n  'stateMutability': 'nonpayable',\n  'type': 'function'\n}];\nexport const connectAccount = async networkAccount => {\n  // @ts-ignore // TODO\n  if (networkAccount.getAddress && !networkAccount.address) {\n    // @ts-ignore\n    networkAccount.address = await getAddr({\n      networkAccount\n    });\n  } // XXX networkAccount MUST be a Wallet or Signer to deploy/attach\n\n\n  const provider = await getProvider();\n  const address = await getAddr({\n    networkAccount\n  });\n\n  if (!address) {\n    throw Error(`Expected networkAccount.address: ${networkAccount}`);\n  }\n\n  const shad = address.substring(2, 6);\n  let label = shad;\n\n  const iam = some_addr => {\n    if (some_addr == address) {\n      return address;\n    } else {\n      throw Error(`I should be ${some_addr}, but am ${address}`);\n    }\n  };\n\n  const selfAddress = () => {\n    return address;\n  };\n\n  let gasLimit;\n\n  const setGasLimit = ngl => {\n    gasLimit = bigNumberify(ngl);\n  };\n\n  const deploy = bin => {\n    if (!ethers.Signer.isSigner(networkAccount)) {\n      throw Error(`Signer required to deploy, ${networkAccount}`);\n    }\n\n    const {\n      infoP,\n      resolveInfo\n    } = (() => {\n      let resolveInfo = info => {\n        void info;\n      };\n\n      const infoP = new Promise(resolve => {\n        resolveInfo = resolve;\n      });\n      return {\n        infoP,\n        resolveInfo\n      };\n    })();\n\n    const performDeploy = init => {\n      debug(shad, ': performDeploy with', init);\n      const {\n        argsMay,\n        value\n      } = initOrDefaultArgs(init);\n      const {\n        ABI,\n        Bytecode\n      } = bin._Connectors.ETH;\n      debug(shad, ': making contract factory');\n      const factory = new ethers.ContractFactory(ABI, Bytecode, networkAccount);\n\n      (async () => {\n        debug(shad, `: deploying factory`);\n        const contract = await factory.deploy(...argsMay, {\n          value,\n          gasLimit\n        });\n        debug(shad, `: deploying factory; done:`, contract.address);\n        debug(shad, `: waiting for receipt:`, contract.deployTransaction.hash);\n        const deploy_r = await contract.deployTransaction.wait();\n        debug(shad, `: got receipt;`, deploy_r.blockNumber);\n        const info = {\n          address: contract.address,\n          creation_block: deploy_r.blockNumber,\n          transactionHash: deploy_r.transactionHash,\n          init\n        };\n        resolveInfo(info);\n      })();\n\n      return attach(bin, infoP);\n    };\n\n    const attachDeferDeploy = () => {\n      let setImpl;\n      const implP = new Promise(resolve => {\n        setImpl = resolve;\n      });\n      const implNow = {\n        stdlib: compiledStdlib,\n        sendrecv: async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay, sim_p) => {\n          debug(shad, `:`, label, 'sendrecv m', funcNum, `(deferred deploy)`);\n          void evt_cnt;\n          void sim_p; // TODO: munge/unmunge roundtrip?\n\n          void hasLastTime;\n          void tys;\n          void out_tys;\n          const [value, toks] = pay; // The following must be true for the first sendrecv.\n\n          try {\n            assert(onlyIf, `verifyContract: onlyIf must be true`);\n            assert(soloSend, `verifyContract: soloSend must be true`);\n            assert(eq(funcNum, 1), `verifyContract: funcNum must be 1`);\n            assert(!timeout_delay, `verifyContract: no timeout`);\n            assert(toks.length == 0, `verifyContract: no tokens`);\n          } catch (e) {\n            throw Error(`impossible: Deferred deploy sendrecv assumptions violated.\\n${e}`);\n          } // shim impl is replaced with real impl\n\n\n          setImpl(performDeploy({\n            args: [[0], args],\n            value\n          }));\n          await infoP; // Wait for the deploy to actually happen.\n          // simulated recv\n\n          return await impl.recv(funcNum, evt_cnt, out_tys, false, timeout_delay);\n        }\n      };\n      const impl = deferContract(true, implP, implNow);\n      return impl;\n    };\n\n    switch (bin._Connectors.ETH.deployMode) {\n      case 'DM_firstMsg':\n        return attachDeferDeploy();\n\n      case 'DM_constructor':\n        return performDeploy();\n\n      default:\n        throw Error(`Unrecognized deployMode: ${bin._Connectors.ETH.deployMode}`);\n    }\n  };\n\n  const attach = (bin, infoP) => {\n    // unofficially: infoP can also be Contract\n    // This should be considered deprecated\n    // TODO: remove at next Reach version bump?\n    // @ts-ignore\n    if (infoP.getInfo) {\n      console.log(`Calling attach with another Contract is deprecated.` + ` Please replace accBob.attach(backend, ctcAlice)` + ` with accBob.attach(bin, ctcAlice.getInfo())`); // @ts-ignore\n\n      infoP = infoP.getInfo();\n    }\n\n    const ABI = JSON.parse(bin._Connectors.ETH.ABI); // Attached state\n\n    const {\n      getLastBlock,\n      setLastBlock\n    } = (() => {\n      let lastBlock = null;\n\n      const setLastBlock = n => {\n        debug(`lastBlock from`, lastBlock, `to`, n);\n        lastBlock = n;\n      };\n\n      const getLastBlock = async () => {\n        if (typeof lastBlock === 'number') {\n          return lastBlock;\n        }\n\n        const info = await infoP;\n        setLastBlock(info.creation_block);\n        return info.creation_block;\n      };\n\n      return {\n        getLastBlock,\n        setLastBlock\n      };\n    })();\n\n    const updateLast = o => {\n      if (!o.blockNumber) {\n        console.log(o);\n        throw Error(`Expected blockNumber in ${Object.keys(o)}`);\n      }\n\n      setLastBlock(o.blockNumber);\n    };\n\n    const getC = (() => {\n      let _ethersC = null;\n      return async () => {\n        if (_ethersC) {\n          return _ethersC;\n        }\n\n        const info = await infoP;\n        await verifyContract(info, bin);\n        debug(shad, `: contract verified`);\n\n        if (!ethers.Signer.isSigner(networkAccount)) {\n          throw Error(`networkAccount must be a Signer (read: Wallet). ${networkAccount}`);\n        }\n\n        _ethersC = new ethers.Contract(info.address, ABI, networkAccount);\n        return _ethersC;\n      };\n    })();\n\n    const callC = async (dhead, funcName, arg, pay) => {\n      const [value, toks] = pay;\n      const ethersC = await getC();\n      const zero = bigNumberify(0);\n\n      const actualCall = async () => await doCall({ ...dhead,\n        kind: 'reach'\n      }, ethersC, funcName, [arg], value, gasLimit);\n\n      const callTok = async (tok, amt) => {\n        // @ts-ignore\n        const tokCtc = new ethers.Contract(tok, ERC20_ABI, networkAccount);\n        const tokBalance = await tokCtc['balanceOf'](address);\n        debug({ ...dhead,\n          kind: 'token'\n        }, 'balanceOf', tokBalance);\n        assert(tokBalance >= amt, `local account token balance insufficient: ${tokBalance} < ${amt}`);\n        await doCall({ ...dhead,\n          kind: 'token'\n        }, tokCtc, 'approve', [ethersC.address, amt], zero, gasLimit);\n      };\n\n      const maybePayTok = async i => {\n        if (i < toks.length) {\n          const [amt, tok] = toks[i];\n          await callTok(tok, amt);\n\n          try {\n            await maybePayTok(i + 1);\n          } catch (e) {\n            await callTok(tok, zero);\n            throw e;\n          }\n        } else {\n          await actualCall();\n        }\n      };\n\n      await maybePayTok(0);\n    };\n\n    const getEventData = async (ok_evt, ok_e) => {\n      const ethersC = await getC();\n      const ok_args_abi = ethersC.interface.getEvent(ok_evt).inputs;\n      const {\n        args\n      } = ethersC.interface.parseLog(ok_e);\n      return ok_args_abi.map(a => args[a.name]);\n    };\n\n    const getLogs = async (fromBlock, toBlock, ok_evt) => {\n      if (fromBlock > toBlock) {\n        return [];\n      }\n\n      const ethersC = await getC();\n      return await provider.getLogs({\n        fromBlock,\n        toBlock,\n        address: ethersC.address,\n        topics: [ethersC.interface.getEventTopic(ok_evt)]\n      });\n    };\n\n    const getInfo = async () => await infoP;\n\n    const sendrecv_impl = async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay) => {\n      void hasLastTime;\n\n      const doRecv = async waitIfNotPresent => await recv_impl(funcNum, out_tys, waitIfNotPresent, timeout_delay);\n\n      if (!onlyIf) {\n        return await doRecv(true);\n      }\n\n      const funcName = `m${funcNum}`;\n\n      if (tys.length !== args.length) {\n        throw Error(`tys.length (${tys.length}) !== args.length (${args.length})`);\n      }\n\n      const dhead = [shad, label, 'send', funcName, timeout_delay, 'SEND'];\n      debug([...dhead, 'ARGS', args]);\n      const [args_svs, args_msg] = argsSplit(args, evt_cnt);\n      const [tys_svs, tys_msg] = argsSplit(tys, evt_cnt); // @ts-ignore XXX\n\n      const arg_ty = T_Tuple([T_Tuple(tys_svs), T_Tuple(tys_msg)]);\n      const arg = arg_ty.munge([args_svs, args_msg]);\n      debug([...dhead, 'START', arg]);\n      const lastBlock = await getLastBlock();\n      let block_send_attempt = lastBlock;\n      let block_repeat_count = 0;\n\n      while (!timeout_delay || lt(block_send_attempt, add(lastBlock, timeout_delay))) {\n        debug([...dhead, 'TRY']);\n\n        try {\n          debug([...dhead, 'ARG', arg, pay]);\n          await callC(dhead, funcName, arg, pay);\n        } catch (e) {\n          if (!soloSend) {\n            debug([...dhead, `SKIPPING`, e]);\n          } else {\n            debug([...dhead, `ERROR`, e.stack]); // XXX What should we do...? If we fail, but there's no timeout delay... then we should just die\n\n            await Timeout.set(1);\n            const current_block = await getNetworkTimeNumber();\n\n            if (current_block == block_send_attempt) {\n              block_repeat_count++;\n            }\n\n            block_send_attempt = current_block;\n\n            if (\n            /* timeout_delay && */\n            block_repeat_count > 32) {\n              if (e.code === 'UNPREDICTABLE_GAS_LIMIT') {\n                let error = e;\n\n                while (error.error) {\n                  error = error.error;\n                }\n\n                console.log(`impossible: The message you are trying to send appears to be invalid.`);\n                console.log(error);\n              }\n\n              console.log(`args:`);\n              console.log(arg);\n              throw Error(`${dhead} REPEAT @ ${block_send_attempt} x ${block_repeat_count}`);\n            }\n\n            debug([...dhead, `TRY FAIL`, lastBlock, current_block, block_repeat_count, block_send_attempt]);\n            continue;\n          }\n        }\n\n        return await doRecv(false);\n      } // XXX If we were trying to join, but we got sniped, then we'll\n      // think that there is a timeout and then we'll wait forever for\n      // the timeout message.\n\n\n      debug([...dhead, `FAIL/TIMEOUT`]);\n      return {\n        didTimeout: true\n      };\n    };\n\n    const sendrecv = async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay, sim_p) => {\n      void sim_p;\n      return await sendrecv_impl(funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay);\n    }; // https://docs.ethers.io/ethers.js/html/api-contract.html#configuring-events\n\n\n    const recv_impl = async (okNum, out_tys, waitIfNotPresent, timeout_delay) => {\n      const isFirstMsgDeploy = okNum == 1 && bin._Connectors.ETH.deployMode == 'DM_firstMsg';\n      const lastBlock = await getLastBlock();\n      const ok_evt = `e${okNum}`;\n      debug(shad, ':', label, 'recv', ok_evt, timeout_delay, `--- START`); // look after the last block\n\n      const block_poll_start_init = lastBlock + (isFirstMsgDeploy ? 0 : 1);\n      let block_poll_start = block_poll_start_init;\n      let block_poll_end = block_poll_start;\n\n      while (!timeout_delay || lt(block_poll_start, add(lastBlock, timeout_delay))) {\n        debug(shad, ':', label, 'recv', ok_evt, `--- GET`, block_poll_start, block_poll_end);\n        const es = await getLogs(block_poll_start, block_poll_end, ok_evt);\n\n        if (es.length == 0) {\n          debug(shad, ':', label, 'recv', ok_evt, timeout_delay, `--- RETRY`);\n          block_poll_start = block_poll_end;\n          await Timeout.set(1);\n          block_poll_end = await getNetworkTimeNumber();\n\n          if (waitIfNotPresent && block_poll_start == block_poll_end) {\n            await waitUntilTime(bigNumberify(block_poll_end + 1));\n          }\n\n          if (block_poll_start <= lastBlock) {\n            block_poll_start = block_poll_start_init;\n          }\n\n          continue;\n        } else {\n          debug(shad, ':', label, 'recv', ok_evt, timeout_delay, `--- OKAY`);\n          const ok_e = es[0];\n          const ok_r = await fetchAndRejectInvalidReceiptFor(ok_e.transactionHash);\n          void ok_r;\n          const ok_t = await provider.getTransaction(ok_e.transactionHash); // The .gas field doesn't exist on this anymore, apparently?\n          // debug(`${ok_evt} gas was ${ok_t.gas} ${ok_t.gasPrice}`);\n\n          if (ok_t.blockNumber) {\n            assert(ok_t.blockNumber == ok_r.blockNumber, 'recept & transaction block numbers should match');\n\n            if (ok_e.blockNumber) {\n              assert(ok_t.blockNumber == ok_e.blockNumber, 'event & transaction block numbers should match');\n            }\n          } else {\n            // XXX For some reason ok_t sometimes doesn't have blockNumber\n            console.log(`WARNING: no blockNumber on transaction.`);\n            console.log(ok_t);\n          }\n\n          debug(shad, ':', label, 'recv', ok_evt, `--- AT`, ok_r.blockNumber);\n          updateLast(ok_r);\n          const ok_ed = await getEventData(ok_evt, ok_e);\n          debug(shad, ':', label, 'recv', ok_evt, `--- DATA --`, ok_ed);\n          const ok_vals = ok_ed[0][1];\n          debug(shad, ':', label, 'recv', ok_evt, `--- MSG --`, ok_vals);\n          const data = T_Tuple(out_tys).unmunge(ok_vals);\n\n          const getLog = async (l_evt, l_ctc) => {\n            let dhead = [shad, label, 'recv', ok_evt, '--- getLog', l_evt, l_ctc];\n            debug(dhead);\n            const theBlock = ok_r.blockNumber;\n            const l_e = (await getLogs(theBlock, theBlock, l_evt))[0];\n            dhead = [...dhead, 'log', l_e];\n            debug(dhead);\n            const l_ed = (await getEventData(l_evt, l_e))[0];\n            dhead = [...dhead, 'data', l_ed];\n            debug(dhead);\n            const l_edu = l_ctc.unmunge(l_ed);\n            dhead = [...dhead, 'unmunge', l_edu];\n            debug(dhead);\n            return l_edu;\n          };\n\n          const getOutput = (o_lab, o_ctc) => getLog(`oe_${o_lab}`, o_ctc);\n\n          debug(`${shad}: ${label} recv ${ok_evt} ${timeout_delay} --- OKAY --- ${JSON.stringify(ok_vals)}`);\n          const {\n            from\n          } = ok_t;\n          return {\n            data,\n            getOutput,\n            from,\n            didTimeout: false,\n            time: bigNumberify(ok_r.blockNumber)\n          };\n        }\n      }\n\n      debug(shad, ':', label, 'recv', ok_evt, timeout_delay, '--- TIMEOUT');\n      return {\n        didTimeout: true\n      };\n    };\n\n    const recv = async (okNum, ok_cnt, out_tys, waitIfNotPresent, timeout_delay) => {\n      void ok_cnt;\n      return await recv_impl(okNum, out_tys, waitIfNotPresent, timeout_delay);\n    };\n\n    const wait = async delta => {\n      const lastBlock = await getLastBlock(); // Don't wait from current time, wait from last_block\n\n      debug('=====Waiting', delta, 'from', lastBlock, ':', address);\n      const p = await waitUntilTime(add(lastBlock, delta));\n      debug('=====Done waiting', delta, 'from', lastBlock, ':', address);\n      return p;\n    };\n\n    const creationTime = async () => bigNumberify((await getInfo()).creation_block);\n\n    const views_bin = bin._getViews({\n      reachStdlib: compiledStdlib\n    });\n\n    const views_namesm = bin._Connectors.ETH.views;\n\n    const getView1 = (vs, v, k, vim) => async () => {\n      void vs;\n      const {\n        ty\n      } = vim;\n      const ethersC = await getC();\n      const vkn = views_namesm[v][k];\n      const val = await ethersC[vkn]();\n      return ty.unmunge(val);\n    };\n\n    const getViews = getViewsHelper(views_bin, getView1); // Note: wait is the local one not the global one of the same name.\n\n    return {\n      getInfo,\n      creationTime,\n      sendrecv,\n      recv,\n      wait,\n      iam,\n      selfAddress,\n      getViews,\n      stdlib: compiledStdlib\n    };\n  };\n\n  function setDebugLabel(newLabel) {\n    label = newLabel; // @ts-ignore\n\n    return this;\n  }\n\n  return {\n    deploy,\n    attach,\n    networkAccount,\n    setGasLimit,\n    getAddress: selfAddress,\n    stdlib: compiledStdlib,\n    setDebugLabel\n  };\n};\nexport const newAccountFromSecret = async secret => {\n  const provider = await getProvider();\n  const networkAccount = new ethers.Wallet(secret).connect(provider);\n  const acc = await connectAccount(networkAccount);\n  return acc;\n};\nexport const newAccountFromMnemonic = async phrase => {\n  const provider = await getProvider();\n  const networkAccount = ethers.Wallet.fromMnemonic(phrase).connect(provider);\n  const acc = await connectAccount(networkAccount);\n  return acc;\n};\nexport const getDefaultAccount = async () => {\n  debug(`getDefaultAccount`);\n\n  if (isIsolatedNetwork || networkDesc.type == 'window') {\n    const provider = await getProvider(); // TODO: teach ts what the specialized type of provider is in this branch\n    // @ts-ignore\n\n    const signer = provider.getSigner();\n    return await connectAccount(signer);\n  }\n\n  throw Error(`Default account not available for REACH_CONNECTOR_MODE=${connectorMode}`);\n}; // TODO: Should users be able to access this directly?\n// TODO: define a faucet on Ropsten & other testnets?\n\nexport const [getFaucet, setFaucet] = replaceableThunk(async () => {\n  // XXX this may break if users call setProvider?\n  if (isIsolatedNetwork) {\n    // On isolated networks, the default account is assumed to be the faucet.\n    // Furthermore, it is assumed that the faucet Signer is \"unlocked\",\n    // so no further secrets need be provided in order to access its funds.\n    // This is true of reach-provided devnets.\n    // TODO: allow the user to set the faucet via mnemnonic.\n    return await getDefaultAccount();\n  } else if (networkDesc.type === 'window') {\n    // @ts-ignore // 0x539 = 1337\n    if (window.ethereum.chainId === '0xNaN' || window.ethereum.chainId == '0x539') {\n      // XXX this is a hacky way of checking if we're on a devnet\n      // XXX only localhost:8545 is supported\n      const p = new ethers.providers.JsonRpcProvider('http://localhost:8545');\n      return await connectAccount(p.getSigner());\n    }\n  }\n\n  throw Error(`getFaucet not supported in this context.`);\n});\nexport const createAccount = async () => {\n  debug(`createAccount with 0 balance.`);\n  const provider = await getProvider();\n  const networkAccount = ethers.Wallet.createRandom().connect(provider);\n  return await connectAccount(networkAccount);\n};\nexport const fundFromFaucet = async (account, value) => {\n  const faucet = await getFaucet();\n  await transfer(faucet, account, value);\n};\nexport const newTestAccount = async startingBalance => {\n  debug('newTestAccount(', startingBalance, ')');\n  requireIsolatedNetwork('newTestAccount');\n  const acc = await createAccount();\n  const to = await getAddr(acc);\n\n  try {\n    debug('newTestAccount awaiting transfer:', to);\n    await fundFromFaucet(acc, startingBalance);\n    debug('newTestAccount got transfer:', to);\n    return acc;\n  } catch (e) {\n    console.log(`newTestAccount: Trouble with account ${to}`);\n    throw e;\n  }\n};\nexport const getNetworkTime = async () => {\n  return bigNumberify(await getNetworkTimeNumber());\n}; // onProgress callback is optional, it will be given an obj\n// {currentTime, targetTime}\n\nexport const wait = async (delta, onProgress) => {\n  const now = await getNetworkTime();\n  return await waitUntilTime(add(now, delta), onProgress);\n}; // onProgress callback is optional, it will be given an obj\n// {currentTime, targetTime}\n\nexport const waitUntilTime = async (targetTime, onProgress) => {\n  targetTime = bigNumberify(targetTime);\n\n  if (isIsolatedNetwork) {\n    return await fastForwardTo(targetTime, onProgress);\n  } else {\n    return await actuallyWaitUntilTime(targetTime, onProgress);\n  }\n}; // Check the contract info and the associated deployed bytecode;\n// Verify that:\n// * it matches the bytecode you are expecting.\n// * it was deployed at exactly creation_block.\n// Throws an Error if any verifications fail\n\nexport const verifyContract = async (ctcInfo, backend) => {\n  const {\n    ABI,\n    Bytecode\n  } = backend._Connectors.ETH;\n  const {\n    address,\n    creation_block,\n    init\n  } = ctcInfo;\n  const {\n    argsMay\n  } = initOrDefaultArgs(init);\n  const factory = new ethers.ContractFactory(ABI, Bytecode);\n  debug('verifyContract:', address);\n  debug(ctcInfo);\n  const provider = await getProvider();\n  const now = await getNetworkTimeNumber();\n  const deployEvent = isNone(argsMay) ? 'e0' : 'e1';\n  debug('verifyContract: checking logs for', deployEvent, '...'); // https://docs.ethers.io/v5/api/providers/provider/#Provider-getLogs\n  // \"Keep in mind that many backends will discard old events\"\n  // TODO: find another way to validate creation block if much time has passed?\n\n  const logs = await provider.getLogs({\n    fromBlock: creation_block,\n    toBlock: now,\n    address: address,\n    topics: [factory.interface.getEventTopic(deployEvent)]\n  });\n\n  if (logs.length < 1) {\n    throw Error(`Contract was claimed to be deployed at ${creation_block},` + ` but the current block is ${now} and it hasn't been deployed yet.`);\n  }\n\n  const log = logs[0];\n\n  if (log.blockNumber !== creation_block) {\n    throw Error(`Contract was deployed at blockNumber ${log.blockNumber},` + ` but was claimed to be deployed at ${creation_block}.`);\n  }\n\n  debug(`verifyContract: checking code...`); // https://docs.ethers.io/v5/api/providers/provider/#Provider-getCode\n  // We can safely getCode at the current block;\n  // Reach programs don't change their ETH code over time.\n\n  const actual = await provider.getCode(address); // XXX should this also pass {value}, like factory.deploy() does?\n\n  const deployData = factory.getDeployTransaction(...argsMay).data;\n\n  if (typeof deployData !== 'string') {\n    // TODO: could also be Ethers.utils.bytes, apparently? Or undefined... why?\n    throw Error(`Impossible: deployData is not string ${deployData}`);\n  }\n\n  if (!deployData.startsWith(backend._Connectors.ETH.Bytecode)) {\n    throw Error(`Impossible: contract with args is not prefixed by backend Bytecode`);\n  } // FIXME this is based on empirical observation, feels hacky\n  // deployData looks like this: [init][setup][body][teardown]\n  // actual looks like this:     [init][body]\n  // XXX the labels \"init\", \"setup\", and \"teardown\" are probably misleading\n  // FIXME: for 0-arg contract deploys, it appears that:\n  // * \"init\" is of length 13\n  // * \"setup\" is not consistent in content, but is of length 156\n  // * \"teardown\" is of length 0\n  // FIXME: for n-arg contract deploys, it appears that:\n  // * \"init\" is of length 13\n  // * \"setup\" is of length >= 0 (and probably >= 156)\n  // * \"teardown\" is of length >= 0\n\n\n  const initLen = 13;\n  const setupLen = 156;\n  const expected = deployData.slice(0, initLen) + deployData.slice(initLen + setupLen);\n\n  if (expected.length <= 0) {\n    throw Error(`Impossible: contract expectation is empty`);\n  }\n\n  if (actual !== expected) {\n    // FIXME: Empirical observation says that 0-arg contract deploys\n    // should === expected. However, this is fragile (?), so it's ok\n    // to only pass the next check.\n    // FIXME: the 13-char header is also fragile, but we're just\n    // running with that assumption for now.\n    const deployNoInit = deployData.slice(initLen);\n    const actualNoInit = actual.slice(initLen);\n\n    if (actualNoInit.length === 0 || !deployNoInit.includes(actualNoInit)) {\n      // FIXME: this display is not so helful for the n-arg contract deploy case.\n      const displayLen = 60;\n      console.log('--------------------------------------------');\n      console.log('expected start: ' + expected.slice(0, displayLen));\n      console.log('actual   start: ' + actual.slice(0, displayLen));\n      console.log('--------------------------------------------');\n      console.log('expected   end: ' + expected.slice(expected.length - displayLen));\n      console.log('actual     end: ' + actual.slice(actual.length - displayLen));\n      console.log('--------------------------------------------');\n      console.log('expected   len: ' + expected.length);\n      console.log('actual     len: ' + actual.length);\n      console.log('--------------------------------------------');\n      throw Error(`Contract bytecode does not match expected bytecode.`);\n    }\n  } // We are not checking the balance or the contract storage, because we know\n  // that the code is correct and we know that the code mandates the way that\n  // those things are initialized\n\n\n  return true;\n};\n/** @description the display name of the standard unit of currency for the network */\n\nexport const standardUnit = 'ETH';\n/** @description the display name of the atomic (smallest) unit of currency for the network */\n\nexport const atomicUnit = 'WEI';\n/**\n * @description  Parse currency by network\n * @param amt  value in the {@link standardUnit} for the network.\n * @returns  the amount in the {@link atomicUnit} of the network.\n * @example  parseCurrency(100).toString() // => '100000000000000000000'\n */\n\nexport function parseCurrency(amt) {\n  return bigNumberify(ethers.utils.parseUnits(amt.toString(), 'ether'));\n}\nexport const minimumBalance = parseCurrency(0);\n/**\n * @description  Format currency by network\n * @param amt  the amount in the {@link atomicUnit} of the network.\n * @param decimals  up to how many decimal places to display in the {@link standardUnit}.\n *   Trailing zeroes will be omitted. Excess decimal places will be truncated. (not rounded)\n *   This argument defaults to maximum precision.\n * @returns  a string representation of that amount in the {@link standardUnit} for that network.\n * @example  formatCurrency(bigNumberify('100000000000000000000')); // => '100'\n */\n\nexport function formatCurrency(amt, decimals = 18) {\n  // Recall that 1 WEI = 10e18 ETH\n  if (!(Number.isInteger(decimals) && 0 <= decimals)) {\n    throw Error(`Expected decimals to be a nonnegative integer, but got ${decimals}.`);\n  } // Truncate\n\n\n  decimals = Math.min(decimals, 18);\n  const decimalsToForget = 18 - decimals;\n  const divAmt = bigNumberify(amt).div(bigNumberify(10).pow(decimalsToForget));\n  const amtStr = ethers.utils.formatUnits(divAmt, decimals); // If the str ends with .0, chop it off\n\n  if (amtStr.slice(amtStr.length - 2) == '.0') {\n    return amtStr.slice(0, amtStr.length - 2);\n  } else {\n    return amtStr;\n  }\n}\nexport const reachStdlib = compiledStdlib;","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/@reach-sh/stdlib/ETH.mjs"],"names":["Timeout","ethers","http","url","window","process","getConnectorMode","add","assert","bigNumberify","debug","envDefault","eq","ge","getDEBUG","lt","getViewsHelper","deferContract","makeRandom","argsSplit","memoizeThunk","replaceableThunk","stdlib","compiledStdlib","typeDefs","waitPort","isNone","m","length","isSome","Some","None","connectorMode","isIsolatedNetwork","startsWith","env","networkDesc","type","uri","ETH_NODE_URI","network","ETH_NODE_NETWORK","getPortConnection","doHealthcheck","uriObj","parse","protocol","Promise","resolve","reject","data","JSON","stringify","jsonrpc","method","params","id","opts","headers","req","request","res","statusCode","on","d","stdout","write","e","console","log","end","getDevnet","getAddr","acc","networkAccount","Error","address","getAddress","rejectInvalidReceiptFor","txHash","r","transactionHash","status","fetchAndRejectInvalidReceiptFor","provider","getProvider","getTransactionReceipt","setProvider","providers","JsonRpcProvider","pollingInterval","ethereum","Web3Provider","send","getNetworkTimeNumber","getBlockNumber","fastForwardTo","targetTime","onProgress","onProg","requireIsolatedNetwork","currentTime","getNetworkTime","stepTime","label","initOrDefaultArgs","init","argsMay","args","value","actuallyWaitUntilTime","onBlock","currentTimeNum","off","then","getDummyAccount","Wallet","createRandom","connect","connectAccount","faucet","getFaucet","transfer","parseCurrency","addressEq","digest","T_Null","T_Bool","T_UInt","T_Tuple","T_Array","T_Object","T_Data","T_Bytes","T_Address","T_Digest","T_Struct","randomUInt","hasRandom","setProviderByEnv","setProviderByName","providerName","providerEnvByName","balanceOf","getBalance","addr","doTxn","dhead","tp","step","rt","rm","wait","ro","doCall","ctc","funcName","gasLimit","dpre","from","to","token","sender","receiver","valueb","kind","txn","sendTransaction","tokCtc","Contract","ERC20_ABI","undefined","shad","substring","iam","some_addr","selfAddress","setGasLimit","ngl","deploy","bin","Signer","isSigner","infoP","resolveInfo","info","performDeploy","ABI","Bytecode","_Connectors","ETH","factory","ContractFactory","contract","deployTransaction","hash","deploy_r","blockNumber","creation_block","attach","attachDeferDeploy","setImpl","implP","implNow","sendrecv","funcNum","evt_cnt","hasLastTime","tys","pay","out_tys","onlyIf","soloSend","timeout_delay","sim_p","toks","impl","recv","deployMode","getInfo","getLastBlock","setLastBlock","lastBlock","n","updateLast","o","Object","keys","getC","_ethersC","verifyContract","callC","arg","ethersC","zero","actualCall","callTok","tok","amt","tokBalance","maybePayTok","i","getEventData","ok_evt","ok_e","ok_args_abi","interface","getEvent","inputs","parseLog","map","a","name","getLogs","fromBlock","toBlock","topics","getEventTopic","sendrecv_impl","doRecv","waitIfNotPresent","recv_impl","args_svs","args_msg","tys_svs","tys_msg","arg_ty","munge","block_send_attempt","block_repeat_count","stack","set","current_block","code","error","didTimeout","okNum","isFirstMsgDeploy","block_poll_start_init","block_poll_start","block_poll_end","es","waitUntilTime","ok_r","ok_t","getTransaction","ok_ed","ok_vals","unmunge","getLog","l_evt","l_ctc","theBlock","l_e","l_ed","l_edu","getOutput","o_lab","o_ctc","time","ok_cnt","delta","p","creationTime","views_bin","_getViews","reachStdlib","views_namesm","views","getView1","vs","v","k","vim","ty","vkn","val","getViews","setDebugLabel","newLabel","newAccountFromSecret","secret","newAccountFromMnemonic","phrase","fromMnemonic","getDefaultAccount","signer","getSigner","setFaucet","chainId","createAccount","fundFromFaucet","account","newTestAccount","startingBalance","now","ctcInfo","backend","deployEvent","logs","actual","getCode","deployData","getDeployTransaction","initLen","setupLen","expected","slice","deployNoInit","actualNoInit","includes","displayLen","standardUnit","atomicUnit","utils","parseUnits","toString","minimumBalance","formatCurrency","decimals","Number","isInteger","Math","min","decimalsToForget","divAmt","div","pow","amtStr","formatUnits"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,OAAP,MAAoB,eAApB;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,GAAP,MAAgB,KAAhB;AACA,SAASC,MAAT,EAAiBC,OAAjB,QAAgC,YAAhC;AACA,SAASC,gBAAT,QAAiC,qBAAjC;AACA,SAASC,GAAT,EAAcC,MAAd,EAAsBC,YAAtB,EAAoCC,KAApC,EAA2CC,UAA3C,EAAuDC,EAAvD,EAA2DC,EAA3D,EAA+DC,QAA/D,EAAyEC,EAAzE,EAA6EC,cAA7E,EAA6FC,aAA7F,EAA4GC,UAA5G,EAAwHC,SAAxH,QAAyI,cAAzI;AACA,SAASC,YAAT,EAAuBC,gBAAvB,QAA+C,mBAA/C;AACA,cAAc,cAAd;AACA,SAASC,MAAM,IAAIC,cAAnB,EAAmCC,QAAnC,QAAmD,oBAAnD;AACA,OAAOC,QAAP,MAAqB,gBAArB;;AAEA,SAASC,MAAT,CAAgBC,CAAhB,EAAmB;AACjB,SAAOA,CAAC,CAACC,MAAF,KAAa,CAApB;AACD;;AAED,SAASC,MAAT,CAAgBF,CAAhB,EAAmB;AACjB,SAAO,CAACD,MAAM,CAACC,CAAD,CAAd;AACD;;AACD,MAAMG,IAAI,GAAIH,CAAD,IAAO,CAACA,CAAD,CAApB;;AACA,MAAMI,IAAI,GAAG,EAAb;AACA,KAAKF,MAAL;AACA,MAAMG,aAAa,GAAG1B,gBAAgB,EAAtC,C,CACA;AACA;AACA;;AACA,MAAM2B,iBAAiB,GAAGD,aAAa,CAACE,UAAd,CAAyB,qBAAzB,KACxB;AACA7B,OAAO,CAAC8B,GAAR,CAAY,wBAAZ,CAFF;AAGA,MAAMC,WAAW,GAAIJ,aAAa,IAAI,0BAAjB,IACnBA,aAAa,IAAI,UADC,GACa;AAC/BK,EAAAA,IAAI,EAAE,KADyB;AAE/BC,EAAAA,GAAG,EAAE3B,UAAU,CAACN,OAAO,CAAC8B,GAAR,CAAYI,YAAb,EAA2B,uBAA3B,CAFgB;AAG/BC,EAAAA,OAAO,EAAE7B,UAAU,CAACN,OAAO,CAAC8B,GAAR,CAAYM,gBAAb,EAA+B,aAA/B;AAHY,CADb,GAKhBT,aAAa,IAAI,aAAjB,GAAiC;AACnCK,EAAAA,IAAI,EAAE;AAD6B,CAAjC,GAEA;AACFA,EAAAA,IAAI,EAAE;AADJ,CAPJ;AAUA,MAAMK,iBAAiB,GAAGtB,YAAY,CAAC,YAAY;AACjDV,EAAAA,KAAK,CAAC,mBAAD,CAAL;;AACA,MAAI0B,WAAW,CAACC,IAAZ,IAAoB,KAAxB,EAA+B;AAC7B;AACD;;AACD,QAAMZ,QAAQ,CAACW,WAAW,CAACE,GAAb,CAAd;AACD,CANqC,CAAtC,C,CAOA;;AACA,MAAMK,aAAa,GAAG,YAAY;AAChCjC,EAAAA,KAAK,CAAC,eAAD,CAAL;;AACA,MAAI0B,WAAW,CAACC,IAAZ,IAAoB,KAAxB,EAA+B;AAC7B;AACD;;AACD,QAAMO,MAAM,GAAGzC,GAAG,CAAC0C,KAAJ,CAAUT,WAAW,CAACE,GAAtB,CAAf,CALgC,CAMhC;;AACA,MAAIM,MAAM,CAACE,QAAP,KAAoB,OAAxB,EAAiC;AAC/B;AACD;;AACD,QAAM,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrC,UAAMC,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAe;AAC1BC,MAAAA,OAAO,EAAE,KADiB;AAE1BC,MAAAA,MAAM,EAAE,oBAFkB;AAG1BC,MAAAA,MAAM,EAAE,EAHkB;AAI1BC,MAAAA,EAAE,EAAE;AAJsB,KAAf,CAAb;AAMA9C,IAAAA,KAAK,CAAC,iCAAD,CAAL;AACA,UAAM+C,IAAI,GAAG,EACX,GAAGb,MADQ;AAEXU,MAAAA,MAAM,EAAE,MAFG;AAGXI,MAAAA,OAAO,EAAE;AACP,wBAAgB,kBADT;AAEP,0BAAkBR,IAAI,CAACtB;AAFhB;AAHE,KAAb;AAQA,UAAM+B,GAAG,GAAGzD,IAAI,CAAC0D,OAAL,CAAaH,IAAb,EAAoBI,GAAD,IAAS;AACtCnD,MAAAA,KAAK,CAAE,aAAF,EAAgBmD,GAAG,CAACC,UAApB,CAAL;AACAD,MAAAA,GAAG,CAACE,EAAJ,CAAO,MAAP,EAAgBC,CAAD,IAAO;AACpBtD,QAAAA,KAAK,CAAC,4BAAD,CAAL;;AACA,YAAII,QAAQ,EAAZ,EAAgB;AACdT,UAAAA,OAAO,CAAC4D,MAAR,CAAeC,KAAf,CAAqBF,CAArB;AACD;;AACDhB,QAAAA,OAAO,CAAC;AAAEa,UAAAA,GAAF;AAAOG,UAAAA;AAAP,SAAD,CAAP;AACD,OAND;AAOD,KATW,CAAZ;AAUAL,IAAAA,GAAG,CAACI,EAAJ,CAAO,OAAP,EAAiBI,CAAD,IAAO;AACrBC,MAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AACAD,MAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACAlB,MAAAA,MAAM,CAACkB,CAAD,CAAN;AACD,KAJD;AAKAR,IAAAA,GAAG,CAACO,KAAJ,CAAUhB,IAAV;AACAxC,IAAAA,KAAK,CAAC,8BAAD,CAAL;AACAiD,IAAAA,GAAG,CAACW,GAAJ;AACA5D,IAAAA,KAAK,CAAC,YAAD,CAAL;AACD,GAnCK,CAAN;AAoCD,CA9CD;;AA+CA,MAAM6D,SAAS,GAAGnD,YAAY,CAAC,YAAY;AACzC,QAAMsB,iBAAiB,EAAvB;AACA,SAAO,MAAMC,aAAa,EAA1B;AACD,CAH6B,CAA9B;AAIA;;AACA,MAAM6B,OAAO,GAAG,MAAOC,GAAP,IAAe;AAC7B,MAAI,CAACA,GAAG,CAACC,cAAT,EACE,MAAMC,KAAK,CAAE,6BAAF,CAAX,CAF2B,CAG7B;AACA;;AACA,MAAIF,GAAG,CAACC,cAAJ,CAAmBE,OAAvB,EAAgC;AAC9B;AACA,WAAOH,GAAG,CAACC,cAAJ,CAAmBE,OAA1B;AACD;;AACD,MAAIH,GAAG,CAACC,cAAJ,CAAmBG,UAAvB,EAAmC;AACjC,WAAO,MAAMJ,GAAG,CAACC,cAAJ,CAAmBG,UAAnB,EAAb;AACD;;AACD,QAAMF,KAAK,CAAE,sEAAF,CAAX;AACD,CAbD;;AAcA,MAAMG,uBAAuB,GAAG,OAAOC,MAAP,EAAeC,CAAf,KAAqB,IAAIjC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB,CAAC+B,CAAD,GAAK/B,MAAM,CAAE,0BAAyB8B,MAAO,EAAlC,CAAX,GACpFC,CAAC,CAACC,eAAF,KAAsBF,MAAtB,GAA+B9B,MAAM,CAAE,eAAc8B,MAAO,QAAOC,CAAC,CAACC,eAAgB,EAAhD,CAArC,GACA,CAACD,CAAC,CAACE,MAAH,GAAYjC,MAAM,CAAE,gBAAe8B,MAAO,yBAAwBC,CAAE,EAAlD,CAAlB,GACAhC,OAAO,CAACgC,CAAD,CAH4C,CAArD;;AAIA,MAAMG,+BAA+B,GAAG,MAAOJ,MAAP,IAAkB;AACxD,QAAMK,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,QAAML,CAAC,GAAG,MAAMI,QAAQ,CAACE,qBAAT,CAA+BP,MAA/B,CAAhB;AACA,SAAO,MAAMD,uBAAuB,CAACC,MAAD,EAASC,CAAT,CAApC;AACD,CAJD;;AAKA,MAAM,CAACK,WAAD,EAAcE,WAAd,IAA6BlE,gBAAgB,CAAC,YAAY;AAC9D,MAAIe,WAAW,CAACC,IAAZ,IAAoB,KAAxB,EAA+B;AAC7B,UAAMkC,SAAS,EAAf;AACA,UAAMa,QAAQ,GAAG,IAAInF,MAAM,CAACuF,SAAP,CAAiBC,eAArB,CAAqCrD,WAAW,CAACE,GAAjD,CAAjB;AACA8C,IAAAA,QAAQ,CAACM,eAAT,GAA2B,GAA3B,CAH6B,CAGG;;AAChC,WAAON,QAAP;AACD,GALD,MAKO,IAAIhD,WAAW,CAACC,IAAZ,IAAoB,QAAxB,EAAkC;AACvC,QAAIjC,MAAM,CAACuF,QAAX,EAAqB;AACnB,YAAMP,QAAQ,GAAG,IAAInF,MAAM,CAACuF,SAAP,CAAiBI,YAArB,CAAkCxF,MAAM,CAACuF,QAAzC,CAAjB,CADmB,CAEnB;AACA;;AACA,YAAMP,QAAQ,CAACS,IAAT,CAAc,qBAAd,EAAqC,EAArC,CAAN;AACA,aAAOT,QAAP;AACD,KAND,MAMO;AACL,YAAMT,KAAK,CAAE,gCAAF,CAAX;AACD;AACF,GAVM,MAUA;AACL;AACA,UAAMA,KAAK,CAAE,8DAA6D3C,aAAc,EAA7E,CAAX;AACD;AACF,CApBkD,CAAnD;;AAqBA,MAAM8D,oBAAoB,GAAG,YAAY;AACvC,QAAMV,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,SAAO,MAAMD,QAAQ,CAACW,cAAT,EAAb;AACD,CAHD;;AAIA,MAAMC,aAAa,GAAG,OAAOC,UAAP,EAAmBC,UAAnB,KAAkC;AACtD;AACA,QAAMC,MAAM,GAAGD,UAAU,KAAK,MAAM,CAAE,CAAb,CAAzB;;AACAE,EAAAA,sBAAsB,CAAC,eAAD,CAAtB;AACA,MAAIC,WAAJ;;AACA,SAAOtF,EAAE,CAACsF,WAAW,GAAG,MAAMC,cAAc,EAAnC,EAAuCL,UAAvC,CAAT,EAA6D;AAC3DE,IAAAA,MAAM,CAAC;AAAEE,MAAAA,WAAF;AAAeJ,MAAAA;AAAf,KAAD,CAAN;AACA,UAAMM,QAAQ,EAAd;AACD,GARqD,CAStD;;;AACAJ,EAAAA,MAAM,CAAC;AAAEE,IAAAA,WAAF;AAAeJ,IAAAA;AAAf,GAAD,CAAN,CAVsD,CAWtD;;AACA,SAAOI,WAAP;AACD,CAbD;;AAcA,MAAMD,sBAAsB,GAAII,KAAD,IAAW;AACxC,MAAI,CAACvE,iBAAL,EAAwB;AACtB,UAAM0C,KAAK,CAAE,qBAAoB6B,KAAM,4BAA2BxE,aAAc,EAArE,CAAX;AACD;AACF,CAJD;;AAKA,MAAMyE,iBAAiB,GAAIC,IAAD,KAAW;AACnCC,EAAAA,OAAO,EAAED,IAAI,GAAG5E,IAAI,CAAC4E,IAAI,CAACE,IAAN,CAAP,GAAqB7E,IADC;AAEnC8E,EAAAA,KAAK,EAAEH,IAAI,GAAGA,IAAI,CAACG,KAAR,GAAgBpG,YAAY,CAAC,CAAD;AAFJ,CAAX,CAA1B,C,CAIA;AACA;;;AACA,MAAMqG,qBAAqB,GAAG,OAAOb,UAAP,EAAmBC,UAAnB,KAAkC;AAC9D,QAAMC,MAAM,GAAGD,UAAU,KAAK,MAAM,CAAE,CAAb,CAAzB;;AACA,QAAMd,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,SAAO,MAAM,IAAItC,OAAJ,CAAaC,OAAD,IAAa;AACpC,UAAM+D,OAAO,GAAG,MAAOC,cAAP,IAA0B;AACxC,YAAMX,WAAW,GAAG5F,YAAY,CAACuG,cAAD,CAAhC,CADwC,CAExC;;AACAb,MAAAA,MAAM,CAAC;AAAEE,QAAAA,WAAF;AAAeJ,QAAAA;AAAf,OAAD,CAAN;;AACA,UAAIpF,EAAE,CAACwF,WAAD,EAAcJ,UAAd,CAAN,EAAiC;AAC/Bb,QAAAA,QAAQ,CAAC6B,GAAT,CAAa,OAAb,EAAsBF,OAAtB;AACA/D,QAAAA,OAAO,CAACqD,WAAD,CAAP;AACD;AACF,KARD;;AASAjB,IAAAA,QAAQ,CAACrB,EAAT,CAAY,OAAZ,EAAqBgD,OAArB,EAVoC,CAWpC;AACA;AACA;;AACAT,IAAAA,cAAc,GAAGY,IAAjB,CAAsBH,OAAtB;AACD,GAfY,CAAb;AAgBD,CAnBD;;AAoBA,MAAMI,eAAe,GAAG/F,YAAY,CAAC,YAAY;AAC/C,QAAMgE,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,QAAMX,cAAc,GAAGzE,MAAM,CAACmH,MAAP,CAAcC,YAAd,GAA6BC,OAA7B,CAAqClC,QAArC,CAAvB;AACA,QAAMX,GAAG,GAAG,MAAM8C,cAAc,CAAC7C,cAAD,CAAhC;AACA,SAAOD,GAAP;AACD,CALmC,CAApC;;AAMA,MAAM8B,QAAQ,GAAG,YAAY;AAC3BH,EAAAA,sBAAsB,CAAC,UAAD,CAAtB;AACA,QAAMoB,MAAM,GAAG,MAAMC,SAAS,EAA9B;AACA,QAAMhD,GAAG,GAAG,MAAM0C,eAAe,EAAjC;AACA,SAAO,MAAMO,QAAQ,CAACF,MAAD,EAAS/C,GAAT,EAAckD,aAAa,CAAC,CAAD,CAA3B,CAArB;AACD,CALD,C,CAMA;AACA;AACA;;;AACA,OAAO,MAAM;AAAEC,EAAAA,SAAF;AAAaC,EAAAA;AAAb,IAAwBtG,cAA9B;AACP,OAAO,MAAM;AAAEuG,EAAAA,MAAF;AAAUC,EAAAA,MAAV;AAAkBC,EAAAA,MAAlB;AAA0BC,EAAAA,OAA1B;AAAmCC,EAAAA,OAAnC;AAA4CC,EAAAA,QAA5C;AAAsDC,EAAAA,MAAtD;AAA8DC,EAAAA,OAA9D;AAAuEC,EAAAA,SAAvE;AAAkFC,EAAAA,QAAlF;AAA4FC,EAAAA;AAA5F,IAAyGhH,QAA/G;AACP,OAAO,MAAM;AAAEiH,EAAAA,UAAF;AAAcC,EAAAA;AAAd,IAA4BxH,UAAU,CAAC,EAAD,CAA5C;AACP,SAASmE,WAAT,EAAsBE,WAAtB,G,CACA;;AACA,OAAO,SAASoD,gBAAT,CAA0BxG,GAA1B,EAA+B;AACpC,OAAKA,GAAL;AACA,QAAMwC,KAAK,CAAE,2CAAF,CAAX;AACD,C,CACD;;AACA,OAAO,SAASiE,iBAAT,CAA2BC,YAA3B,EAAyC;AAC9C,OAAKA,YAAL;AACA,QAAMlE,KAAK,CAAE,4CAAF,CAAX;AACD,C,CACD;;AACA,OAAO,SAASmE,iBAAT,CAA2BD,YAA3B,EAAyC;AAC9C,OAAKA,YAAL;AACA,QAAMlE,KAAK,CAAE,4CAAF,CAAX;AACD;AACD,OAAO,MAAMoE,SAAS,GAAG,MAAOtE,GAAP,IAAe;AACtC,QAAM;AAAEC,IAAAA;AAAF,MAAqBD,GAA3B;AACA,MAAI,CAACC,cAAL,EACE,MAAMC,KAAK,CAAE,oCAAmCF,GAAI,EAAzC,CAAX;;AACF,MAAIC,cAAc,CAACsE,UAAnB,EAA+B;AAC7B,WAAOvI,YAAY,CAAC,MAAMiE,cAAc,CAACsE,UAAf,EAAP,CAAnB;AACD;;AACD,QAAMC,IAAI,GAAG,MAAMzE,OAAO,CAACC,GAAD,CAA1B;;AACA,MAAIwE,IAAJ,EAAU;AACR,UAAM7D,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,WAAO5E,YAAY,CAAC,MAAM2E,QAAQ,CAAC4D,UAAT,CAAoBC,IAApB,CAAP,CAAnB;AACD;;AACD,QAAMtE,KAAK,CAAE,yBAAwBD,cAAe,EAAzC,CAAX;AACD,CAbM;;AAcP,MAAMwE,KAAK,GAAG,OAAOC,KAAP,EAAcC,EAAd,KAAqB;AACjC1I,EAAAA,KAAK,CAAC,EAAE,GAAGyI,KAAL;AAAYE,IAAAA,IAAI,EAAG;AAAnB,GAAD,CAAL;AACA,QAAMC,EAAE,GAAG,MAAMF,EAAjB;AACA1I,EAAAA,KAAK,CAAC,EAAE,GAAGyI,KAAL;AAAYG,IAAAA,EAAZ;AAAgBD,IAAAA,IAAI,EAAG;AAAvB,GAAD,CAAL;AACA,QAAME,EAAE,GAAG,MAAMD,EAAE,CAACE,IAAH,EAAjB;AACA9I,EAAAA,KAAK,CAAC,EAAE,GAAGyI,KAAL;AAAYG,IAAAA,EAAZ;AAAgBC,IAAAA,EAAhB;AAAoBF,IAAAA,IAAI,EAAG;AAA3B,GAAD,CAAL;AACA7I,EAAAA,MAAM,CAAC+I,EAAE,KAAK,IAAR,EAAe,mBAAf,CAAN;AACA,QAAME,EAAE,GAAG,MAAMtE,+BAA+B,CAACoE,EAAE,CAACtE,eAAJ,CAAhD;AACAvE,EAAAA,KAAK,CAAC,EAAE,GAAGyI,KAAL;AAAYG,IAAAA,EAAZ;AAAgBC,IAAAA,EAAhB;AAAoBE,IAAAA,EAApB;AAAwBJ,IAAAA,IAAI,EAAG;AAA/B,GAAD,CAAL,CARiC,CASjC;;AACA,OAAKI,EAAL;AACD,CAXD;;AAYA,MAAMC,MAAM,GAAG,OAAOP,KAAP,EAAcQ,GAAd,EAAmBC,QAAnB,EAA6BhD,IAA7B,EAAmCC,KAAnC,EAA0CgD,QAA1C,KAAuD;AACpE,QAAMC,IAAI,GAAG,EAAE,GAAGX,KAAL;AAAYS,IAAAA,QAAZ;AAAsBhD,IAAAA,IAAtB;AAA4BC,IAAAA;AAA5B,GAAb;AACAnG,EAAAA,KAAK,CAAC,EAAE,GAAGoJ,IAAL;AAAWT,IAAAA,IAAI,EAAG;AAAlB,GAAD,CAAL;AACA,SAAO,MAAMH,KAAK,CAACY,IAAD,EAAOH,GAAG,CAACC,QAAD,CAAH,CAAc,GAAGhD,IAAjB,EAAuB;AAAEC,IAAAA,KAAF;AAASgD,IAAAA;AAAT,GAAvB,CAAP,CAAlB;AACD,CAJD;AAKA;;;AACA,OAAO,MAAMnC,QAAQ,GAAG,OAAOqC,IAAP,EAAaC,EAAb,EAAiBnD,KAAjB,EAAwBoD,KAAK,GAAG,KAAhC,KAA0C;AAChE,QAAMC,MAAM,GAAGH,IAAI,CAACrF,cAApB;AACA,QAAMyF,QAAQ,GAAG3F,OAAO,CAACwF,EAAD,CAAxB;AACA,QAAMI,MAAM,GAAG3J,YAAY,CAACoG,KAAD,CAA3B;AACA,QAAMsC,KAAK,GAAG;AAAEkB,IAAAA,IAAI,EAAE;AAAR,GAAd;;AACA,MAAI,CAACJ,KAAL,EAAY;AACV,UAAMK,GAAG,GAAG;AAAEN,MAAAA,EAAE,EAAEG,QAAN;AAAgBtD,MAAAA,KAAK,EAAEuD;AAAvB,KAAZ;AACA1J,IAAAA,KAAK,CAAC,yBAAD,EAA4B4J,GAA5B,EAAiC,GAAjC,CAAL;AACA,WAAO,MAAMpB,KAAK,CAACC,KAAD,EAAQe,MAAM,CAACK,eAAP,CAAuBD,GAAvB,CAAR,CAAlB;AACD,GAJD,MAIO;AACL,UAAME,MAAM,GAAG,IAAIvK,MAAM,CAACwK,QAAX,CAAoBR,KAApB,EAA2BS,SAA3B,EAAsCR,MAAtC,CAAf;AACA,WAAO,MAAMR,MAAM,CAACP,KAAD,EAAQqB,MAAR,EAAgB,UAAhB,EAA4B,CAACL,QAAD,EAAWC,MAAX,CAA5B,EAAgD3J,YAAY,CAAC,CAAD,CAA5D,EAAiEkK,SAAjE,CAAnB;AACD;AACF,CAbM;AAcP,MAAMD,SAAS,GAAG,CAAC;AACf,cAAY,KADG;AAEf,YAAU,CAAC;AACP,YAAQ,UADD;AAEP,YAAQ;AAFD,GAAD,EAIR;AACE,YAAQ,QADV;AAEE,YAAQ;AAFV,GAJQ,CAFK;AAWf,UAAQ,SAXO;AAYf,aAAW,CAAC;AACV,YAAQ,EADE;AAEV,YAAQ;AAFE,GAAD,CAZI;AAgBf,aAAW,KAhBI;AAiBf,qBAAmB,YAjBJ;AAkBf,UAAQ;AAlBO,CAAD,EAoBhB;AACE,cAAY,IADd;AAEE,YAAU,CAAC;AACT,YAAQ,SADC;AAET,YAAQ;AAFC,GAAD,CAFZ;AAME,UAAQ,WANV;AAOE,aAAW,CAAC;AACV,YAAQ,EADE;AAEV,YAAQ;AAFE,GAAD,CAPb;AAWE,aAAW,KAXb;AAYE,qBAAmB,MAZrB;AAaE,UAAQ;AAbV,CApBgB,EAmChB;AACE,cAAY,KADd;AAEE,YAAU,CAAC;AACP,YAAQ,YADD;AAEP,YAAQ;AAFD,GAAD,EAIR;AACE,YAAQ,SADV;AAEE,YAAQ;AAFV,GAJQ,CAFZ;AAWE,UAAQ,UAXV;AAYE,aAAW,CAAC;AACV,YAAQ,EADE;AAEV,YAAQ;AAFE,GAAD,CAZb;AAgBE,aAAW,KAhBb;AAiBE,qBAAmB,YAjBrB;AAkBE,UAAQ;AAlBV,CAnCgB,CAAlB;AAwDA,OAAO,MAAMnD,cAAc,GAAG,MAAO7C,cAAP,IAA0B;AACtD;AACA,MAAIA,cAAc,CAACG,UAAf,IAA6B,CAACH,cAAc,CAACE,OAAjD,EAA0D;AACxD;AACAF,IAAAA,cAAc,CAACE,OAAf,GAAyB,MAAMJ,OAAO,CAAC;AAAEE,MAAAA;AAAF,KAAD,CAAtC;AACD,GALqD,CAMtD;;;AACA,QAAMU,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,QAAMT,OAAO,GAAG,MAAMJ,OAAO,CAAC;AAAEE,IAAAA;AAAF,GAAD,CAA7B;;AACA,MAAI,CAACE,OAAL,EAAc;AACZ,UAAMD,KAAK,CAAE,oCAAmCD,cAAe,EAApD,CAAX;AACD;;AACD,QAAMkG,IAAI,GAAGhG,OAAO,CAACiG,SAAR,CAAkB,CAAlB,EAAqB,CAArB,CAAb;AACA,MAAIrE,KAAK,GAAGoE,IAAZ;;AACA,QAAME,GAAG,GAAIC,SAAD,IAAe;AACzB,QAAIA,SAAS,IAAInG,OAAjB,EAA0B;AACxB,aAAOA,OAAP;AACD,KAFD,MAEO;AACL,YAAMD,KAAK,CAAE,eAAcoG,SAAU,YAAWnG,OAAQ,EAA7C,CAAX;AACD;AACF,GAND;;AAOA,QAAMoG,WAAW,GAAG,MAAM;AACxB,WAAOpG,OAAP;AACD,GAFD;;AAGA,MAAIiF,QAAJ;;AACA,QAAMoB,WAAW,GAAIC,GAAD,IAAS;AAC3BrB,IAAAA,QAAQ,GAAGpJ,YAAY,CAACyK,GAAD,CAAvB;AACD,GAFD;;AAGA,QAAMC,MAAM,GAAIC,GAAD,IAAS;AACtB,QAAI,CAACnL,MAAM,CAACoL,MAAP,CAAcC,QAAd,CAAuB5G,cAAvB,CAAL,EAA6C;AAC3C,YAAMC,KAAK,CAAE,8BAA6BD,cAAe,EAA9C,CAAX;AACD;;AACD,UAAM;AAAE6G,MAAAA,KAAF;AAASC,MAAAA;AAAT,QAAyB,CAAC,MAAM;AACpC,UAAIA,WAAW,GAAIC,IAAD,IAAU;AAAE,aAAKA,IAAL;AAAa,OAA3C;;AACA,YAAMF,KAAK,GAAG,IAAIxI,OAAJ,CAAYC,OAAO,IAAI;AACnCwI,QAAAA,WAAW,GAAGxI,OAAd;AACD,OAFa,CAAd;AAGA,aAAO;AAAEuI,QAAAA,KAAF;AAASC,QAAAA;AAAT,OAAP;AACD,KAN8B,GAA/B;;AAOA,UAAME,aAAa,GAAIhF,IAAD,IAAU;AAC9BhG,MAAAA,KAAK,CAACkK,IAAD,EAAO,sBAAP,EAA+BlE,IAA/B,CAAL;AACA,YAAM;AAAEC,QAAAA,OAAF;AAAWE,QAAAA;AAAX,UAAqBJ,iBAAiB,CAACC,IAAD,CAA5C;AACA,YAAM;AAAEiF,QAAAA,GAAF;AAAOC,QAAAA;AAAP,UAAoBR,GAAG,CAACS,WAAJ,CAAgBC,GAA1C;AACApL,MAAAA,KAAK,CAACkK,IAAD,EAAO,2BAAP,CAAL;AACA,YAAMmB,OAAO,GAAG,IAAI9L,MAAM,CAAC+L,eAAX,CAA2BL,GAA3B,EAAgCC,QAAhC,EAA0ClH,cAA1C,CAAhB;;AACA,OAAC,YAAY;AACXhE,QAAAA,KAAK,CAACkK,IAAD,EAAQ,qBAAR,CAAL;AACA,cAAMqB,QAAQ,GAAG,MAAMF,OAAO,CAACZ,MAAR,CAAe,GAAGxE,OAAlB,EAA2B;AAAEE,UAAAA,KAAF;AAASgD,UAAAA;AAAT,SAA3B,CAAvB;AACAnJ,QAAAA,KAAK,CAACkK,IAAD,EAAQ,4BAAR,EAAqCqB,QAAQ,CAACrH,OAA9C,CAAL;AACAlE,QAAAA,KAAK,CAACkK,IAAD,EAAQ,wBAAR,EAAiCqB,QAAQ,CAACC,iBAAT,CAA2BC,IAA5D,CAAL;AACA,cAAMC,QAAQ,GAAG,MAAMH,QAAQ,CAACC,iBAAT,CAA2B1C,IAA3B,EAAvB;AACA9I,QAAAA,KAAK,CAACkK,IAAD,EAAQ,gBAAR,EAAyBwB,QAAQ,CAACC,WAAlC,CAAL;AACA,cAAMZ,IAAI,GAAG;AACX7G,UAAAA,OAAO,EAAEqH,QAAQ,CAACrH,OADP;AAEX0H,UAAAA,cAAc,EAAEF,QAAQ,CAACC,WAFd;AAGXpH,UAAAA,eAAe,EAAEmH,QAAQ,CAACnH,eAHf;AAIXyB,UAAAA;AAJW,SAAb;AAMA8E,QAAAA,WAAW,CAACC,IAAD,CAAX;AACD,OAdD;;AAeA,aAAOc,MAAM,CAACnB,GAAD,EAAMG,KAAN,CAAb;AACD,KAtBD;;AAuBA,UAAMiB,iBAAiB,GAAG,MAAM;AAC9B,UAAIC,OAAJ;AACA,YAAMC,KAAK,GAAG,IAAI3J,OAAJ,CAAaC,OAAD,IAAa;AAAEyJ,QAAAA,OAAO,GAAGzJ,OAAV;AAAoB,OAA/C,CAAd;AACA,YAAM2J,OAAO,GAAG;AACdrL,QAAAA,MAAM,EAAEC,cADM;AAEdqL,QAAAA,QAAQ,EAAE,OAAOC,OAAP,EAAgBC,OAAhB,EAAyBC,WAAzB,EAAsCC,GAAtC,EAA2CpG,IAA3C,EAAiDqG,GAAjD,EAAsDC,OAAtD,EAA+DC,MAA/D,EAAuEC,QAAvE,EAAiFC,aAAjF,EAAgGC,KAAhG,KAA0G;AAClH5M,UAAAA,KAAK,CAACkK,IAAD,EAAQ,GAAR,EAAYpE,KAAZ,EAAmB,YAAnB,EAAiCqG,OAAjC,EAA2C,mBAA3C,CAAL;AACA,eAAKC,OAAL;AACA,eAAKQ,KAAL,CAHkH,CAIlH;;AACA,eAAKP,WAAL;AACA,eAAKC,GAAL;AACA,eAAKE,OAAL;AACA,gBAAM,CAACrG,KAAD,EAAQ0G,IAAR,IAAgBN,GAAtB,CARkH,CASlH;;AACA,cAAI;AACFzM,YAAAA,MAAM,CAAC2M,MAAD,EAAU,qCAAV,CAAN;AACA3M,YAAAA,MAAM,CAAC4M,QAAD,EAAY,uCAAZ,CAAN;AACA5M,YAAAA,MAAM,CAACI,EAAE,CAACiM,OAAD,EAAU,CAAV,CAAH,EAAkB,mCAAlB,CAAN;AACArM,YAAAA,MAAM,CAAC,CAAC6M,aAAF,EAAkB,4BAAlB,CAAN;AACA7M,YAAAA,MAAM,CAAC+M,IAAI,CAAC3L,MAAL,IAAe,CAAhB,EAAoB,2BAApB,CAAN;AACD,WAND,CAME,OAAOuC,CAAP,EAAU;AACV,kBAAMQ,KAAK,CAAE,+DAA8DR,CAAE,EAAlE,CAAX;AACD,WAlBiH,CAmBlH;;;AACAsI,UAAAA,OAAO,CAACf,aAAa,CAAC;AAAE9E,YAAAA,IAAI,EAAE,CAC1B,CAAC,CAAD,CAD0B,EACrBA,IADqB,CAAR;AAEjBC,YAAAA;AAFiB,WAAD,CAAd,CAAP;AAGA,gBAAM0E,KAAN,CAvBkH,CAuBrG;AACb;;AACA,iBAAO,MAAMiC,IAAI,CAACC,IAAL,CAAUZ,OAAV,EAAmBC,OAAnB,EAA4BI,OAA5B,EAAqC,KAArC,EAA4CG,aAA5C,CAAb;AACD;AA5Ba,OAAhB;AA8BA,YAAMG,IAAI,GAAGvM,aAAa,CAAC,IAAD,EAAOyL,KAAP,EAAcC,OAAd,CAA1B;AACA,aAAOa,IAAP;AACD,KAnCD;;AAoCA,YAAQpC,GAAG,CAACS,WAAJ,CAAgBC,GAAhB,CAAoB4B,UAA5B;AACE,WAAK,aAAL;AACE,eAAOlB,iBAAiB,EAAxB;;AACF,WAAK,gBAAL;AACE,eAAOd,aAAa,EAApB;;AACF;AACE,cAAM/G,KAAK,CAAE,4BAA2ByG,GAAG,CAACS,WAAJ,CAAgBC,GAAhB,CAAoB4B,UAAW,EAA5D,CAAX;AANJ;AAQD,GA9ED;;AA+EA,QAAMnB,MAAM,GAAG,CAACnB,GAAD,EAAMG,KAAN,KAAgB;AAC7B;AACA;AACA;AACA;AACA,QAAIA,KAAK,CAACoC,OAAV,EAAmB;AACjBvJ,MAAAA,OAAO,CAACC,GAAR,CAAa,qDAAD,GACT,kDADS,GAET,8CAFH,EADiB,CAIjB;;AACAkH,MAAAA,KAAK,GAAGA,KAAK,CAACoC,OAAN,EAAR;AACD;;AACD,UAAMhC,GAAG,GAAGxI,IAAI,CAACN,KAAL,CAAWuI,GAAG,CAACS,WAAJ,CAAgBC,GAAhB,CAAoBH,GAA/B,CAAZ,CAZ6B,CAa7B;;AACA,UAAM;AAAEiC,MAAAA,YAAF;AAAgBC,MAAAA;AAAhB,QAAiC,CAAC,MAAM;AAC5C,UAAIC,SAAS,GAAG,IAAhB;;AACA,YAAMD,YAAY,GAAIE,CAAD,IAAO;AAC1BrN,QAAAA,KAAK,CAAE,gBAAF,EAAmBoN,SAAnB,EAA+B,IAA/B,EAAoCC,CAApC,CAAL;AACAD,QAAAA,SAAS,GAAGC,CAAZ;AACD,OAHD;;AAIA,YAAMH,YAAY,GAAG,YAAY;AAC/B,YAAI,OAAOE,SAAP,KAAqB,QAAzB,EAAmC;AACjC,iBAAOA,SAAP;AACD;;AACD,cAAMrC,IAAI,GAAG,MAAMF,KAAnB;AACAsC,QAAAA,YAAY,CAACpC,IAAI,CAACa,cAAN,CAAZ;AACA,eAAOb,IAAI,CAACa,cAAZ;AACD,OAPD;;AAQA,aAAO;AAAEsB,QAAAA,YAAF;AAAgBC,QAAAA;AAAhB,OAAP;AACD,KAfsC,GAAvC;;AAgBA,UAAMG,UAAU,GAAIC,CAAD,IAAO;AACxB,UAAI,CAACA,CAAC,CAAC5B,WAAP,EAAoB;AAClBjI,QAAAA,OAAO,CAACC,GAAR,CAAY4J,CAAZ;AACA,cAAMtJ,KAAK,CAAE,2BAA0BuJ,MAAM,CAACC,IAAP,CAAYF,CAAZ,CAAe,EAA3C,CAAX;AACD;;AACDJ,MAAAA,YAAY,CAACI,CAAC,CAAC5B,WAAH,CAAZ;AACD,KAND;;AAOA,UAAM+B,IAAI,GAAG,CAAC,MAAM;AAClB,UAAIC,QAAQ,GAAG,IAAf;AACA,aAAO,YAAY;AACjB,YAAIA,QAAJ,EAAc;AACZ,iBAAOA,QAAP;AACD;;AACD,cAAM5C,IAAI,GAAG,MAAMF,KAAnB;AACA,cAAM+C,cAAc,CAAC7C,IAAD,EAAOL,GAAP,CAApB;AACA1K,QAAAA,KAAK,CAACkK,IAAD,EAAQ,qBAAR,CAAL;;AACA,YAAI,CAAC3K,MAAM,CAACoL,MAAP,CAAcC,QAAd,CAAuB5G,cAAvB,CAAL,EAA6C;AAC3C,gBAAMC,KAAK,CAAE,mDAAkDD,cAAe,EAAnE,CAAX;AACD;;AACD2J,QAAAA,QAAQ,GAAG,IAAIpO,MAAM,CAACwK,QAAX,CAAoBgB,IAAI,CAAC7G,OAAzB,EAAkC+G,GAAlC,EAAuCjH,cAAvC,CAAX;AACA,eAAO2J,QAAP;AACD,OAZD;AAaD,KAfY,GAAb;;AAgBA,UAAME,KAAK,GAAG,OAAOpF,KAAP,EAAcS,QAAd,EAAwB4E,GAAxB,EAA6BvB,GAA7B,KAAqC;AACjD,YAAM,CAACpG,KAAD,EAAQ0G,IAAR,IAAgBN,GAAtB;AACA,YAAMwB,OAAO,GAAG,MAAML,IAAI,EAA1B;AACA,YAAMM,IAAI,GAAGjO,YAAY,CAAC,CAAD,CAAzB;;AACA,YAAMkO,UAAU,GAAG,YAAY,MAAMjF,MAAM,CAAC,EAAE,GAAGP,KAAL;AAAYkB,QAAAA,IAAI,EAAE;AAAlB,OAAD,EAA8BoE,OAA9B,EAAuC7E,QAAvC,EAAiD,CAAC4E,GAAD,CAAjD,EAAwD3H,KAAxD,EAA+DgD,QAA/D,CAA3C;;AACA,YAAM+E,OAAO,GAAG,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AAClC;AACA,cAAMtE,MAAM,GAAG,IAAIvK,MAAM,CAACwK,QAAX,CAAoBoE,GAApB,EAAyBnE,SAAzB,EAAoChG,cAApC,CAAf;AACA,cAAMqK,UAAU,GAAG,MAAMvE,MAAM,CAAC,WAAD,CAAN,CAAoB5F,OAApB,CAAzB;AACAlE,QAAAA,KAAK,CAAC,EAAE,GAAGyI,KAAL;AAAYkB,UAAAA,IAAI,EAAE;AAAlB,SAAD,EAA8B,WAA9B,EAA2C0E,UAA3C,CAAL;AACAvO,QAAAA,MAAM,CAACuO,UAAU,IAAID,GAAf,EAAqB,6CAA4CC,UAAW,MAAKD,GAAI,EAArF,CAAN;AACA,cAAMpF,MAAM,CAAC,EAAE,GAAGP,KAAL;AAAYkB,UAAAA,IAAI,EAAE;AAAlB,SAAD,EAA8BG,MAA9B,EAAsC,SAAtC,EAAiD,CAACiE,OAAO,CAAC7J,OAAT,EAAkBkK,GAAlB,CAAjD,EAAyEJ,IAAzE,EAA+E7E,QAA/E,CAAZ;AACD,OAPD;;AAQA,YAAMmF,WAAW,GAAG,MAAOC,CAAP,IAAa;AAC/B,YAAIA,CAAC,GAAG1B,IAAI,CAAC3L,MAAb,EAAqB;AACnB,gBAAM,CAACkN,GAAD,EAAMD,GAAN,IAAatB,IAAI,CAAC0B,CAAD,CAAvB;AACA,gBAAML,OAAO,CAACC,GAAD,EAAMC,GAAN,CAAb;;AACA,cAAI;AACF,kBAAME,WAAW,CAACC,CAAC,GAAG,CAAL,CAAjB;AACD,WAFD,CAEE,OAAO9K,CAAP,EAAU;AACV,kBAAMyK,OAAO,CAACC,GAAD,EAAMH,IAAN,CAAb;AACA,kBAAMvK,CAAN;AACD;AACF,SATD,MASO;AACL,gBAAMwK,UAAU,EAAhB;AACD;AACF,OAbD;;AAcA,YAAMK,WAAW,CAAC,CAAD,CAAjB;AACD,KA5BD;;AA6BA,UAAME,YAAY,GAAG,OAAOC,MAAP,EAAeC,IAAf,KAAwB;AAC3C,YAAMX,OAAO,GAAG,MAAML,IAAI,EAA1B;AACA,YAAMiB,WAAW,GAAGZ,OAAO,CAACa,SAAR,CAAkBC,QAAlB,CAA2BJ,MAA3B,EAAmCK,MAAvD;AACA,YAAM;AAAE5I,QAAAA;AAAF,UAAW6H,OAAO,CAACa,SAAR,CAAkBG,QAAlB,CAA2BL,IAA3B,CAAjB;AACA,aAAOC,WAAW,CAACK,GAAZ,CAAgBC,CAAC,IAAI/I,IAAI,CAAC+I,CAAC,CAACC,IAAH,CAAzB,CAAP;AACD,KALD;;AAMA,UAAMC,OAAO,GAAG,OAAOC,SAAP,EAAkBC,OAAlB,EAA2BZ,MAA3B,KAAsC;AACpD,UAAIW,SAAS,GAAGC,OAAhB,EAAyB;AACvB,eAAO,EAAP;AACD;;AACD,YAAMtB,OAAO,GAAG,MAAML,IAAI,EAA1B;AACA,aAAO,MAAMhJ,QAAQ,CAACyK,OAAT,CAAiB;AAC5BC,QAAAA,SAD4B;AAE5BC,QAAAA,OAF4B;AAG5BnL,QAAAA,OAAO,EAAE6J,OAAO,CAAC7J,OAHW;AAI5BoL,QAAAA,MAAM,EAAE,CAACvB,OAAO,CAACa,SAAR,CAAkBW,aAAlB,CAAgCd,MAAhC,CAAD;AAJoB,OAAjB,CAAb;AAMD,KAXD;;AAYA,UAAMxB,OAAO,GAAG,YAAY,MAAMpC,KAAlC;;AACA,UAAM2E,aAAa,GAAG,OAAOrD,OAAP,EAAgBC,OAAhB,EAAyBC,WAAzB,EAAsCC,GAAtC,EAA2CpG,IAA3C,EAAiDqG,GAAjD,EAAsDC,OAAtD,EAA+DC,MAA/D,EAAuEC,QAAvE,EAAiFC,aAAjF,KAAmG;AACvH,WAAKN,WAAL;;AACA,YAAMoD,MAAM,GAAG,MAAOC,gBAAP,IAA4B,MAAMC,SAAS,CAACxD,OAAD,EAAUK,OAAV,EAAmBkD,gBAAnB,EAAqC/C,aAArC,CAA1D;;AACA,UAAI,CAACF,MAAL,EAAa;AACX,eAAO,MAAMgD,MAAM,CAAC,IAAD,CAAnB;AACD;;AACD,YAAMvG,QAAQ,GAAI,IAAGiD,OAAQ,EAA7B;;AACA,UAAIG,GAAG,CAACpL,MAAJ,KAAegF,IAAI,CAAChF,MAAxB,EAAgC;AAC9B,cAAM+C,KAAK,CAAE,eAAcqI,GAAG,CAACpL,MAAO,sBAAqBgF,IAAI,CAAChF,MAAO,GAA5D,CAAX;AACD;;AACD,YAAMuH,KAAK,GAAG,CAACyB,IAAD,EAAOpE,KAAP,EAAc,MAAd,EAAsBoD,QAAtB,EAAgCyD,aAAhC,EAA+C,MAA/C,CAAd;AACA3M,MAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAW,MAAX,EAAmBvC,IAAnB,CAAD,CAAL;AACA,YAAM,CAAC0J,QAAD,EAAWC,QAAX,IAAuBpP,SAAS,CAACyF,IAAD,EAAOkG,OAAP,CAAtC;AACA,YAAM,CAAC0D,OAAD,EAAUC,OAAV,IAAqBtP,SAAS,CAAC6L,GAAD,EAAMF,OAAN,CAApC,CAbuH,CAcvH;;AACA,YAAM4D,MAAM,GAAGzI,OAAO,CAAC,CAACA,OAAO,CAACuI,OAAD,CAAR,EAAmBvI,OAAO,CAACwI,OAAD,CAA1B,CAAD,CAAtB;AACA,YAAMjC,GAAG,GAAGkC,MAAM,CAACC,KAAP,CAAa,CAACL,QAAD,EAAWC,QAAX,CAAb,CAAZ;AACA7P,MAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAW,OAAX,EAAoBqF,GAApB,CAAD,CAAL;AACA,YAAMV,SAAS,GAAG,MAAMF,YAAY,EAApC;AACA,UAAIgD,kBAAkB,GAAG9C,SAAzB;AACA,UAAI+C,kBAAkB,GAAG,CAAzB;;AACA,aAAO,CAACxD,aAAD,IAAkBtM,EAAE,CAAC6P,kBAAD,EAAqBrQ,GAAG,CAACuN,SAAD,EAAYT,aAAZ,CAAxB,CAA3B,EAAgF;AAC9E3M,QAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAW,KAAX,CAAD,CAAL;;AACA,YAAI;AACFzI,UAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAW,KAAX,EAAkBqF,GAAlB,EAAuBvB,GAAvB,CAAD,CAAL;AACA,gBAAMsB,KAAK,CAACpF,KAAD,EAAQS,QAAR,EAAkB4E,GAAlB,EAAuBvB,GAAvB,CAAX;AACD,SAHD,CAGE,OAAO9I,CAAP,EAAU;AACV,cAAI,CAACiJ,QAAL,EAAe;AACb1M,YAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAY,UAAZ,EAAuBhF,CAAvB,CAAD,CAAL;AACD,WAFD,MAEO;AACLzD,YAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAY,OAAZ,EAAoBhF,CAAC,CAAC2M,KAAtB,CAAD,CAAL,CADK,CAEL;;AACA,kBAAM9Q,OAAO,CAAC+Q,GAAR,CAAY,CAAZ,CAAN;AACA,kBAAMC,aAAa,GAAG,MAAMlL,oBAAoB,EAAhD;;AACA,gBAAIkL,aAAa,IAAIJ,kBAArB,EAAyC;AACvCC,cAAAA,kBAAkB;AACnB;;AACDD,YAAAA,kBAAkB,GAAGI,aAArB;;AACA;AAAK;AAAuBH,YAAAA,kBAAkB,GAAG,EAAjD,EAAqD;AACnD,kBAAI1M,CAAC,CAAC8M,IAAF,KAAW,yBAAf,EAA0C;AACxC,oBAAIC,KAAK,GAAG/M,CAAZ;;AACA,uBAAO+M,KAAK,CAACA,KAAb,EAAoB;AAClBA,kBAAAA,KAAK,GAAGA,KAAK,CAACA,KAAd;AACD;;AACD9M,gBAAAA,OAAO,CAACC,GAAR,CAAa,uEAAb;AACAD,gBAAAA,OAAO,CAACC,GAAR,CAAY6M,KAAZ;AACD;;AACD9M,cAAAA,OAAO,CAACC,GAAR,CAAa,OAAb;AACAD,cAAAA,OAAO,CAACC,GAAR,CAAYmK,GAAZ;AACA,oBAAM7J,KAAK,CAAE,GAAEwE,KAAM,aAAYyH,kBAAmB,MAAKC,kBAAmB,EAAjE,CAAX;AACD;;AACDnQ,YAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAY,UAAZ,EAAuB2E,SAAvB,EAAkCkD,aAAlC,EAAiDH,kBAAjD,EAAqED,kBAArE,CAAD,CAAL;AACA;AACD;AACF;;AACD,eAAO,MAAMT,MAAM,CAAC,KAAD,CAAnB;AACD,OAxDsH,CAyDvH;AACA;AACA;;;AACAzP,MAAAA,KAAK,CAAC,CAAC,GAAGyI,KAAJ,EAAY,cAAZ,CAAD,CAAL;AACA,aAAO;AAAEgI,QAAAA,UAAU,EAAE;AAAd,OAAP;AACD,KA9DD;;AA+DA,UAAMvE,QAAQ,GAAG,OAAOC,OAAP,EAAgBC,OAAhB,EAAyBC,WAAzB,EAAsCC,GAAtC,EAA2CpG,IAA3C,EAAiDqG,GAAjD,EAAsDC,OAAtD,EAA+DC,MAA/D,EAAuEC,QAAvE,EAAiFC,aAAjF,EAAgGC,KAAhG,KAA0G;AACzH,WAAKA,KAAL;AACA,aAAO,MAAM4C,aAAa,CAACrD,OAAD,EAAUC,OAAV,EAAmBC,WAAnB,EAAgCC,GAAhC,EAAqCpG,IAArC,EAA2CqG,GAA3C,EAAgDC,OAAhD,EAAyDC,MAAzD,EAAiEC,QAAjE,EAA2EC,aAA3E,CAA1B;AACD,KAHD,CApK6B,CAwK7B;;;AACA,UAAMgD,SAAS,GAAG,OAAOe,KAAP,EAAclE,OAAd,EAAuBkD,gBAAvB,EAAyC/C,aAAzC,KAA2D;AAC3E,YAAMgE,gBAAgB,GAAID,KAAK,IAAI,CAAV,IAAiBhG,GAAG,CAACS,WAAJ,CAAgBC,GAAhB,CAAoB4B,UAApB,IAAkC,aAA5E;AACA,YAAMI,SAAS,GAAG,MAAMF,YAAY,EAApC;AACA,YAAMuB,MAAM,GAAI,IAAGiC,KAAM,EAAzB;AACA1Q,MAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAmC9B,aAAnC,EAAmD,WAAnD,CAAL,CAJ2E,CAK3E;;AACA,YAAMiE,qBAAqB,GAAGxD,SAAS,IAAIuD,gBAAgB,GAAG,CAAH,GAAO,CAA3B,CAAvC;AACA,UAAIE,gBAAgB,GAAGD,qBAAvB;AACA,UAAIE,cAAc,GAAGD,gBAArB;;AACA,aAAO,CAAClE,aAAD,IAAkBtM,EAAE,CAACwQ,gBAAD,EAAmBhR,GAAG,CAACuN,SAAD,EAAYT,aAAZ,CAAtB,CAA3B,EAA8E;AAC5E3M,QAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAoC,SAApC,EAA8CoC,gBAA9C,EAAgEC,cAAhE,CAAL;AACA,cAAMC,EAAE,GAAG,MAAM5B,OAAO,CAAC0B,gBAAD,EAAmBC,cAAnB,EAAmCrC,MAAnC,CAAxB;;AACA,YAAIsC,EAAE,CAAC7P,MAAH,IAAa,CAAjB,EAAoB;AAClBlB,UAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAmC9B,aAAnC,EAAmD,WAAnD,CAAL;AACAkE,UAAAA,gBAAgB,GAAGC,cAAnB;AACA,gBAAMxR,OAAO,CAAC+Q,GAAR,CAAY,CAAZ,CAAN;AACAS,UAAAA,cAAc,GAAG,MAAM1L,oBAAoB,EAA3C;;AACA,cAAIsK,gBAAgB,IAAImB,gBAAgB,IAAIC,cAA5C,EAA4D;AAC1D,kBAAME,aAAa,CAACjR,YAAY,CAAC+Q,cAAc,GAAG,CAAlB,CAAb,CAAnB;AACD;;AACD,cAAID,gBAAgB,IAAIzD,SAAxB,EAAmC;AACjCyD,YAAAA,gBAAgB,GAAGD,qBAAnB;AACD;;AACD;AACD,SAZD,MAYO;AACL5Q,UAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAmC9B,aAAnC,EAAmD,UAAnD,CAAL;AACA,gBAAM+B,IAAI,GAAGqC,EAAE,CAAC,CAAD,CAAf;AACA,gBAAME,IAAI,GAAG,MAAMxM,+BAA+B,CAACiK,IAAI,CAACnK,eAAN,CAAlD;AACA,eAAK0M,IAAL;AACA,gBAAMC,IAAI,GAAG,MAAMxM,QAAQ,CAACyM,cAAT,CAAwBzC,IAAI,CAACnK,eAA7B,CAAnB,CALK,CAML;AACA;;AACA,cAAI2M,IAAI,CAACvF,WAAT,EAAsB;AACpB7L,YAAAA,MAAM,CAACoR,IAAI,CAACvF,WAAL,IAAoBsF,IAAI,CAACtF,WAA1B,EAAuC,iDAAvC,CAAN;;AACA,gBAAI+C,IAAI,CAAC/C,WAAT,EAAsB;AACpB7L,cAAAA,MAAM,CAACoR,IAAI,CAACvF,WAAL,IAAoB+C,IAAI,CAAC/C,WAA1B,EAAuC,gDAAvC,CAAN;AACD;AACF,WALD,MAKO;AACL;AACAjI,YAAAA,OAAO,CAACC,GAAR,CAAa,yCAAb;AACAD,YAAAA,OAAO,CAACC,GAAR,CAAYuN,IAAZ;AACD;;AACDlR,UAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAoC,QAApC,EAA6CwC,IAAI,CAACtF,WAAlD,CAAL;AACA2B,UAAAA,UAAU,CAAC2D,IAAD,CAAV;AACA,gBAAMG,KAAK,GAAG,MAAM5C,YAAY,CAACC,MAAD,EAASC,IAAT,CAAhC;AACA1O,UAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAoC,aAApC,EAAkD2C,KAAlD,CAAL;AACA,gBAAMC,OAAO,GAAGD,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,CAAhB;AACApR,UAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAoC,YAApC,EAAiD4C,OAAjD,CAAL;AACA,gBAAM7O,IAAI,GAAG+E,OAAO,CAACiF,OAAD,CAAP,CAAiB8E,OAAjB,CAAyBD,OAAzB,CAAb;;AACA,gBAAME,MAAM,GAAG,OAAOC,KAAP,EAAcC,KAAd,KAAwB;AACrC,gBAAIhJ,KAAK,GAAG,CAACyB,IAAD,EAAOpE,KAAP,EAAc,MAAd,EAAsB2I,MAAtB,EAA8B,YAA9B,EAA4C+C,KAA5C,EAAmDC,KAAnD,CAAZ;AACAzR,YAAAA,KAAK,CAACyI,KAAD,CAAL;AACA,kBAAMiJ,QAAQ,GAAGT,IAAI,CAACtF,WAAtB;AACA,kBAAMgG,GAAG,GAAG,CAAC,MAAMxC,OAAO,CAACuC,QAAD,EAAWA,QAAX,EAAqBF,KAArB,CAAd,EAA2C,CAA3C,CAAZ;AACA/I,YAAAA,KAAK,GAAG,CAAC,GAAGA,KAAJ,EAAW,KAAX,EAAkBkJ,GAAlB,CAAR;AACA3R,YAAAA,KAAK,CAACyI,KAAD,CAAL;AACA,kBAAMmJ,IAAI,GAAG,CAAC,MAAMpD,YAAY,CAACgD,KAAD,EAAQG,GAAR,CAAnB,EAAiC,CAAjC,CAAb;AACAlJ,YAAAA,KAAK,GAAG,CAAC,GAAGA,KAAJ,EAAW,MAAX,EAAmBmJ,IAAnB,CAAR;AACA5R,YAAAA,KAAK,CAACyI,KAAD,CAAL;AACA,kBAAMoJ,KAAK,GAAGJ,KAAK,CAACH,OAAN,CAAcM,IAAd,CAAd;AACAnJ,YAAAA,KAAK,GAAG,CAAC,GAAGA,KAAJ,EAAW,SAAX,EAAsBoJ,KAAtB,CAAR;AACA7R,YAAAA,KAAK,CAACyI,KAAD,CAAL;AACA,mBAAOoJ,KAAP;AACD,WAdD;;AAeA,gBAAMC,SAAS,GAAG,CAACC,KAAD,EAAQC,KAAR,KAAkBT,MAAM,CAAE,MAAKQ,KAAM,EAAb,EAAgBC,KAAhB,CAA1C;;AACAhS,UAAAA,KAAK,CAAE,GAAEkK,IAAK,KAAIpE,KAAM,SAAQ2I,MAAO,IAAG9B,aAAc,iBAAgBlK,IAAI,CAACC,SAAL,CAAe2O,OAAf,CAAwB,EAA3F,CAAL;AACA,gBAAM;AAAEhI,YAAAA;AAAF,cAAW6H,IAAjB;AACA,iBAAO;AACL1O,YAAAA,IADK;AAELsP,YAAAA,SAFK;AAGLzI,YAAAA,IAHK;AAILoH,YAAAA,UAAU,EAAE,KAJP;AAKLwB,YAAAA,IAAI,EAAElS,YAAY,CAACkR,IAAI,CAACtF,WAAN;AALb,WAAP;AAOD;AACF;;AACD3L,MAAAA,KAAK,CAACkK,IAAD,EAAO,GAAP,EAAYpE,KAAZ,EAAmB,MAAnB,EAA2B2I,MAA3B,EAAmC9B,aAAnC,EAAkD,aAAlD,CAAL;AACA,aAAO;AAAE8D,QAAAA,UAAU,EAAE;AAAd,OAAP;AACD,KA9ED;;AA+EA,UAAM1D,IAAI,GAAG,OAAO2D,KAAP,EAAcwB,MAAd,EAAsB1F,OAAtB,EAA+BkD,gBAA/B,EAAiD/C,aAAjD,KAAmE;AAC9E,WAAKuF,MAAL;AACA,aAAO,MAAMvC,SAAS,CAACe,KAAD,EAAQlE,OAAR,EAAiBkD,gBAAjB,EAAmC/C,aAAnC,CAAtB;AACD,KAHD;;AAIA,UAAM7D,IAAI,GAAG,MAAOqJ,KAAP,IAAiB;AAC5B,YAAM/E,SAAS,GAAG,MAAMF,YAAY,EAApC,CAD4B,CAE5B;;AACAlN,MAAAA,KAAK,CAAC,cAAD,EAAiBmS,KAAjB,EAAwB,MAAxB,EAAgC/E,SAAhC,EAA2C,GAA3C,EAAgDlJ,OAAhD,CAAL;AACA,YAAMkO,CAAC,GAAG,MAAMpB,aAAa,CAACnR,GAAG,CAACuN,SAAD,EAAY+E,KAAZ,CAAJ,CAA7B;AACAnS,MAAAA,KAAK,CAAC,mBAAD,EAAsBmS,KAAtB,EAA6B,MAA7B,EAAqC/E,SAArC,EAAgD,GAAhD,EAAqDlJ,OAArD,CAAL;AACA,aAAOkO,CAAP;AACD,KAPD;;AAQA,UAAMC,YAAY,GAAG,YAAYtS,YAAY,CAAC,CAAC,MAAMkN,OAAO,EAAd,EAAkBrB,cAAnB,CAA7C;;AACA,UAAM0G,SAAS,GAAG5H,GAAG,CAAC6H,SAAJ,CAAc;AAAEC,MAAAA,WAAW,EAAE3R;AAAf,KAAd,CAAlB;;AACA,UAAM4R,YAAY,GAAG/H,GAAG,CAACS,WAAJ,CAAgBC,GAAhB,CAAoBsH,KAAzC;;AACA,UAAMC,QAAQ,GAAG,CAACC,EAAD,EAAKC,CAAL,EAAQC,CAAR,EAAWC,GAAX,KAAmB,YAAY;AAC9C,WAAKH,EAAL;AACA,YAAM;AAAEI,QAAAA;AAAF,UAASD,GAAf;AACA,YAAMhF,OAAO,GAAG,MAAML,IAAI,EAA1B;AACA,YAAMuF,GAAG,GAAGR,YAAY,CAACI,CAAD,CAAZ,CAAgBC,CAAhB,CAAZ;AACA,YAAMI,GAAG,GAAG,MAAMnF,OAAO,CAACkF,GAAD,CAAP,EAAlB;AACA,aAAOD,EAAE,CAAC1B,OAAH,CAAW4B,GAAX,CAAP;AACD,KAPD;;AAQA,UAAMC,QAAQ,GAAG7S,cAAc,CAACgS,SAAD,EAAYK,QAAZ,CAA/B,CA/Q6B,CAgR7B;;AACA,WAAO;AAAE1F,MAAAA,OAAF;AAAWoF,MAAAA,YAAX;AAAyBnG,MAAAA,QAAzB;AAAmCa,MAAAA,IAAnC;AAAyCjE,MAAAA,IAAzC;AAA+CsB,MAAAA,GAA/C;AAAoDE,MAAAA,WAApD;AAAiE6I,MAAAA,QAAjE;AAA2EvS,MAAAA,MAAM,EAAEC;AAAnF,KAAP;AACD,GAlRD;;AAoRA,WAASuS,aAAT,CAAuBC,QAAvB,EAAiC;AAC/BvN,IAAAA,KAAK,GAAGuN,QAAR,CAD+B,CAE/B;;AACA,WAAO,IAAP;AACD;;AACD,SAAO;AAAE5I,IAAAA,MAAF;AAAUoB,IAAAA,MAAV;AAAkB7H,IAAAA,cAAlB;AAAkCuG,IAAAA,WAAlC;AAA+CpG,IAAAA,UAAU,EAAEmG,WAA3D;AAAwE1J,IAAAA,MAAM,EAAEC,cAAhF;AAAgGuS,IAAAA;AAAhG,GAAP;AACD,CArYM;AAsYP,OAAO,MAAME,oBAAoB,GAAG,MAAOC,MAAP,IAAkB;AACpD,QAAM7O,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,QAAMX,cAAc,GAAI,IAAIzE,MAAM,CAACmH,MAAX,CAAkB6M,MAAlB,CAAD,CAA4B3M,OAA5B,CAAoClC,QAApC,CAAvB;AACA,QAAMX,GAAG,GAAG,MAAM8C,cAAc,CAAC7C,cAAD,CAAhC;AACA,SAAOD,GAAP;AACD,CALM;AAMP,OAAO,MAAMyP,sBAAsB,GAAG,MAAOC,MAAP,IAAkB;AACtD,QAAM/O,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,QAAMX,cAAc,GAAGzE,MAAM,CAACmH,MAAP,CAAcgN,YAAd,CAA2BD,MAA3B,EAAmC7M,OAAnC,CAA2ClC,QAA3C,CAAvB;AACA,QAAMX,GAAG,GAAG,MAAM8C,cAAc,CAAC7C,cAAD,CAAhC;AACA,SAAOD,GAAP;AACD,CALM;AAMP,OAAO,MAAM4P,iBAAiB,GAAG,YAAY;AAC3C3T,EAAAA,KAAK,CAAE,mBAAF,CAAL;;AACA,MAAIuB,iBAAiB,IAAIG,WAAW,CAACC,IAAZ,IAAoB,QAA7C,EAAuD;AACrD,UAAM+C,QAAQ,GAAG,MAAMC,WAAW,EAAlC,CADqD,CAErD;AACA;;AACA,UAAMiP,MAAM,GAAGlP,QAAQ,CAACmP,SAAT,EAAf;AACA,WAAO,MAAMhN,cAAc,CAAC+M,MAAD,CAA3B;AACD;;AACD,QAAM3P,KAAK,CAAE,0DAAyD3C,aAAc,EAAzE,CAAX;AACD,CAVM,C,CAWP;AACA;;AACA,OAAO,MAAM,CAACyF,SAAD,EAAY+M,SAAZ,IAAyBnT,gBAAgB,CAAC,YAAY;AACjE;AACA,MAAIY,iBAAJ,EAAuB;AACrB;AACA;AACA;AACA;AACA;AACA,WAAO,MAAMoS,iBAAiB,EAA9B;AACD,GAPD,MAOO,IAAIjS,WAAW,CAACC,IAAZ,KAAqB,QAAzB,EAAmC;AACxC;AACA,QAAIjC,MAAM,CAACuF,QAAP,CAAgB8O,OAAhB,KAA4B,OAA5B,IAAuCrU,MAAM,CAACuF,QAAP,CAAgB8O,OAAhB,IAA2B,OAAtE,EAA+E;AAC7E;AACA;AACA,YAAM3B,CAAC,GAAG,IAAI7S,MAAM,CAACuF,SAAP,CAAiBC,eAArB,CAAqC,uBAArC,CAAV;AACA,aAAO,MAAM8B,cAAc,CAACuL,CAAC,CAACyB,SAAF,EAAD,CAA3B;AACD;AACF;;AACD,QAAM5P,KAAK,CAAE,0CAAF,CAAX;AACD,CAnBqD,CAA/C;AAoBP,OAAO,MAAM+P,aAAa,GAAG,YAAY;AACvChU,EAAAA,KAAK,CAAE,+BAAF,CAAL;AACA,QAAM0E,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,QAAMX,cAAc,GAAGzE,MAAM,CAACmH,MAAP,CAAcC,YAAd,GAA6BC,OAA7B,CAAqClC,QAArC,CAAvB;AACA,SAAO,MAAMmC,cAAc,CAAC7C,cAAD,CAA3B;AACD,CALM;AAMP,OAAO,MAAMiQ,cAAc,GAAG,OAAOC,OAAP,EAAgB/N,KAAhB,KAA0B;AACtD,QAAMW,MAAM,GAAG,MAAMC,SAAS,EAA9B;AACA,QAAMC,QAAQ,CAACF,MAAD,EAASoN,OAAT,EAAkB/N,KAAlB,CAAd;AACD,CAHM;AAIP,OAAO,MAAMgO,cAAc,GAAG,MAAOC,eAAP,IAA2B;AACvDpU,EAAAA,KAAK,CAAC,iBAAD,EAAoBoU,eAApB,EAAqC,GAArC,CAAL;AACA1O,EAAAA,sBAAsB,CAAC,gBAAD,CAAtB;AACA,QAAM3B,GAAG,GAAG,MAAMiQ,aAAa,EAA/B;AACA,QAAM1K,EAAE,GAAG,MAAMxF,OAAO,CAACC,GAAD,CAAxB;;AACA,MAAI;AACF/D,IAAAA,KAAK,CAAC,mCAAD,EAAsCsJ,EAAtC,CAAL;AACA,UAAM2K,cAAc,CAAClQ,GAAD,EAAMqQ,eAAN,CAApB;AACApU,IAAAA,KAAK,CAAC,8BAAD,EAAiCsJ,EAAjC,CAAL;AACA,WAAOvF,GAAP;AACD,GALD,CAKE,OAAON,CAAP,EAAU;AACVC,IAAAA,OAAO,CAACC,GAAR,CAAa,wCAAuC2F,EAAG,EAAvD;AACA,UAAM7F,CAAN;AACD;AACF,CAdM;AAeP,OAAO,MAAMmC,cAAc,GAAG,YAAY;AACxC,SAAO7F,YAAY,CAAC,MAAMqF,oBAAoB,EAA3B,CAAnB;AACD,CAFM,C,CAGP;AACA;;AACA,OAAO,MAAM0D,IAAI,GAAG,OAAOqJ,KAAP,EAAc3M,UAAd,KAA6B;AAC/C,QAAM6O,GAAG,GAAG,MAAMzO,cAAc,EAAhC;AACA,SAAO,MAAMoL,aAAa,CAACnR,GAAG,CAACwU,GAAD,EAAMlC,KAAN,CAAJ,EAAkB3M,UAAlB,CAA1B;AACD,CAHM,C,CAIP;AACA;;AACA,OAAO,MAAMwL,aAAa,GAAG,OAAOzL,UAAP,EAAmBC,UAAnB,KAAkC;AAC7DD,EAAAA,UAAU,GAAGxF,YAAY,CAACwF,UAAD,CAAzB;;AACA,MAAIhE,iBAAJ,EAAuB;AACrB,WAAO,MAAM+D,aAAa,CAACC,UAAD,EAAaC,UAAb,CAA1B;AACD,GAFD,MAEO;AACL,WAAO,MAAMY,qBAAqB,CAACb,UAAD,EAAaC,UAAb,CAAlC;AACD;AACF,CAPM,C,CAQP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMoI,cAAc,GAAG,OAAO0G,OAAP,EAAgBC,OAAhB,KAA4B;AACxD,QAAM;AAAEtJ,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAoBqJ,OAAO,CAACpJ,WAAR,CAAoBC,GAA9C;AACA,QAAM;AAAElH,IAAAA,OAAF;AAAW0H,IAAAA,cAAX;AAA2B5F,IAAAA;AAA3B,MAAoCsO,OAA1C;AACA,QAAM;AAAErO,IAAAA;AAAF,MAAcF,iBAAiB,CAACC,IAAD,CAArC;AACA,QAAMqF,OAAO,GAAG,IAAI9L,MAAM,CAAC+L,eAAX,CAA2BL,GAA3B,EAAgCC,QAAhC,CAAhB;AACAlL,EAAAA,KAAK,CAAC,iBAAD,EAAoBkE,OAApB,CAAL;AACAlE,EAAAA,KAAK,CAACsU,OAAD,CAAL;AACA,QAAM5P,QAAQ,GAAG,MAAMC,WAAW,EAAlC;AACA,QAAM0P,GAAG,GAAG,MAAMjP,oBAAoB,EAAtC;AACA,QAAMoP,WAAW,GAAGxT,MAAM,CAACiF,OAAD,CAAN,GAAkB,IAAlB,GAAyB,IAA7C;AACAjG,EAAAA,KAAK,CAAC,mCAAD,EAAsCwU,WAAtC,EAAmD,KAAnD,CAAL,CAVwD,CAWxD;AACA;AACA;;AACA,QAAMC,IAAI,GAAG,MAAM/P,QAAQ,CAACyK,OAAT,CAAiB;AAClCC,IAAAA,SAAS,EAAExD,cADuB;AAElCyD,IAAAA,OAAO,EAAEgF,GAFyB;AAGlCnQ,IAAAA,OAAO,EAAEA,OAHyB;AAIlCoL,IAAAA,MAAM,EAAE,CAACjE,OAAO,CAACuD,SAAR,CAAkBW,aAAlB,CAAgCiF,WAAhC,CAAD;AAJ0B,GAAjB,CAAnB;;AAMA,MAAIC,IAAI,CAACvT,MAAL,GAAc,CAAlB,EAAqB;AACnB,UAAM+C,KAAK,CAAE,0CAAyC2H,cAAe,GAAzD,GACT,6BAA4ByI,GAAI,mCADxB,CAAX;AAED;;AACD,QAAM1Q,GAAG,GAAG8Q,IAAI,CAAC,CAAD,CAAhB;;AACA,MAAI9Q,GAAG,CAACgI,WAAJ,KAAoBC,cAAxB,EAAwC;AACtC,UAAM3H,KAAK,CAAE,wCAAuCN,GAAG,CAACgI,WAAY,GAAxD,GACT,sCAAqCC,cAAe,GAD5C,CAAX;AAED;;AACD5L,EAAAA,KAAK,CAAE,kCAAF,CAAL,CA7BwD,CA8BxD;AACA;AACA;;AACA,QAAM0U,MAAM,GAAG,MAAMhQ,QAAQ,CAACiQ,OAAT,CAAiBzQ,OAAjB,CAArB,CAjCwD,CAkCxD;;AACA,QAAM0Q,UAAU,GAAGvJ,OAAO,CAACwJ,oBAAR,CAA6B,GAAG5O,OAAhC,EAAyCzD,IAA5D;;AACA,MAAI,OAAOoS,UAAP,KAAsB,QAA1B,EAAoC;AAClC;AACA,UAAM3Q,KAAK,CAAE,wCAAuC2Q,UAAW,EAApD,CAAX;AACD;;AACD,MAAI,CAACA,UAAU,CAACpT,UAAX,CAAsB+S,OAAO,CAACpJ,WAAR,CAAoBC,GAApB,CAAwBF,QAA9C,CAAL,EAA8D;AAC5D,UAAMjH,KAAK,CAAE,oEAAF,CAAX;AACD,GA1CuD,CA2CxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAM6Q,OAAO,GAAG,EAAhB;AACA,QAAMC,QAAQ,GAAG,GAAjB;AACA,QAAMC,QAAQ,GAAGJ,UAAU,CAACK,KAAX,CAAiB,CAAjB,EAAoBH,OAApB,IAA+BF,UAAU,CAACK,KAAX,CAAiBH,OAAO,GAAGC,QAA3B,CAAhD;;AACA,MAAIC,QAAQ,CAAC9T,MAAT,IAAmB,CAAvB,EAA0B;AACxB,UAAM+C,KAAK,CAAE,2CAAF,CAAX;AACD;;AACD,MAAIyQ,MAAM,KAAKM,QAAf,EAAyB;AACvB;AACA;AACA;AACA;AACA;AACA,UAAME,YAAY,GAAGN,UAAU,CAACK,KAAX,CAAiBH,OAAjB,CAArB;AACA,UAAMK,YAAY,GAAGT,MAAM,CAACO,KAAP,CAAaH,OAAb,CAArB;;AACA,QAAIK,YAAY,CAACjU,MAAb,KAAwB,CAAxB,IAA6B,CAACgU,YAAY,CAACE,QAAb,CAAsBD,YAAtB,CAAlC,EAAuE;AACrE;AACA,YAAME,UAAU,GAAG,EAAnB;AACA3R,MAAAA,OAAO,CAACC,GAAR,CAAY,8CAAZ;AACAD,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBqR,QAAQ,CAACC,KAAT,CAAe,CAAf,EAAkBI,UAAlB,CAAjC;AACA3R,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqB+Q,MAAM,CAACO,KAAP,CAAa,CAAb,EAAgBI,UAAhB,CAAjC;AACA3R,MAAAA,OAAO,CAACC,GAAR,CAAY,8CAAZ;AACAD,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBqR,QAAQ,CAACC,KAAT,CAAeD,QAAQ,CAAC9T,MAAT,GAAkBmU,UAAjC,CAAjC;AACA3R,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqB+Q,MAAM,CAACO,KAAP,CAAaP,MAAM,CAACxT,MAAP,GAAgBmU,UAA7B,CAAjC;AACA3R,MAAAA,OAAO,CAACC,GAAR,CAAY,8CAAZ;AACAD,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBqR,QAAQ,CAAC9T,MAA1C;AACAwC,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqB+Q,MAAM,CAACxT,MAAxC;AACAwC,MAAAA,OAAO,CAACC,GAAR,CAAY,8CAAZ;AACA,YAAMM,KAAK,CAAE,qDAAF,CAAX;AACD;AACF,GApFuD,CAqFxD;AACA;AACA;;;AACA,SAAO,IAAP;AACD,CAzFM;AA0FP;;AACA,OAAO,MAAMqR,YAAY,GAAG,KAArB;AACP;;AACA,OAAO,MAAMC,UAAU,GAAG,KAAnB;AACP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAStO,aAAT,CAAuBmH,GAAvB,EAA4B;AACjC,SAAOrO,YAAY,CAACR,MAAM,CAACiW,KAAP,CAAaC,UAAb,CAAwBrH,GAAG,CAACsH,QAAJ,EAAxB,EAAwC,OAAxC,CAAD,CAAnB;AACD;AACD,OAAO,MAAMC,cAAc,GAAG1O,aAAa,CAAC,CAAD,CAApC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAS2O,cAAT,CAAwBxH,GAAxB,EAA6ByH,QAAQ,GAAG,EAAxC,EAA4C;AACjD;AACA,MAAI,EAAEC,MAAM,CAACC,SAAP,CAAiBF,QAAjB,KAA8B,KAAKA,QAArC,CAAJ,EAAoD;AAClD,UAAM5R,KAAK,CAAE,0DAAyD4R,QAAS,GAApE,CAAX;AACD,GAJgD,CAKjD;;;AACAA,EAAAA,QAAQ,GAAGG,IAAI,CAACC,GAAL,CAASJ,QAAT,EAAmB,EAAnB,CAAX;AACA,QAAMK,gBAAgB,GAAG,KAAKL,QAA9B;AACA,QAAMM,MAAM,GAAGpW,YAAY,CAACqO,GAAD,CAAZ,CACZgI,GADY,CACRrW,YAAY,CAAC,EAAD,CAAZ,CAAiBsW,GAAjB,CAAqBH,gBAArB,CADQ,CAAf;AAEA,QAAMI,MAAM,GAAG/W,MAAM,CAACiW,KAAP,CAAae,WAAb,CAAyBJ,MAAzB,EAAiCN,QAAjC,CAAf,CAViD,CAWjD;;AACA,MAAIS,MAAM,CAACrB,KAAP,CAAaqB,MAAM,CAACpV,MAAP,GAAgB,CAA7B,KAAmC,IAAvC,EAA6C;AAC3C,WAAOoV,MAAM,CAACrB,KAAP,CAAa,CAAb,EAAgBqB,MAAM,CAACpV,MAAP,GAAgB,CAAhC,CAAP;AACD,GAFD,MAEO;AACL,WAAOoV,MAAP;AACD;AACF;AACD,OAAO,MAAM9D,WAAW,GAAG3R,cAApB","sourcesContent":["// ****************************************************************************\n// standard library for Javascript users\n// ****************************************************************************\nimport Timeout from 'await-timeout';\nimport ethers from 'ethers';\nimport http from 'http';\nimport url from 'url';\nimport { window, process } from './shim.mjs';\nimport { getConnectorMode } from './ConnectorMode.mjs';\nimport { add, assert, bigNumberify, debug, envDefault, eq, ge, getDEBUG, lt, getViewsHelper, deferContract, makeRandom, argsSplit } from './shared.mjs';\nimport { memoizeThunk, replaceableThunk } from './shared_impl.mjs';\nexport * from './shared.mjs';\nimport { stdlib as compiledStdlib, typeDefs } from './ETH_compiled.mjs';\nimport waitPort from './waitPort.mjs';\n\nfunction isNone(m) {\n  return m.length === 0;\n}\n\nfunction isSome(m) {\n  return !isNone(m);\n}\nconst Some = (m) => [m];\nconst None = [];\nvoid(isSome);\nconst connectorMode = getConnectorMode();\n// Certain functions either behave differently,\n// or are only available on an \"isolated\" network.\n// Note: ETH-browser is NOT considered isolated.\nconst isIsolatedNetwork = connectorMode.startsWith('ETH-test-dockerized') ||\n  // @ts-ignore\n  process.env['REACH_ISOLATED_NETWORK'];\nconst networkDesc = (connectorMode == 'ETH-test-dockerized-geth' ||\n  connectorMode == 'ETH-live') ? {\n  type: 'uri',\n  uri: envDefault(process.env.ETH_NODE_URI, 'http://localhost:8545'),\n  network: envDefault(process.env.ETH_NODE_NETWORK, 'unspecified'),\n} : connectorMode == 'ETH-browser' ? {\n  type: 'window',\n} : {\n  type: 'skip',\n};\nconst getPortConnection = memoizeThunk(async () => {\n  debug('getPortConnection');\n  if (networkDesc.type != 'uri') {\n    return;\n  }\n  await waitPort(networkDesc.uri);\n});\n// XXX: doesn't even retry, just returns the first attempt\nconst doHealthcheck = async () => {\n  debug('doHealthcheck');\n  if (networkDesc.type != 'uri') {\n    return;\n  }\n  const uriObj = url.parse(networkDesc.uri);\n  // XXX the code below only supports http\n  if (uriObj.protocol !== 'http:') {\n    return;\n  }\n  await new Promise((resolve, reject) => {\n    const data = JSON.stringify({\n      jsonrpc: '2.0',\n      method: 'web3_clientVersion',\n      params: [],\n      id: 67,\n    });\n    debug('Sending health check request...');\n    const opts = {\n      ...uriObj,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': data.length,\n      },\n    };\n    const req = http.request(opts, (res) => {\n      debug(`statusCode:`, res.statusCode);\n      res.on('data', (d) => {\n        debug('rpc health check succeeded');\n        if (getDEBUG()) {\n          process.stdout.write(d);\n        }\n        resolve({ res, d });\n      });\n    });\n    req.on('error', (e) => {\n      console.log('rpc health check failed');\n      console.log(e);\n      reject(e);\n    });\n    req.write(data);\n    debug('attached all the handlers...');\n    req.end();\n    debug('req.end...');\n  });\n};\nconst getDevnet = memoizeThunk(async () => {\n  await getPortConnection();\n  return await doHealthcheck();\n});\n/** @description convenience function for drilling down to the actual address */\nconst getAddr = async (acc) => {\n  if (!acc.networkAccount)\n    throw Error(`Expected acc.networkAccount`);\n  // TODO better type design here\n  // @ts-ignore\n  if (acc.networkAccount.address) {\n    // @ts-ignore\n    return acc.networkAccount.address;\n  }\n  if (acc.networkAccount.getAddress) {\n    return await acc.networkAccount.getAddress();\n  }\n  throw Error(`Expected acc.networkAccount.address or acc.networkAccount.getAddress`);\n};\nconst rejectInvalidReceiptFor = async (txHash, r) => new Promise((resolve, reject) => !r ? reject(`No receipt for txHash: ${txHash}`) :\n  r.transactionHash !== txHash ? reject(`Bad txHash; ${txHash} !== ${r.transactionHash}`) :\n  !r.status ? reject(`Transaction: ${txHash} was reverted by EVM\\n${r}`) :\n  resolve(r));\nconst fetchAndRejectInvalidReceiptFor = async (txHash) => {\n  const provider = await getProvider();\n  const r = await provider.getTransactionReceipt(txHash);\n  return await rejectInvalidReceiptFor(txHash, r);\n};\nconst [getProvider, setProvider] = replaceableThunk(async () => {\n  if (networkDesc.type == 'uri') {\n    await getDevnet();\n    const provider = new ethers.providers.JsonRpcProvider(networkDesc.uri);\n    provider.pollingInterval = 500; // ms\n    return provider;\n  } else if (networkDesc.type == 'window') {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(window.ethereum);\n      // The proper way to ask MetaMask to enable itself is eth_requestAccounts\n      // https://eips.ethereum.org/EIPS/eip-1102\n      await provider.send('eth_requestAccounts', []);\n      return provider;\n    } else {\n      throw Error(`window.ethereum is not defined`);\n    }\n  } else {\n    // This lib was imported, but not for its net connection.\n    throw Error(`Using stdlib/ETH is incompatible with REACH_CONNECTOR_MODE=${connectorMode}`);\n  }\n});\nconst getNetworkTimeNumber = async () => {\n  const provider = await getProvider();\n  return await provider.getBlockNumber();\n};\nconst fastForwardTo = async (targetTime, onProgress) => {\n  // console.log(`>>> FFWD TO: ${targetTime}`);\n  const onProg = onProgress || (() => {});\n  requireIsolatedNetwork('fastForwardTo');\n  let currentTime;\n  while (lt(currentTime = await getNetworkTime(), targetTime)) {\n    onProg({ currentTime, targetTime });\n    await stepTime();\n  }\n  // Also report progress at completion time\n  onProg({ currentTime, targetTime });\n  // console.log(`<<< FFWD TO: ${targetTime} complete. It's ${currentTime}`);\n  return currentTime;\n};\nconst requireIsolatedNetwork = (label) => {\n  if (!isIsolatedNetwork) {\n    throw Error(`Invalid operation ${label} in REACH_CONNECTOR_MODE=${connectorMode}`);\n  }\n};\nconst initOrDefaultArgs = (init) => ({\n  argsMay: init ? Some(init.args) : None,\n  value: init ? init.value : bigNumberify(0),\n});\n// onProgress callback is optional, it will be given an obj\n// {currentTime, targetTime}\nconst actuallyWaitUntilTime = async (targetTime, onProgress) => {\n  const onProg = onProgress || (() => {});\n  const provider = await getProvider();\n  return await new Promise((resolve) => {\n    const onBlock = async (currentTimeNum) => {\n      const currentTime = bigNumberify(currentTimeNum);\n      // Does not block on the progress fn if it is async\n      onProg({ currentTime, targetTime });\n      if (ge(currentTime, targetTime)) {\n        provider.off('block', onBlock);\n        resolve(currentTime);\n      }\n    };\n    provider.on('block', onBlock);\n    // Also \"re-emit\" the current block\n    // Note: this sometimes causes the starting block\n    // to be processed twice, which should be harmless.\n    getNetworkTime().then(onBlock);\n  });\n};\nconst getDummyAccount = memoizeThunk(async () => {\n  const provider = await getProvider();\n  const networkAccount = ethers.Wallet.createRandom().connect(provider);\n  const acc = await connectAccount(networkAccount);\n  return acc;\n});\nconst stepTime = async () => {\n  requireIsolatedNetwork('stepTime');\n  const faucet = await getFaucet();\n  const acc = await getDummyAccount();\n  return await transfer(faucet, acc, parseCurrency(0));\n};\n// ****************************************************************************\n// Common Interface Exports\n// ****************************************************************************\nexport const { addressEq, digest } = compiledStdlib;\nexport const { T_Null, T_Bool, T_UInt, T_Tuple, T_Array, T_Object, T_Data, T_Bytes, T_Address, T_Digest, T_Struct } = typeDefs;\nexport const { randomUInt, hasRandom } = makeRandom(32);\nexport { getProvider, setProvider };\n// TODO\nexport function setProviderByEnv(env) {\n  void(env);\n  throw Error(`setProviderByEnv not yet supported on ETH`);\n}\n// TODO\nexport function setProviderByName(providerName) {\n  void(providerName);\n  throw Error(`setProviderByName not yet supported on ETH`);\n}\n// TODO\nexport function providerEnvByName(providerName) {\n  void(providerName);\n  throw Error(`providerEnvByName not yet supported on ETH`);\n}\nexport const balanceOf = async (acc) => {\n  const { networkAccount } = acc;\n  if (!networkAccount)\n    throw Error(`acc.networkAccount missing. Got: ${acc}`);\n  if (networkAccount.getBalance) {\n    return bigNumberify(await networkAccount.getBalance());\n  }\n  const addr = await getAddr(acc);\n  if (addr) {\n    const provider = await getProvider();\n    return bigNumberify(await provider.getBalance(addr));\n  }\n  throw Error(`address missing. Got: ${networkAccount}`);\n};\nconst doTxn = async (dhead, tp) => {\n  debug({ ...dhead, step: `pre call` });\n  const rt = await tp;\n  debug({ ...dhead, rt, step: `pre wait` });\n  const rm = await rt.wait();\n  debug({ ...dhead, rt, rm, step: `pre receipt` });\n  assert(rm !== null, `receipt wait null`);\n  const ro = await fetchAndRejectInvalidReceiptFor(rm.transactionHash);\n  debug({ ...dhead, rt, rm, ro, step: `post receipt` });\n  // ro's blockNumber might be interesting\n  void(ro);\n};\nconst doCall = async (dhead, ctc, funcName, args, value, gasLimit) => {\n  const dpre = { ...dhead, funcName, args, value };\n  debug({ ...dpre, step: `pre call` });\n  return await doTxn(dpre, ctc[funcName](...args, { value, gasLimit }));\n};\n/** @description Arg order follows \"src before dst\" convention */\nexport const transfer = async (from, to, value, token = false) => {\n  const sender = from.networkAccount;\n  const receiver = getAddr(to);\n  const valueb = bigNumberify(value);\n  const dhead = { kind: 'transfer' };\n  if (!token) {\n    const txn = { to: receiver, value: valueb };\n    debug('sender.sendTransaction(', txn, ')');\n    return await doTxn(dhead, sender.sendTransaction(txn));\n  } else {\n    const tokCtc = new ethers.Contract(token, ERC20_ABI, sender);\n    return await doCall(dhead, tokCtc, 'transfer', [receiver, valueb], bigNumberify(0), undefined);\n  }\n};\nconst ERC20_ABI = [{\n    'constant': false,\n    'inputs': [{\n        'name': '_spender',\n        'type': 'address',\n      },\n      {\n        'name': '_value',\n        'type': 'uint256',\n      },\n    ],\n    'name': 'approve',\n    'outputs': [{\n      'name': '',\n      'type': 'bool',\n    }],\n    'payable': false,\n    'stateMutability': 'nonpayable',\n    'type': 'function',\n  },\n  {\n    'constant': true,\n    'inputs': [{\n      'name': 'account',\n      'type': 'address',\n    }],\n    'name': 'balanceOf',\n    'outputs': [{\n      'name': '',\n      'type': 'uint256',\n    }],\n    'payable': false,\n    'stateMutability': 'view',\n    'type': 'function',\n  },\n  {\n    'constant': false,\n    'inputs': [{\n        'name': '_recipient',\n        'type': 'address',\n      },\n      {\n        'name': '_amount',\n        'type': 'uint256',\n      },\n    ],\n    'name': 'transfer',\n    'outputs': [{\n      'name': '',\n      'type': 'bool',\n    }],\n    'payable': false,\n    'stateMutability': 'nonpayable',\n    'type': 'function',\n  },\n];\nexport const connectAccount = async (networkAccount) => {\n  // @ts-ignore // TODO\n  if (networkAccount.getAddress && !networkAccount.address) {\n    // @ts-ignore\n    networkAccount.address = await getAddr({ networkAccount });\n  }\n  // XXX networkAccount MUST be a Wallet or Signer to deploy/attach\n  const provider = await getProvider();\n  const address = await getAddr({ networkAccount });\n  if (!address) {\n    throw Error(`Expected networkAccount.address: ${networkAccount}`);\n  }\n  const shad = address.substring(2, 6);\n  let label = shad;\n  const iam = (some_addr) => {\n    if (some_addr == address) {\n      return address;\n    } else {\n      throw Error(`I should be ${some_addr}, but am ${address}`);\n    }\n  };\n  const selfAddress = () => {\n    return address;\n  };\n  let gasLimit;\n  const setGasLimit = (ngl) => {\n    gasLimit = bigNumberify(ngl);\n  };\n  const deploy = (bin) => {\n    if (!ethers.Signer.isSigner(networkAccount)) {\n      throw Error(`Signer required to deploy, ${networkAccount}`);\n    }\n    const { infoP, resolveInfo } = (() => {\n      let resolveInfo = (info) => { void(info); };\n      const infoP = new Promise(resolve => {\n        resolveInfo = resolve;\n      });\n      return { infoP, resolveInfo };\n    })();\n    const performDeploy = (init) => {\n      debug(shad, ': performDeploy with', init);\n      const { argsMay, value } = initOrDefaultArgs(init);\n      const { ABI, Bytecode } = bin._Connectors.ETH;\n      debug(shad, ': making contract factory');\n      const factory = new ethers.ContractFactory(ABI, Bytecode, networkAccount);\n      (async () => {\n        debug(shad, `: deploying factory`);\n        const contract = await factory.deploy(...argsMay, { value, gasLimit });\n        debug(shad, `: deploying factory; done:`, contract.address);\n        debug(shad, `: waiting for receipt:`, contract.deployTransaction.hash);\n        const deploy_r = await contract.deployTransaction.wait();\n        debug(shad, `: got receipt;`, deploy_r.blockNumber);\n        const info = {\n          address: contract.address,\n          creation_block: deploy_r.blockNumber,\n          transactionHash: deploy_r.transactionHash,\n          init,\n        };\n        resolveInfo(info);\n      })();\n      return attach(bin, infoP);\n    };\n    const attachDeferDeploy = () => {\n      let setImpl;\n      const implP = new Promise((resolve) => { setImpl = resolve; });\n      const implNow = {\n        stdlib: compiledStdlib,\n        sendrecv: async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay, sim_p) => {\n          debug(shad, `:`, label, 'sendrecv m', funcNum, `(deferred deploy)`);\n          void(evt_cnt);\n          void(sim_p);\n          // TODO: munge/unmunge roundtrip?\n          void(hasLastTime);\n          void(tys);\n          void(out_tys);\n          const [value, toks] = pay;\n          // The following must be true for the first sendrecv.\n          try {\n            assert(onlyIf, `verifyContract: onlyIf must be true`);\n            assert(soloSend, `verifyContract: soloSend must be true`);\n            assert(eq(funcNum, 1), `verifyContract: funcNum must be 1`);\n            assert(!timeout_delay, `verifyContract: no timeout`);\n            assert(toks.length == 0, `verifyContract: no tokens`);\n          } catch (e) {\n            throw Error(`impossible: Deferred deploy sendrecv assumptions violated.\\n${e}`);\n          }\n          // shim impl is replaced with real impl\n          setImpl(performDeploy({ args: [\n              [0], args,\n            ], value }));\n          await infoP; // Wait for the deploy to actually happen.\n          // simulated recv\n          return await impl.recv(funcNum, evt_cnt, out_tys, false, timeout_delay);\n        },\n      };\n      const impl = deferContract(true, implP, implNow);\n      return impl;\n    };\n    switch (bin._Connectors.ETH.deployMode) {\n      case 'DM_firstMsg':\n        return attachDeferDeploy();\n      case 'DM_constructor':\n        return performDeploy();\n      default:\n        throw Error(`Unrecognized deployMode: ${bin._Connectors.ETH.deployMode}`);\n    }\n  };\n  const attach = (bin, infoP) => {\n    // unofficially: infoP can also be Contract\n    // This should be considered deprecated\n    // TODO: remove at next Reach version bump?\n    // @ts-ignore\n    if (infoP.getInfo) {\n      console.log(`Calling attach with another Contract is deprecated.` +\n        ` Please replace accBob.attach(backend, ctcAlice)` +\n        ` with accBob.attach(bin, ctcAlice.getInfo())`);\n      // @ts-ignore\n      infoP = infoP.getInfo();\n    }\n    const ABI = JSON.parse(bin._Connectors.ETH.ABI);\n    // Attached state\n    const { getLastBlock, setLastBlock } = (() => {\n      let lastBlock = null;\n      const setLastBlock = (n) => {\n        debug(`lastBlock from`, lastBlock, `to`, n);\n        lastBlock = n;\n      };\n      const getLastBlock = async () => {\n        if (typeof lastBlock === 'number') {\n          return lastBlock;\n        }\n        const info = await infoP;\n        setLastBlock(info.creation_block);\n        return info.creation_block;\n      };\n      return { getLastBlock, setLastBlock };\n    })();\n    const updateLast = (o) => {\n      if (!o.blockNumber) {\n        console.log(o);\n        throw Error(`Expected blockNumber in ${Object.keys(o)}`);\n      }\n      setLastBlock(o.blockNumber);\n    };\n    const getC = (() => {\n      let _ethersC = null;\n      return async () => {\n        if (_ethersC) {\n          return _ethersC;\n        }\n        const info = await infoP;\n        await verifyContract(info, bin);\n        debug(shad, `: contract verified`);\n        if (!ethers.Signer.isSigner(networkAccount)) {\n          throw Error(`networkAccount must be a Signer (read: Wallet). ${networkAccount}`);\n        }\n        _ethersC = new ethers.Contract(info.address, ABI, networkAccount);\n        return _ethersC;\n      };\n    })();\n    const callC = async (dhead, funcName, arg, pay) => {\n      const [value, toks] = pay;\n      const ethersC = await getC();\n      const zero = bigNumberify(0);\n      const actualCall = async () => await doCall({ ...dhead, kind: 'reach' }, ethersC, funcName, [arg], value, gasLimit);\n      const callTok = async (tok, amt) => {\n        // @ts-ignore\n        const tokCtc = new ethers.Contract(tok, ERC20_ABI, networkAccount);\n        const tokBalance = await tokCtc['balanceOf'](address);\n        debug({ ...dhead, kind: 'token' }, 'balanceOf', tokBalance);\n        assert(tokBalance >= amt, `local account token balance insufficient: ${tokBalance} < ${amt}`);\n        await doCall({ ...dhead, kind: 'token' }, tokCtc, 'approve', [ethersC.address, amt], zero, gasLimit);\n      };\n      const maybePayTok = async (i) => {\n        if (i < toks.length) {\n          const [amt, tok] = toks[i];\n          await callTok(tok, amt);\n          try {\n            await maybePayTok(i + 1);\n          } catch (e) {\n            await callTok(tok, zero);\n            throw e;\n          }\n        } else {\n          await actualCall();\n        }\n      };\n      await maybePayTok(0);\n    };\n    const getEventData = async (ok_evt, ok_e) => {\n      const ethersC = await getC();\n      const ok_args_abi = ethersC.interface.getEvent(ok_evt).inputs;\n      const { args } = ethersC.interface.parseLog(ok_e);\n      return ok_args_abi.map(a => args[a.name]);\n    };\n    const getLogs = async (fromBlock, toBlock, ok_evt) => {\n      if (fromBlock > toBlock) {\n        return [];\n      }\n      const ethersC = await getC();\n      return await provider.getLogs({\n        fromBlock,\n        toBlock,\n        address: ethersC.address,\n        topics: [ethersC.interface.getEventTopic(ok_evt)],\n      });\n    };\n    const getInfo = async () => await infoP;\n    const sendrecv_impl = async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay) => {\n      void(hasLastTime);\n      const doRecv = async (waitIfNotPresent) => await recv_impl(funcNum, out_tys, waitIfNotPresent, timeout_delay);\n      if (!onlyIf) {\n        return await doRecv(true);\n      }\n      const funcName = `m${funcNum}`;\n      if (tys.length !== args.length) {\n        throw Error(`tys.length (${tys.length}) !== args.length (${args.length})`);\n      }\n      const dhead = [shad, label, 'send', funcName, timeout_delay, 'SEND'];\n      debug([...dhead, 'ARGS', args]);\n      const [args_svs, args_msg] = argsSplit(args, evt_cnt);\n      const [tys_svs, tys_msg] = argsSplit(tys, evt_cnt);\n      // @ts-ignore XXX\n      const arg_ty = T_Tuple([T_Tuple(tys_svs), T_Tuple(tys_msg)]);\n      const arg = arg_ty.munge([args_svs, args_msg]);\n      debug([...dhead, 'START', arg]);\n      const lastBlock = await getLastBlock();\n      let block_send_attempt = lastBlock;\n      let block_repeat_count = 0;\n      while (!timeout_delay || lt(block_send_attempt, add(lastBlock, timeout_delay))) {\n        debug([...dhead, 'TRY']);\n        try {\n          debug([...dhead, 'ARG', arg, pay]);\n          await callC(dhead, funcName, arg, pay);\n        } catch (e) {\n          if (!soloSend) {\n            debug([...dhead, `SKIPPING`, e]);\n          } else {\n            debug([...dhead, `ERROR`, e.stack]);\n            // XXX What should we do...? If we fail, but there's no timeout delay... then we should just die\n            await Timeout.set(1);\n            const current_block = await getNetworkTimeNumber();\n            if (current_block == block_send_attempt) {\n              block_repeat_count++;\n            }\n            block_send_attempt = current_block;\n            if ( /* timeout_delay && */ block_repeat_count > 32) {\n              if (e.code === 'UNPREDICTABLE_GAS_LIMIT') {\n                let error = e;\n                while (error.error) {\n                  error = error.error;\n                }\n                console.log(`impossible: The message you are trying to send appears to be invalid.`);\n                console.log(error);\n              }\n              console.log(`args:`);\n              console.log(arg);\n              throw Error(`${dhead} REPEAT @ ${block_send_attempt} x ${block_repeat_count}`);\n            }\n            debug([...dhead, `TRY FAIL`, lastBlock, current_block, block_repeat_count, block_send_attempt]);\n            continue;\n          }\n        }\n        return await doRecv(false);\n      }\n      // XXX If we were trying to join, but we got sniped, then we'll\n      // think that there is a timeout and then we'll wait forever for\n      // the timeout message.\n      debug([...dhead, `FAIL/TIMEOUT`]);\n      return { didTimeout: true };\n    };\n    const sendrecv = async (funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay, sim_p) => {\n      void(sim_p);\n      return await sendrecv_impl(funcNum, evt_cnt, hasLastTime, tys, args, pay, out_tys, onlyIf, soloSend, timeout_delay);\n    };\n    // https://docs.ethers.io/ethers.js/html/api-contract.html#configuring-events\n    const recv_impl = async (okNum, out_tys, waitIfNotPresent, timeout_delay) => {\n      const isFirstMsgDeploy = (okNum == 1) && (bin._Connectors.ETH.deployMode == 'DM_firstMsg');\n      const lastBlock = await getLastBlock();\n      const ok_evt = `e${okNum}`;\n      debug(shad, ':', label, 'recv', ok_evt, timeout_delay, `--- START`);\n      // look after the last block\n      const block_poll_start_init = lastBlock + (isFirstMsgDeploy ? 0 : 1);\n      let block_poll_start = block_poll_start_init;\n      let block_poll_end = block_poll_start;\n      while (!timeout_delay || lt(block_poll_start, add(lastBlock, timeout_delay))) {\n        debug(shad, ':', label, 'recv', ok_evt, `--- GET`, block_poll_start, block_poll_end);\n        const es = await getLogs(block_poll_start, block_poll_end, ok_evt);\n        if (es.length == 0) {\n          debug(shad, ':', label, 'recv', ok_evt, timeout_delay, `--- RETRY`);\n          block_poll_start = block_poll_end;\n          await Timeout.set(1);\n          block_poll_end = await getNetworkTimeNumber();\n          if (waitIfNotPresent && block_poll_start == block_poll_end) {\n            await waitUntilTime(bigNumberify(block_poll_end + 1));\n          }\n          if (block_poll_start <= lastBlock) {\n            block_poll_start = block_poll_start_init;\n          }\n          continue;\n        } else {\n          debug(shad, ':', label, 'recv', ok_evt, timeout_delay, `--- OKAY`);\n          const ok_e = es[0];\n          const ok_r = await fetchAndRejectInvalidReceiptFor(ok_e.transactionHash);\n          void(ok_r);\n          const ok_t = await provider.getTransaction(ok_e.transactionHash);\n          // The .gas field doesn't exist on this anymore, apparently?\n          // debug(`${ok_evt} gas was ${ok_t.gas} ${ok_t.gasPrice}`);\n          if (ok_t.blockNumber) {\n            assert(ok_t.blockNumber == ok_r.blockNumber, 'recept & transaction block numbers should match');\n            if (ok_e.blockNumber) {\n              assert(ok_t.blockNumber == ok_e.blockNumber, 'event & transaction block numbers should match');\n            }\n          } else {\n            // XXX For some reason ok_t sometimes doesn't have blockNumber\n            console.log(`WARNING: no blockNumber on transaction.`);\n            console.log(ok_t);\n          }\n          debug(shad, ':', label, 'recv', ok_evt, `--- AT`, ok_r.blockNumber);\n          updateLast(ok_r);\n          const ok_ed = await getEventData(ok_evt, ok_e);\n          debug(shad, ':', label, 'recv', ok_evt, `--- DATA --`, ok_ed);\n          const ok_vals = ok_ed[0][1];\n          debug(shad, ':', label, 'recv', ok_evt, `--- MSG --`, ok_vals);\n          const data = T_Tuple(out_tys).unmunge(ok_vals);\n          const getLog = async (l_evt, l_ctc) => {\n            let dhead = [shad, label, 'recv', ok_evt, '--- getLog', l_evt, l_ctc];\n            debug(dhead);\n            const theBlock = ok_r.blockNumber;\n            const l_e = (await getLogs(theBlock, theBlock, l_evt))[0];\n            dhead = [...dhead, 'log', l_e];\n            debug(dhead);\n            const l_ed = (await getEventData(l_evt, l_e))[0];\n            dhead = [...dhead, 'data', l_ed];\n            debug(dhead);\n            const l_edu = l_ctc.unmunge(l_ed);\n            dhead = [...dhead, 'unmunge', l_edu];\n            debug(dhead);\n            return l_edu;\n          };\n          const getOutput = (o_lab, o_ctc) => getLog(`oe_${o_lab}`, o_ctc);\n          debug(`${shad}: ${label} recv ${ok_evt} ${timeout_delay} --- OKAY --- ${JSON.stringify(ok_vals)}`);\n          const { from } = ok_t;\n          return {\n            data,\n            getOutput,\n            from,\n            didTimeout: false,\n            time: bigNumberify(ok_r.blockNumber),\n          };\n        }\n      }\n      debug(shad, ':', label, 'recv', ok_evt, timeout_delay, '--- TIMEOUT');\n      return { didTimeout: true };\n    };\n    const recv = async (okNum, ok_cnt, out_tys, waitIfNotPresent, timeout_delay) => {\n      void(ok_cnt);\n      return await recv_impl(okNum, out_tys, waitIfNotPresent, timeout_delay);\n    };\n    const wait = async (delta) => {\n      const lastBlock = await getLastBlock();\n      // Don't wait from current time, wait from last_block\n      debug('=====Waiting', delta, 'from', lastBlock, ':', address);\n      const p = await waitUntilTime(add(lastBlock, delta));\n      debug('=====Done waiting', delta, 'from', lastBlock, ':', address);\n      return p;\n    };\n    const creationTime = async () => bigNumberify((await getInfo()).creation_block);\n    const views_bin = bin._getViews({ reachStdlib: compiledStdlib });\n    const views_namesm = bin._Connectors.ETH.views;\n    const getView1 = (vs, v, k, vim) => async () => {\n      void(vs);\n      const { ty } = vim;\n      const ethersC = await getC();\n      const vkn = views_namesm[v][k];\n      const val = await ethersC[vkn]();\n      return ty.unmunge(val);\n    };\n    const getViews = getViewsHelper(views_bin, getView1);\n    // Note: wait is the local one not the global one of the same name.\n    return { getInfo, creationTime, sendrecv, recv, wait, iam, selfAddress, getViews, stdlib: compiledStdlib };\n  };\n\n  function setDebugLabel(newLabel) {\n    label = newLabel;\n    // @ts-ignore\n    return this;\n  }\n  return { deploy, attach, networkAccount, setGasLimit, getAddress: selfAddress, stdlib: compiledStdlib, setDebugLabel };\n};\nexport const newAccountFromSecret = async (secret) => {\n  const provider = await getProvider();\n  const networkAccount = (new ethers.Wallet(secret)).connect(provider);\n  const acc = await connectAccount(networkAccount);\n  return acc;\n};\nexport const newAccountFromMnemonic = async (phrase) => {\n  const provider = await getProvider();\n  const networkAccount = ethers.Wallet.fromMnemonic(phrase).connect(provider);\n  const acc = await connectAccount(networkAccount);\n  return acc;\n};\nexport const getDefaultAccount = async () => {\n  debug(`getDefaultAccount`);\n  if (isIsolatedNetwork || networkDesc.type == 'window') {\n    const provider = await getProvider();\n    // TODO: teach ts what the specialized type of provider is in this branch\n    // @ts-ignore\n    const signer = provider.getSigner();\n    return await connectAccount(signer);\n  }\n  throw Error(`Default account not available for REACH_CONNECTOR_MODE=${connectorMode}`);\n};\n// TODO: Should users be able to access this directly?\n// TODO: define a faucet on Ropsten & other testnets?\nexport const [getFaucet, setFaucet] = replaceableThunk(async () => {\n  // XXX this may break if users call setProvider?\n  if (isIsolatedNetwork) {\n    // On isolated networks, the default account is assumed to be the faucet.\n    // Furthermore, it is assumed that the faucet Signer is \"unlocked\",\n    // so no further secrets need be provided in order to access its funds.\n    // This is true of reach-provided devnets.\n    // TODO: allow the user to set the faucet via mnemnonic.\n    return await getDefaultAccount();\n  } else if (networkDesc.type === 'window') {\n    // @ts-ignore // 0x539 = 1337\n    if (window.ethereum.chainId === '0xNaN' || window.ethereum.chainId == '0x539') {\n      // XXX this is a hacky way of checking if we're on a devnet\n      // XXX only localhost:8545 is supported\n      const p = new ethers.providers.JsonRpcProvider('http://localhost:8545');\n      return await connectAccount(p.getSigner());\n    }\n  }\n  throw Error(`getFaucet not supported in this context.`);\n});\nexport const createAccount = async () => {\n  debug(`createAccount with 0 balance.`);\n  const provider = await getProvider();\n  const networkAccount = ethers.Wallet.createRandom().connect(provider);\n  return await connectAccount(networkAccount);\n};\nexport const fundFromFaucet = async (account, value) => {\n  const faucet = await getFaucet();\n  await transfer(faucet, account, value);\n};\nexport const newTestAccount = async (startingBalance) => {\n  debug('newTestAccount(', startingBalance, ')');\n  requireIsolatedNetwork('newTestAccount');\n  const acc = await createAccount();\n  const to = await getAddr(acc);\n  try {\n    debug('newTestAccount awaiting transfer:', to);\n    await fundFromFaucet(acc, startingBalance);\n    debug('newTestAccount got transfer:', to);\n    return acc;\n  } catch (e) {\n    console.log(`newTestAccount: Trouble with account ${to}`);\n    throw e;\n  }\n};\nexport const getNetworkTime = async () => {\n  return bigNumberify(await getNetworkTimeNumber());\n};\n// onProgress callback is optional, it will be given an obj\n// {currentTime, targetTime}\nexport const wait = async (delta, onProgress) => {\n  const now = await getNetworkTime();\n  return await waitUntilTime(add(now, delta), onProgress);\n};\n// onProgress callback is optional, it will be given an obj\n// {currentTime, targetTime}\nexport const waitUntilTime = async (targetTime, onProgress) => {\n  targetTime = bigNumberify(targetTime);\n  if (isIsolatedNetwork) {\n    return await fastForwardTo(targetTime, onProgress);\n  } else {\n    return await actuallyWaitUntilTime(targetTime, onProgress);\n  }\n};\n// Check the contract info and the associated deployed bytecode;\n// Verify that:\n// * it matches the bytecode you are expecting.\n// * it was deployed at exactly creation_block.\n// Throws an Error if any verifications fail\nexport const verifyContract = async (ctcInfo, backend) => {\n  const { ABI, Bytecode } = backend._Connectors.ETH;\n  const { address, creation_block, init } = ctcInfo;\n  const { argsMay } = initOrDefaultArgs(init);\n  const factory = new ethers.ContractFactory(ABI, Bytecode);\n  debug('verifyContract:', address);\n  debug(ctcInfo);\n  const provider = await getProvider();\n  const now = await getNetworkTimeNumber();\n  const deployEvent = isNone(argsMay) ? 'e0' : 'e1';\n  debug('verifyContract: checking logs for', deployEvent, '...');\n  // https://docs.ethers.io/v5/api/providers/provider/#Provider-getLogs\n  // \"Keep in mind that many backends will discard old events\"\n  // TODO: find another way to validate creation block if much time has passed?\n  const logs = await provider.getLogs({\n    fromBlock: creation_block,\n    toBlock: now,\n    address: address,\n    topics: [factory.interface.getEventTopic(deployEvent)],\n  });\n  if (logs.length < 1) {\n    throw Error(`Contract was claimed to be deployed at ${creation_block},` +\n      ` but the current block is ${now} and it hasn't been deployed yet.`);\n  }\n  const log = logs[0];\n  if (log.blockNumber !== creation_block) {\n    throw Error(`Contract was deployed at blockNumber ${log.blockNumber},` +\n      ` but was claimed to be deployed at ${creation_block}.`);\n  }\n  debug(`verifyContract: checking code...`);\n  // https://docs.ethers.io/v5/api/providers/provider/#Provider-getCode\n  // We can safely getCode at the current block;\n  // Reach programs don't change their ETH code over time.\n  const actual = await provider.getCode(address);\n  // XXX should this also pass {value}, like factory.deploy() does?\n  const deployData = factory.getDeployTransaction(...argsMay).data;\n  if (typeof deployData !== 'string') {\n    // TODO: could also be Ethers.utils.bytes, apparently? Or undefined... why?\n    throw Error(`Impossible: deployData is not string ${deployData}`);\n  }\n  if (!deployData.startsWith(backend._Connectors.ETH.Bytecode)) {\n    throw Error(`Impossible: contract with args is not prefixed by backend Bytecode`);\n  }\n  // FIXME this is based on empirical observation, feels hacky\n  // deployData looks like this: [init][setup][body][teardown]\n  // actual looks like this:     [init][body]\n  // XXX the labels \"init\", \"setup\", and \"teardown\" are probably misleading\n  // FIXME: for 0-arg contract deploys, it appears that:\n  // * \"init\" is of length 13\n  // * \"setup\" is not consistent in content, but is of length 156\n  // * \"teardown\" is of length 0\n  // FIXME: for n-arg contract deploys, it appears that:\n  // * \"init\" is of length 13\n  // * \"setup\" is of length >= 0 (and probably >= 156)\n  // * \"teardown\" is of length >= 0\n  const initLen = 13;\n  const setupLen = 156;\n  const expected = deployData.slice(0, initLen) + deployData.slice(initLen + setupLen);\n  if (expected.length <= 0) {\n    throw Error(`Impossible: contract expectation is empty`);\n  }\n  if (actual !== expected) {\n    // FIXME: Empirical observation says that 0-arg contract deploys\n    // should === expected. However, this is fragile (?), so it's ok\n    // to only pass the next check.\n    // FIXME: the 13-char header is also fragile, but we're just\n    // running with that assumption for now.\n    const deployNoInit = deployData.slice(initLen);\n    const actualNoInit = actual.slice(initLen);\n    if (actualNoInit.length === 0 || !deployNoInit.includes(actualNoInit)) {\n      // FIXME: this display is not so helful for the n-arg contract deploy case.\n      const displayLen = 60;\n      console.log('--------------------------------------------');\n      console.log('expected start: ' + expected.slice(0, displayLen));\n      console.log('actual   start: ' + actual.slice(0, displayLen));\n      console.log('--------------------------------------------');\n      console.log('expected   end: ' + expected.slice(expected.length - displayLen));\n      console.log('actual     end: ' + actual.slice(actual.length - displayLen));\n      console.log('--------------------------------------------');\n      console.log('expected   len: ' + expected.length);\n      console.log('actual     len: ' + actual.length);\n      console.log('--------------------------------------------');\n      throw Error(`Contract bytecode does not match expected bytecode.`);\n    }\n  }\n  // We are not checking the balance or the contract storage, because we know\n  // that the code is correct and we know that the code mandates the way that\n  // those things are initialized\n  return true;\n};\n/** @description the display name of the standard unit of currency for the network */\nexport const standardUnit = 'ETH';\n/** @description the display name of the atomic (smallest) unit of currency for the network */\nexport const atomicUnit = 'WEI';\n/**\n * @description  Parse currency by network\n * @param amt  value in the {@link standardUnit} for the network.\n * @returns  the amount in the {@link atomicUnit} of the network.\n * @example  parseCurrency(100).toString() // => '100000000000000000000'\n */\nexport function parseCurrency(amt) {\n  return bigNumberify(ethers.utils.parseUnits(amt.toString(), 'ether'));\n}\nexport const minimumBalance = parseCurrency(0);\n/**\n * @description  Format currency by network\n * @param amt  the amount in the {@link atomicUnit} of the network.\n * @param decimals  up to how many decimal places to display in the {@link standardUnit}.\n *   Trailing zeroes will be omitted. Excess decimal places will be truncated. (not rounded)\n *   This argument defaults to maximum precision.\n * @returns  a string representation of that amount in the {@link standardUnit} for that network.\n * @example  formatCurrency(bigNumberify('100000000000000000000')); // => '100'\n */\nexport function formatCurrency(amt, decimals = 18) {\n  // Recall that 1 WEI = 10e18 ETH\n  if (!(Number.isInteger(decimals) && 0 <= decimals)) {\n    throw Error(`Expected decimals to be a nonnegative integer, but got ${decimals}.`);\n  }\n  // Truncate\n  decimals = Math.min(decimals, 18);\n  const decimalsToForget = 18 - decimals;\n  const divAmt = bigNumberify(amt)\n    .div(bigNumberify(10).pow(decimalsToForget));\n  const amtStr = ethers.utils.formatUnits(divAmt, decimals);\n  // If the str ends with .0, chop it off\n  if (amtStr.slice(amtStr.length - 2) == '.0') {\n    return amtStr.slice(0, amtStr.length - 2);\n  } else {\n    return amtStr;\n  }\n}\nexport const reachStdlib = compiledStdlib;\n"]},"metadata":{},"sourceType":"module"}