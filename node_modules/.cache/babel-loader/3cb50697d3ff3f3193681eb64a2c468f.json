{"ast":null,"code":"// Shared code with stuff that is not exported to the user\n\n/**\n * @description Create a getter/setter, where the getter defaults to memoizing a thunk\n */\nexport function replaceableThunk(thunk) {\n  let called = false;\n  let res = null;\n\n  function get() {\n    if (!called) {\n      called = true;\n      res = thunk();\n    }\n\n    return res;\n  }\n\n  function set(val) {\n    if (called) {\n      throw Error(`Cannot re-set value once already set`);\n    }\n\n    res = val;\n    called = true;\n  }\n\n  return [get, set];\n}\n/**\n * @description Only perform side effects from thunk on the first call.\n */\n\nexport function memoizeThunk(thunk) {\n  return replaceableThunk(thunk)[0];\n}\n/**\n * @description ascLabels[i] = label; labelMap[label] = i;\n */\n\nexport const labelMaps = co => {\n  const ascLabels = Object.keys(co).sort();\n  const labelMap = {};\n\n  for (const i in ascLabels) {\n    labelMap[ascLabels[i]] = parseInt(i);\n  }\n\n  return {\n    ascLabels,\n    labelMap\n  };\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/@reach-sh/stdlib/shared_impl.mjs"],"names":["replaceableThunk","thunk","called","res","get","set","val","Error","memoizeThunk","labelMaps","co","ascLabels","Object","keys","sort","labelMap","i","parseInt"],"mappings":"AAAA;;AACA;AACA;AACA;AACA,OAAO,SAASA,gBAAT,CAA0BC,KAA1B,EAAiC;AACtC,MAAIC,MAAM,GAAG,KAAb;AACA,MAAIC,GAAG,GAAG,IAAV;;AAEA,WAASC,GAAT,GAAe;AACb,QAAI,CAACF,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAG,IAAT;AACAC,MAAAA,GAAG,GAAGF,KAAK,EAAX;AACD;;AACD,WAAOE,GAAP;AACD;;AAED,WAASE,GAAT,CAAaC,GAAb,EAAkB;AAChB,QAAIJ,MAAJ,EAAY;AACV,YAAMK,KAAK,CAAE,sCAAF,CAAX;AACD;;AACDJ,IAAAA,GAAG,GAAGG,GAAN;AACAJ,IAAAA,MAAM,GAAG,IAAT;AACD;;AACD,SAAO,CAACE,GAAD,EAAMC,GAAN,CAAP;AACD;AACD;AACA;AACA;;AACA,OAAO,SAASG,YAAT,CAAsBP,KAAtB,EAA6B;AAClC,SAAOD,gBAAgB,CAACC,KAAD,CAAhB,CAAwB,CAAxB,CAAP;AACD;AACD;AACA;AACA;;AACA,OAAO,MAAMQ,SAAS,GAAIC,EAAD,IAAQ;AAC/B,QAAMC,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYH,EAAZ,EAAgBI,IAAhB,EAAlB;AACA,QAAMC,QAAQ,GAAG,EAAjB;;AACA,OAAK,MAAMC,CAAX,IAAgBL,SAAhB,EAA2B;AACzBI,IAAAA,QAAQ,CAACJ,SAAS,CAACK,CAAD,CAAV,CAAR,GAAyBC,QAAQ,CAACD,CAAD,CAAjC;AACD;;AACD,SAAO;AAAEL,IAAAA,SAAF;AAAaI,IAAAA;AAAb,GAAP;AACD,CAPM","sourcesContent":["// Shared code with stuff that is not exported to the user\n/**\n * @description Create a getter/setter, where the getter defaults to memoizing a thunk\n */\nexport function replaceableThunk(thunk) {\n  let called = false;\n  let res = null;\n\n  function get() {\n    if (!called) {\n      called = true;\n      res = thunk();\n    }\n    return res;\n  }\n\n  function set(val) {\n    if (called) {\n      throw Error(`Cannot re-set value once already set`);\n    }\n    res = val;\n    called = true;\n  }\n  return [get, set];\n}\n/**\n * @description Only perform side effects from thunk on the first call.\n */\nexport function memoizeThunk(thunk) {\n  return replaceableThunk(thunk)[0];\n}\n/**\n * @description ascLabels[i] = label; labelMap[label] = i;\n */\nexport const labelMaps = (co) => {\n  const ascLabels = Object.keys(co).sort();\n  const labelMap = {};\n  for (const i in ascLabels) {\n    labelMap[ascLabels[i]] = parseInt(i);\n  }\n  return { ascLabels, labelMap };\n};\n"]},"metadata":{},"sourceType":"module"}