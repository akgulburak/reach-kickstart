{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst address = require('./encoding/address');\n\nconst uint64Encoding = require('./encoding/uint64');\n\nconst mnemonic = require('./mnemonic/mnemonic');\n\nconst encoding = require('./encoding/encoding');\n\nconst account = require('./account');\n\nconst txnBuilder = require('./transaction');\n\nconst makeTxn = require('./makeTxn');\n\nconst group = require('./group');\n\nconst multisig = require('./multisig');\n\nconst bidBuilder = require('./bid');\n\nconst algod = require('./client/algod');\n\nconst kmd = require('./client/kmd');\n\nconst convert = require('./convert');\n\nconst utils = require('./utils/utils');\n\nconst logicsig = require('./logicsig');\n\nconst LogicTemplates = require('./logicTemplates');\n\nconst algodv2 = require('./client/v2/algod/algod');\n\nconst modelsv2 = require('./client/v2/algod/models/types');\n\nconst indexer = require('./client/v2/indexer/indexer');\n\nconst {\n  Algod\n} = algod;\nconst {\n  Kmd\n} = kmd;\nconst Algodv2 = algodv2.AlgodClient;\nconst Indexer = indexer.IndexerClient;\nconst SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n// Errors\n\nconst MULTISIG_BAD_SENDER_ERROR_MSG = 'The transaction sender address and multisig preimage do not match.';\n/**\n * signTransaction takes an object with either payment or key registration fields and\n * a secret key and returns a signed blob.\n *\n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n *\n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn object with either payment or key registration fields\n * @param sk Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\n\nfunction signTransaction(txn, sk) {\n  if (typeof txn.from === 'undefined') {\n    // Get pk from sk if no sender specified\n    const key = nacl.keyPairFromSecretKey(sk); // eslint-disable-next-line no-param-reassign\n\n    txn.from = address.encodeAddress(key.publicKey);\n  }\n\n  let algoTxn = txn;\n\n  if (!(txn instanceof txnBuilder.Transaction)) {\n    algoTxn = new txnBuilder.Transaction(txn);\n  }\n\n  return {\n    txID: algoTxn.txID().toString(),\n    blob: algoTxn.signTxn(sk)\n  };\n}\n/**\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\n * @param bid Algorand Bid\n * @param sk Algorand secret key\n * @returns Uint8Array binary signed bid\n */\n\n\nfunction signBid(bid, sk) {\n  const signedBid = new bidBuilder.Bid(bid);\n  return signedBid.signBid(sk);\n}\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\n * with the private key, and returns the signature.\n * @param bytes Uint8array\n * @param sk Algorand secret key\n * @returns binary signature\n */\n\n\nfunction signBytes(bytes, sk) {\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  const sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes Uint8Array\n * @param signature binary signature\n * @param addr string address\n * @returns bool\n */\n\n\nfunction verifyBytes(bytes, signature, addr) {\n  const toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  const pk = address.decodeAddress(addr).publicKey;\n  return nacl.verify(toBeVerified, signature, pk);\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendMultisigTransaction.\n * @param txn object with either payment or key registration fields\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\n\n\nfunction signMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n\n  if (Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    if (txn.from !== expectedFromRaw && address.encodeAddress(txn.from.publicKey) !== expectedFromRaw) {\n      throw new Error(MULTISIG_BAD_SENDER_ERROR_MSG);\n    }\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  } // build pks for partialSign\n\n\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey); // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn;\n  let blob;\n\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = multisig.MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {\n      version,\n      threshold,\n      pks\n    }, sk);\n  } else {\n    algoTxn = new multisig.MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({\n      version,\n      threshold,\n      pks\n    }, sk);\n  }\n\n  return {\n    txID: algoTxn.txID().toString(),\n    blob\n  };\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns blob representing encoded multisig txn\n */\n\n\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  return multisig.mergeMultisigTransactions(multisigTxnBlobs);\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob an encoded multisig txn. Supports non-payment txn types.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\n\n\nfunction appendSignMultisigTransaction(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey); // obtain underlying txn, sign it, and merge it\n\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = multisig.MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version mutlisig version\n * @param threshold multisig threshold\n * @param addrs list of Algorand addresses\n */\n\n\nfunction multisigAddress({\n  version,\n  threshold,\n  addrs\n}) {\n  return address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n}\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o js obj\n * @returns Uint8Array binary representation\n */\n\n\nfunction encodeObj(o) {\n  return new Uint8Array(encoding.encode(o));\n}\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o Uint8Array to decode\n * @returns object\n */\n\n\nfunction decodeObj(o) {\n  return encoding.decode(o);\n}\n\nmodule.exports = {\n  isValidAddress: address.isValidAddress,\n  encodeAddress: address.encodeAddress,\n  decodeAddress: address.decodeAddress,\n  encodeUint64: uint64Encoding.encodeUint64,\n  decodeUint64: uint64Encoding.decodeUint64,\n  generateAccount: account.generateAccount,\n  secretKeyToMnemonic: mnemonic.secretKeyToMnemonic,\n  mnemonicToSecretKey: mnemonic.mnemonicToSecretKey,\n  signTransaction,\n  signBid,\n  signBytes,\n  verifyBytes,\n  encodeObj,\n  decodeObj,\n  Algod,\n  Kmd,\n  Algodv2,\n  Indexer,\n  modelsv2,\n  mnemonicToMasterDerivationKey: mnemonic.mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic: mnemonic.masterDerivationKeyToMnemonic,\n  appendSignMultisigTransaction,\n  mergeMultisigTransactions,\n  signMultisigTransaction,\n  multisigAddress,\n  MULTISIG_BAD_SENDER_ERROR_MSG,\n  ERROR_MULTISIG_BAD_SENDER: new Error(MULTISIG_BAD_SENDER_ERROR_MSG),\n  INVALID_MICROALGOS_ERROR_MSG: convert.ERROR_INVALID_MICROALGOS,\n  ERROR_INVALID_MICROALGOS: new Error(convert.ERROR_INVALID_MICROALGOS),\n  microalgosToAlgos: convert.microalgosToAlgos,\n  algosToMicroalgos: convert.algosToMicroalgos,\n  computeGroupID: group.computeGroupID,\n  assignGroupID: group.assignGroupID,\n  makeLogicSig: logicsig.makeLogicSig,\n  signLogicSigTransaction: logicsig.signLogicSigTransaction,\n  signLogicSigTransactionObject: logicsig.signLogicSigTransactionObject,\n  logicSigFromByte: logicsig.logicSigFromByte,\n  tealSign: logicsig.tealSign,\n  tealSignFromProgram: logicsig.tealSignFromProgram,\n  makePaymentTxn: makeTxn.makePaymentTxn,\n  makeKeyRegistrationTxn: makeTxn.makeKeyRegistrationTxn,\n  makeAssetCreateTxn: makeTxn.makeAssetCreateTxn,\n  makeAssetConfigTxn: makeTxn.makeAssetConfigTxn,\n  makeAssetDestroyTxn: makeTxn.makeAssetDestroyTxn,\n  makeAssetFreezeTxn: makeTxn.makeAssetFreezeTxn,\n  makeAssetTransferTxn: makeTxn.makeAssetTransferTxn,\n  makePaymentTxnWithSuggestedParams: makeTxn.makePaymentTxnWithSuggestedParams,\n  makeKeyRegistrationTxnWithSuggestedParams: makeTxn.makeKeyRegistrationTxnWithSuggestedParams,\n  makeAssetCreateTxnWithSuggestedParams: makeTxn.makeAssetCreateTxnWithSuggestedParams,\n  makeAssetConfigTxnWithSuggestedParams: makeTxn.makeAssetConfigTxnWithSuggestedParams,\n  makeAssetDestroyTxnWithSuggestedParams: makeTxn.makeAssetDestroyTxnWithSuggestedParams,\n  makeAssetFreezeTxnWithSuggestedParams: makeTxn.makeAssetFreezeTxnWithSuggestedParams,\n  makeAssetTransferTxnWithSuggestedParams: makeTxn.makeAssetTransferTxnWithSuggestedParams,\n  makePaymentTxnWithSuggestedParamsFromObject: makeTxn.makePaymentTxnWithSuggestedParamsFromObject,\n  makeKeyRegistrationTxnWithSuggestedParamsFromObject: makeTxn.makeKeyRegistrationTxnWithSuggestedParamsFromObject,\n  makeAssetCreateTxnWithSuggestedParamsFromObject: makeTxn.makeAssetCreateTxnWithSuggestedParamsFromObject,\n  makeAssetConfigTxnWithSuggestedParamsFromObject: makeTxn.makeAssetConfigTxnWithSuggestedParamsFromObject,\n  makeAssetDestroyTxnWithSuggestedParamsFromObject: makeTxn.makeAssetDestroyTxnWithSuggestedParamsFromObject,\n  makeAssetFreezeTxnWithSuggestedParamsFromObject: makeTxn.makeAssetFreezeTxnWithSuggestedParamsFromObject,\n  makeAssetTransferTxnWithSuggestedParamsFromObject: makeTxn.makeAssetTransferTxnWithSuggestedParamsFromObject,\n  OnApplicationComplete: makeTxn.OnApplicationComplete,\n  makeApplicationCreateTxn: makeTxn.makeApplicationCreateTxn,\n  makeApplicationUpdateTxn: makeTxn.makeApplicationUpdateTxn,\n  makeApplicationDeleteTxn: makeTxn.makeApplicationDeleteTxn,\n  makeApplicationOptInTxn: makeTxn.makeApplicationOptInTxn,\n  makeApplicationCloseOutTxn: makeTxn.makeApplicationCloseOutTxn,\n  makeApplicationClearStateTxn: makeTxn.makeApplicationClearStateTxn,\n  makeApplicationNoOpTxn: makeTxn.makeApplicationNoOpTxn,\n  makeApplicationCreateTxnFromObject: makeTxn.makeApplicationCreateTxnFromObject,\n  makeApplicationUpdateTxnFromObject: makeTxn.makeApplicationUpdateTxnFromObject,\n  makeApplicationDeleteTxnFromObject: makeTxn.makeApplicationDeleteTxnFromObject,\n  makeApplicationOptInTxnFromObject: makeTxn.makeApplicationOptInTxnFromObject,\n  makeApplicationCloseOutTxnFromObject: makeTxn.makeApplicationCloseOutTxnFromObject,\n  makeApplicationClearStateTxnFromObject: makeTxn.makeApplicationClearStateTxnFromObject,\n  makeApplicationNoOpTxnFromObject: makeTxn.makeApplicationNoOpTxnFromObject,\n  encodeUnsignedTransaction: txnBuilder.encodeUnsignedTransaction,\n  decodeUnsignedTransaction: txnBuilder.decodeUnsignedTransaction,\n  decodeSignedTransaction: txnBuilder.decodeSignedTransaction,\n  Transaction: txnBuilder.Transaction,\n  LogicTemplates\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/main.js"],"names":["Buffer","require","nacl","address","uint64Encoding","mnemonic","encoding","account","txnBuilder","makeTxn","group","multisig","bidBuilder","algod","kmd","convert","utils","logicsig","LogicTemplates","algodv2","modelsv2","indexer","Algod","Kmd","Algodv2","AlgodClient","Indexer","IndexerClient","SIGN_BYTES_PREFIX","from","MULTISIG_BAD_SENDER_ERROR_MSG","signTransaction","txn","sk","key","keyPairFromSecretKey","encodeAddress","publicKey","algoTxn","Transaction","txID","toString","blob","signTxn","signBid","bid","signedBid","Bid","signBytes","bytes","toBeSigned","concatArrays","sig","sign","verifyBytes","signature","addr","toBeVerified","pk","decodeAddress","verify","signMultisigTransaction","version","threshold","addrs","expectedFromRaw","fromMultisigPreImgAddrs","Object","prototype","hasOwnProperty","call","Error","pks","map","txnAlreadyBuilt","MultisigTransaction","partialSignTxn","mergeMultisigTransactions","multisigTxnBlobs","appendSignMultisigTransaction","multisigTxnBlob","multisigTxObj","decode","msigTxn","from_obj_for_encoding","partialSignedBlob","multisigAddress","encodeObj","o","Uint8Array","encode","decodeObj","module","exports","isValidAddress","encodeUint64","decodeUint64","generateAccount","secretKeyToMnemonic","mnemonicToSecretKey","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","ERROR_MULTISIG_BAD_SENDER","INVALID_MICROALGOS_ERROR_MSG","ERROR_INVALID_MICROALGOS","microalgosToAlgos","algosToMicroalgos","computeGroupID","assignGroupID","makeLogicSig","signLogicSigTransaction","signLogicSigTransactionObject","logicSigFromByte","tealSign","tealSignFromProgram","makePaymentTxn","makeKeyRegistrationTxn","makeAssetCreateTxn","makeAssetConfigTxn","makeAssetDestroyTxn","makeAssetFreezeTxn","makeAssetTransferTxn","makePaymentTxnWithSuggestedParams","makeKeyRegistrationTxnWithSuggestedParams","makeAssetCreateTxnWithSuggestedParams","makeAssetConfigTxnWithSuggestedParams","makeAssetDestroyTxnWithSuggestedParams","makeAssetFreezeTxnWithSuggestedParams","makeAssetTransferTxnWithSuggestedParams","makePaymentTxnWithSuggestedParamsFromObject","makeKeyRegistrationTxnWithSuggestedParamsFromObject","makeAssetCreateTxnWithSuggestedParamsFromObject","makeAssetConfigTxnWithSuggestedParamsFromObject","makeAssetDestroyTxnWithSuggestedParamsFromObject","makeAssetFreezeTxnWithSuggestedParamsFromObject","makeAssetTransferTxnWithSuggestedParamsFromObject","OnApplicationComplete","makeApplicationCreateTxn","makeApplicationUpdateTxn","makeApplicationDeleteTxn","makeApplicationOptInTxn","makeApplicationCloseOutTxn","makeApplicationClearStateTxn","makeApplicationNoOpTxn","makeApplicationCreateTxnFromObject","makeApplicationUpdateTxnFromObject","makeApplicationDeleteTxnFromObject","makeApplicationOptInTxnFromObject","makeApplicationCloseOutTxnFromObject","makeApplicationClearStateTxnFromObject","makeApplicationNoOpTxnFromObject","encodeUnsignedTransaction","decodeUnsignedTransaction","decodeSignedTransaction"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst nacl = require('./nacl/naclWrappers');\nconst address = require('./encoding/address');\nconst uint64Encoding = require('./encoding/uint64');\nconst mnemonic = require('./mnemonic/mnemonic');\nconst encoding = require('./encoding/encoding');\nconst account = require('./account');\nconst txnBuilder = require('./transaction');\nconst makeTxn = require('./makeTxn');\nconst group = require('./group');\nconst multisig = require('./multisig');\nconst bidBuilder = require('./bid');\nconst algod = require('./client/algod');\nconst kmd = require('./client/kmd');\nconst convert = require('./convert');\nconst utils = require('./utils/utils');\nconst logicsig = require('./logicsig');\nconst LogicTemplates = require('./logicTemplates');\nconst algodv2 = require('./client/v2/algod/algod');\nconst modelsv2 = require('./client/v2/algod/models/types');\nconst indexer = require('./client/v2/indexer/indexer');\n\nconst { Algod } = algod;\nconst { Kmd } = kmd;\nconst Algodv2 = algodv2.AlgodClient;\nconst Indexer = indexer.IndexerClient;\n\nconst SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n\n// Errors\nconst MULTISIG_BAD_SENDER_ERROR_MSG =\n  'The transaction sender address and multisig preimage do not match.';\n\n/**\n * signTransaction takes an object with either payment or key registration fields and\n * a secret key and returns a signed blob.\n *\n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n *\n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn object with either payment or key registration fields\n * @param sk Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\nfunction signTransaction(txn, sk) {\n  if (typeof txn.from === 'undefined') {\n    // Get pk from sk if no sender specified\n    const key = nacl.keyPairFromSecretKey(sk);\n    // eslint-disable-next-line no-param-reassign\n    txn.from = address.encodeAddress(key.publicKey);\n  }\n  let algoTxn = txn;\n  if (!(txn instanceof txnBuilder.Transaction)) {\n    algoTxn = new txnBuilder.Transaction(txn);\n  }\n\n  return { txID: algoTxn.txID().toString(), blob: algoTxn.signTxn(sk) };\n}\n\n/**\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\n * @param bid Algorand Bid\n * @param sk Algorand secret key\n * @returns Uint8Array binary signed bid\n */\nfunction signBid(bid, sk) {\n  const signedBid = new bidBuilder.Bid(bid);\n  return signedBid.signBid(sk);\n}\n\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\n * with the private key, and returns the signature.\n * @param bytes Uint8array\n * @param sk Algorand secret key\n * @returns binary signature\n */\nfunction signBytes(bytes, sk) {\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  const sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes Uint8Array\n * @param signature binary signature\n * @param addr string address\n * @returns bool\n */\nfunction verifyBytes(bytes, signature, addr) {\n  const toBeVerified = Buffer.from(\n    utils.concatArrays(SIGN_BYTES_PREFIX, bytes)\n  );\n  const pk = address.decodeAddress(addr).publicKey;\n  return nacl.verify(toBeVerified, signature, pk);\n}\n\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendMultisigTransaction.\n * @param txn object with either payment or key registration fields\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nfunction signMultisigTransaction(txn, { version, threshold, addrs }, sk) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs,\n  });\n  if (Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    if (\n      txn.from !== expectedFromRaw &&\n      address.encodeAddress(txn.from.publicKey) !== expectedFromRaw\n    ) {\n      throw new Error(MULTISIG_BAD_SENDER_ERROR_MSG);\n    }\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn;\n  let blob;\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = multisig.MultisigTransaction.prototype.partialSignTxn.call(\n      algoTxn,\n      { version, threshold, pks },\n      sk\n    );\n  } else {\n    algoTxn = new multisig.MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob,\n  };\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns blob representing encoded multisig txn\n */\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  return multisig.mergeMultisigTransactions(multisigTxnBlobs);\n}\n\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob an encoded multisig txn. Supports non-payment txn types.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nfunction appendSignMultisigTransaction(\n  multisigTxnBlob,\n  { version, threshold, addrs },\n  sk\n) {\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = multisig.MultisigTransaction.from_obj_for_encoding(\n    multisigTxObj.txn\n  );\n  const partialSignedBlob = msigTxn.partialSignTxn(\n    { version, threshold, pks },\n    sk\n  );\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version mutlisig version\n * @param threshold multisig threshold\n * @param addrs list of Algorand addresses\n */\nfunction multisigAddress({ version, threshold, addrs }) {\n  return address.fromMultisigPreImgAddrs({ version, threshold, addrs });\n}\n\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o js obj\n * @returns Uint8Array binary representation\n */\nfunction encodeObj(o) {\n  return new Uint8Array(encoding.encode(o));\n}\n\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o Uint8Array to decode\n * @returns object\n */\nfunction decodeObj(o) {\n  return encoding.decode(o);\n}\n\nmodule.exports = {\n  isValidAddress: address.isValidAddress,\n  encodeAddress: address.encodeAddress,\n  decodeAddress: address.decodeAddress,\n  encodeUint64: uint64Encoding.encodeUint64,\n  decodeUint64: uint64Encoding.decodeUint64,\n  generateAccount: account.generateAccount,\n  secretKeyToMnemonic: mnemonic.secretKeyToMnemonic,\n  mnemonicToSecretKey: mnemonic.mnemonicToSecretKey,\n  signTransaction,\n  signBid,\n  signBytes,\n  verifyBytes,\n  encodeObj,\n  decodeObj,\n  Algod,\n  Kmd,\n  Algodv2,\n  Indexer,\n  modelsv2,\n  mnemonicToMasterDerivationKey: mnemonic.mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic: mnemonic.masterDerivationKeyToMnemonic,\n  appendSignMultisigTransaction,\n  mergeMultisigTransactions,\n  signMultisigTransaction,\n  multisigAddress,\n  MULTISIG_BAD_SENDER_ERROR_MSG,\n  ERROR_MULTISIG_BAD_SENDER: new Error(MULTISIG_BAD_SENDER_ERROR_MSG),\n  INVALID_MICROALGOS_ERROR_MSG: convert.ERROR_INVALID_MICROALGOS,\n  ERROR_INVALID_MICROALGOS: new Error(convert.ERROR_INVALID_MICROALGOS),\n  microalgosToAlgos: convert.microalgosToAlgos,\n  algosToMicroalgos: convert.algosToMicroalgos,\n  computeGroupID: group.computeGroupID,\n  assignGroupID: group.assignGroupID,\n  makeLogicSig: logicsig.makeLogicSig,\n  signLogicSigTransaction: logicsig.signLogicSigTransaction,\n  signLogicSigTransactionObject: logicsig.signLogicSigTransactionObject,\n  logicSigFromByte: logicsig.logicSigFromByte,\n  tealSign: logicsig.tealSign,\n  tealSignFromProgram: logicsig.tealSignFromProgram,\n  makePaymentTxn: makeTxn.makePaymentTxn,\n  makeKeyRegistrationTxn: makeTxn.makeKeyRegistrationTxn,\n  makeAssetCreateTxn: makeTxn.makeAssetCreateTxn,\n  makeAssetConfigTxn: makeTxn.makeAssetConfigTxn,\n  makeAssetDestroyTxn: makeTxn.makeAssetDestroyTxn,\n  makeAssetFreezeTxn: makeTxn.makeAssetFreezeTxn,\n  makeAssetTransferTxn: makeTxn.makeAssetTransferTxn,\n  makePaymentTxnWithSuggestedParams: makeTxn.makePaymentTxnWithSuggestedParams,\n  makeKeyRegistrationTxnWithSuggestedParams:\n    makeTxn.makeKeyRegistrationTxnWithSuggestedParams,\n  makeAssetCreateTxnWithSuggestedParams:\n    makeTxn.makeAssetCreateTxnWithSuggestedParams,\n  makeAssetConfigTxnWithSuggestedParams:\n    makeTxn.makeAssetConfigTxnWithSuggestedParams,\n  makeAssetDestroyTxnWithSuggestedParams:\n    makeTxn.makeAssetDestroyTxnWithSuggestedParams,\n  makeAssetFreezeTxnWithSuggestedParams:\n    makeTxn.makeAssetFreezeTxnWithSuggestedParams,\n  makeAssetTransferTxnWithSuggestedParams:\n    makeTxn.makeAssetTransferTxnWithSuggestedParams,\n  makePaymentTxnWithSuggestedParamsFromObject:\n    makeTxn.makePaymentTxnWithSuggestedParamsFromObject,\n  makeKeyRegistrationTxnWithSuggestedParamsFromObject:\n    makeTxn.makeKeyRegistrationTxnWithSuggestedParamsFromObject,\n  makeAssetCreateTxnWithSuggestedParamsFromObject:\n    makeTxn.makeAssetCreateTxnWithSuggestedParamsFromObject,\n  makeAssetConfigTxnWithSuggestedParamsFromObject:\n    makeTxn.makeAssetConfigTxnWithSuggestedParamsFromObject,\n  makeAssetDestroyTxnWithSuggestedParamsFromObject:\n    makeTxn.makeAssetDestroyTxnWithSuggestedParamsFromObject,\n  makeAssetFreezeTxnWithSuggestedParamsFromObject:\n    makeTxn.makeAssetFreezeTxnWithSuggestedParamsFromObject,\n  makeAssetTransferTxnWithSuggestedParamsFromObject:\n    makeTxn.makeAssetTransferTxnWithSuggestedParamsFromObject,\n  OnApplicationComplete: makeTxn.OnApplicationComplete,\n  makeApplicationCreateTxn: makeTxn.makeApplicationCreateTxn,\n  makeApplicationUpdateTxn: makeTxn.makeApplicationUpdateTxn,\n  makeApplicationDeleteTxn: makeTxn.makeApplicationDeleteTxn,\n  makeApplicationOptInTxn: makeTxn.makeApplicationOptInTxn,\n  makeApplicationCloseOutTxn: makeTxn.makeApplicationCloseOutTxn,\n  makeApplicationClearStateTxn: makeTxn.makeApplicationClearStateTxn,\n  makeApplicationNoOpTxn: makeTxn.makeApplicationNoOpTxn,\n  makeApplicationCreateTxnFromObject:\n    makeTxn.makeApplicationCreateTxnFromObject,\n  makeApplicationUpdateTxnFromObject:\n    makeTxn.makeApplicationUpdateTxnFromObject,\n  makeApplicationDeleteTxnFromObject:\n    makeTxn.makeApplicationDeleteTxnFromObject,\n  makeApplicationOptInTxnFromObject: makeTxn.makeApplicationOptInTxnFromObject,\n  makeApplicationCloseOutTxnFromObject:\n    makeTxn.makeApplicationCloseOutTxnFromObject,\n  makeApplicationClearStateTxnFromObject:\n    makeTxn.makeApplicationClearStateTxnFromObject,\n  makeApplicationNoOpTxnFromObject: makeTxn.makeApplicationNoOpTxnFromObject,\n  encodeUnsignedTransaction: txnBuilder.encodeUnsignedTransaction,\n  decodeUnsignedTransaction: txnBuilder.decodeUnsignedTransaction,\n  decodeSignedTransaction: txnBuilder.decodeSignedTransaction,\n  Transaction: txnBuilder.Transaction,\n  LogicTemplates,\n};\n"]},"metadata":{},"sourceType":"script"}