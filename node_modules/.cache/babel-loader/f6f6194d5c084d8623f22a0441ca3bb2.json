{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n/**\n * encodeUint64 converts an integer to its binary representation.\n * @param {number | bigint} num The number to convert. This must be an unsigned integer less than\n *   2^64.\n * @returns {Uint8Array} An 8-byte typed array containing the big-endian encoding of the input\n *   integer.\n */\n\n\nfunction encodeUint64(num) {\n  const isInteger = typeof num === 'bigint' || Number.isInteger(num);\n\n  if (!isInteger || num < 0 || num > 0xffffffffffffffffn) {\n    throw new Error('Input is not a 64-bit unsigned integer');\n  }\n\n  const buf = Buffer.allocUnsafe(8);\n  buf.writeBigUInt64BE(BigInt(num));\n  return new Uint8Array(buf);\n}\n/**\n * decodeUint64 produces an integer from a binary representation.\n * @param {Uint8Array} data An typed array containing the big-endian encoding of an unsigned integer\n *   less than 2^64. This array must be at most 8 bytes long.\n * @param {\"safe\" | \"mixed\" | \"bigint\"} decodingMode Configure how the integer will be\n *   decoded.\n *\n *   The options are:\n *   * \"safe\": The integer will be decoded as a Number, but if it is greater than\n *     Number.MAX_SAFE_INTEGER an error will be thrown.\n *   * \"mixed\": The integer will be decoded as a Number if it is less than or equal to\n *     Number.MAX_SAFE_INTEGER, otherwise it will be decoded as a BigInt.\n *   * \"bigint\": The integer will always be decoded as a BigInt.\n *\n *   Defaults to \"safe\" if not included.\n * @returns {number | bigint} The integer that was encoded in the input data. The return type will\n *   be determined by the parameter decodingMode.\n */\n\n\nfunction decodeUint64(data, decodingMode = 'safe') {\n  if (decodingMode !== 'safe' && decodingMode !== 'mixed' && decodingMode !== 'bigint') {\n    throw new Error(`Unknown decodingMode option: ${decodingMode}`);\n  }\n\n  if (data.byteLength === 0 || data.byteLength > 8) {\n    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);\n  } // insert 0s at the beginning if data is smaller than 8 bytes\n\n\n  const padding = Buffer.allocUnsafe(8 - data.byteLength);\n  padding.fill(0);\n  const buf = Buffer.concat([padding, Buffer.from(data)]);\n  const num = buf.readBigUInt64BE();\n  const isBig = num > Number.MAX_SAFE_INTEGER;\n\n  if (decodingMode === 'safe') {\n    if (isBig) {\n      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with \"mixed\" or \"safe\" decodingMode.`);\n    }\n\n    return Number(num);\n  }\n\n  if (decodingMode === 'mixed' && !isBig) {\n    return Number(num);\n  }\n\n  return num;\n}\n\nmodule.exports = {\n  encodeUint64,\n  decodeUint64\n};","map":{"version":3,"sources":["/home/x/reach/kick/github/node_modules/algosdk/src/encoding/uint64.js"],"names":["Buffer","require","encodeUint64","num","isInteger","Number","Error","buf","allocUnsafe","writeBigUInt64BE","BigInt","Uint8Array","decodeUint64","data","decodingMode","byteLength","padding","fill","concat","from","readBigUInt64BE","isBig","MAX_SAFE_INTEGER","toString","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,CAAsBC,GAAtB,EAA2B;AACzB,QAAMC,SAAS,GAAG,OAAOD,GAAP,KAAe,QAAf,IAA2BE,MAAM,CAACD,SAAP,CAAiBD,GAAjB,CAA7C;;AAEA,MAAI,CAACC,SAAD,IAAcD,GAAG,GAAG,CAApB,IAAyBA,GAAG,GAAG,mBAAnC,EAAwD;AACtD,UAAM,IAAIG,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,QAAMC,GAAG,GAAGP,MAAM,CAACQ,WAAP,CAAmB,CAAnB,CAAZ;AAEAD,EAAAA,GAAG,CAACE,gBAAJ,CAAqBC,MAAM,CAACP,GAAD,CAA3B;AAEA,SAAO,IAAIQ,UAAJ,CAAeJ,GAAf,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,YAAT,CAAsBC,IAAtB,EAA4BC,YAAY,GAAG,MAA3C,EAAmD;AACjD,MACEA,YAAY,KAAK,MAAjB,IACAA,YAAY,KAAK,OADjB,IAEAA,YAAY,KAAK,QAHnB,EAIE;AACA,UAAM,IAAIR,KAAJ,CAAW,gCAA+BQ,YAAa,EAAvD,CAAN;AACD;;AAED,MAAID,IAAI,CAACE,UAAL,KAAoB,CAApB,IAAyBF,IAAI,CAACE,UAAL,GAAkB,CAA/C,EAAkD;AAChD,UAAM,IAAIT,KAAJ,CACH,yEAAwEO,IAAI,CAACE,UAAW,EADrF,CAAN;AAGD,GAbgD,CAejD;;;AACA,QAAMC,OAAO,GAAGhB,MAAM,CAACQ,WAAP,CAAmB,IAAIK,IAAI,CAACE,UAA5B,CAAhB;AACAC,EAAAA,OAAO,CAACC,IAAR,CAAa,CAAb;AAEA,QAAMV,GAAG,GAAGP,MAAM,CAACkB,MAAP,CAAc,CAACF,OAAD,EAAUhB,MAAM,CAACmB,IAAP,CAAYN,IAAZ,CAAV,CAAd,CAAZ;AAEA,QAAMV,GAAG,GAAGI,GAAG,CAACa,eAAJ,EAAZ;AACA,QAAMC,KAAK,GAAGlB,GAAG,GAAGE,MAAM,CAACiB,gBAA3B;;AAEA,MAAIR,YAAY,KAAK,MAArB,EAA6B;AAC3B,QAAIO,KAAJ,EAAW;AACT,YAAM,IAAIf,KAAJ,CACH,yCAAwCH,GAAG,CAACoB,QAAJ,EAAe,qDADpD,CAAN;AAGD;;AACD,WAAOlB,MAAM,CAACF,GAAD,CAAb;AACD;;AAED,MAAIW,YAAY,KAAK,OAAjB,IAA4B,CAACO,KAAjC,EAAwC;AACtC,WAAOhB,MAAM,CAACF,GAAD,CAAb;AACD;;AAED,SAAOA,GAAP;AACD;;AAEDqB,MAAM,CAACC,OAAP,GAAiB;AACfvB,EAAAA,YADe;AAEfU,EAAAA;AAFe,CAAjB","sourcesContent":["const { Buffer } = require('buffer');\n\n/**\n * encodeUint64 converts an integer to its binary representation.\n * @param {number | bigint} num The number to convert. This must be an unsigned integer less than\n *   2^64.\n * @returns {Uint8Array} An 8-byte typed array containing the big-endian encoding of the input\n *   integer.\n */\nfunction encodeUint64(num) {\n  const isInteger = typeof num === 'bigint' || Number.isInteger(num);\n\n  if (!isInteger || num < 0 || num > 0xffffffffffffffffn) {\n    throw new Error('Input is not a 64-bit unsigned integer');\n  }\n\n  const buf = Buffer.allocUnsafe(8);\n\n  buf.writeBigUInt64BE(BigInt(num));\n\n  return new Uint8Array(buf);\n}\n\n/**\n * decodeUint64 produces an integer from a binary representation.\n * @param {Uint8Array} data An typed array containing the big-endian encoding of an unsigned integer\n *   less than 2^64. This array must be at most 8 bytes long.\n * @param {\"safe\" | \"mixed\" | \"bigint\"} decodingMode Configure how the integer will be\n *   decoded.\n *\n *   The options are:\n *   * \"safe\": The integer will be decoded as a Number, but if it is greater than\n *     Number.MAX_SAFE_INTEGER an error will be thrown.\n *   * \"mixed\": The integer will be decoded as a Number if it is less than or equal to\n *     Number.MAX_SAFE_INTEGER, otherwise it will be decoded as a BigInt.\n *   * \"bigint\": The integer will always be decoded as a BigInt.\n *\n *   Defaults to \"safe\" if not included.\n * @returns {number | bigint} The integer that was encoded in the input data. The return type will\n *   be determined by the parameter decodingMode.\n */\nfunction decodeUint64(data, decodingMode = 'safe') {\n  if (\n    decodingMode !== 'safe' &&\n    decodingMode !== 'mixed' &&\n    decodingMode !== 'bigint'\n  ) {\n    throw new Error(`Unknown decodingMode option: ${decodingMode}`);\n  }\n\n  if (data.byteLength === 0 || data.byteLength > 8) {\n    throw new Error(\n      `Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`\n    );\n  }\n\n  // insert 0s at the beginning if data is smaller than 8 bytes\n  const padding = Buffer.allocUnsafe(8 - data.byteLength);\n  padding.fill(0);\n\n  const buf = Buffer.concat([padding, Buffer.from(data)]);\n\n  const num = buf.readBigUInt64BE();\n  const isBig = num > Number.MAX_SAFE_INTEGER;\n\n  if (decodingMode === 'safe') {\n    if (isBig) {\n      throw new Error(\n        `Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with \"mixed\" or \"safe\" decodingMode.`\n      );\n    }\n    return Number(num);\n  }\n\n  if (decodingMode === 'mixed' && !isBig) {\n    return Number(num);\n  }\n\n  return num;\n}\n\nmodule.exports = {\n  encodeUint64,\n  decodeUint64,\n};\n"]},"metadata":{},"sourceType":"script"}