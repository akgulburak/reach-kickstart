{"ast":null,"code":"// ****************************************************************************\n// standard library needed at runtime by compiled Reach programs\n// ****************************************************************************\nimport * as shared from './shared.mjs';\nimport algosdk from 'algosdk';\nimport buffer from 'buffer';\nimport ethers from 'ethers';\nimport * as CBR from './CBR.mjs';\nimport { labelMaps } from './shared_impl.mjs';\nconst BigNumber = ethers.BigNumber;\nconst Buffer = buffer.Buffer;\nexport const UInt_max = BigNumber.from(2).pow(64).sub(1);\nexport const digest = shared.makeDigest((t, v) => t.toNet(v));\nexport const T_Null = { ...CBR.BT_Null,\n  netSize: 0,\n  toNet: bv => (void bv, new Uint8Array([])),\n  fromNet: nv => (void nv, null)\n};\nexport const T_Bool = { ...CBR.BT_Bool,\n  netSize: 1,\n  toNet: bv => new Uint8Array([bv ? 1 : 0]),\n  fromNet: nv => nv[0] == 1\n};\nexport const T_UInt = { ...CBR.BT_UInt,\n  netSize: 8,\n  toNet: bv => ethers.utils.zeroPad(ethers.utils.arrayify(bv), 8),\n  fromNet: nv => {\n    // debug(`fromNet: UInt`);\n    // if (getDEBUG()) console.log(nv);\n    return ethers.BigNumber.from(nv);\n  }\n};\n/** @description For arbitrary utf8 strings */\n\nconst stringyNet = {\n  toNet: bv => ethers.utils.toUtf8Bytes(bv),\n  fromNet: nv => ethers.utils.toUtf8String(nv)\n};\n/** @description For hex strings representing bytes */\n\nconst bytestringyNet = {\n  toNet: bv => ethers.utils.arrayify(bv),\n  fromNet: nv => ethers.utils.hexlify(nv)\n};\nexport const T_Bytes = len => ({ ...CBR.BT_Bytes(len),\n  ...stringyNet,\n  netSize: len\n});\nexport const T_Digest = { ...CBR.BT_Digest,\n  ...bytestringyNet,\n  netSize: 32\n};\nexport const addressToHex = x => '0x' + Buffer.from(algosdk.decodeAddress(x).publicKey).toString('hex');\n\nfunction addressUnwrapper(x) {\n  const addr = x && x.networkAccount && x.networkAccount.addr || x && x.addr;\n  return addr != undefined ? addressToHex(addr) : x;\n}\n\nexport const T_Address = { ...CBR.BT_Address,\n  ...bytestringyNet,\n  netSize: 32,\n  canonicalize: uv => {\n    const val = addressUnwrapper(uv);\n    return CBR.BT_Address.canonicalize(val || uv);\n  }\n};\nexport const T_Array = (co, size) => ({ ...CBR.BT_Array(co, size),\n  netSize: size * co.netSize,\n  toNet: bv => {\n    return ethers.utils.concat(bv.map(v => co.toNet(v)));\n  },\n  fromNet: nv => {\n    // TODO: assert nv.size = len * size\n    const len = co.netSize;\n    const chunks = new Array(size).fill(null);\n\n    for (let i = 0; i < size; i++) {\n      const start = i * len;\n      chunks[i] = co.fromNet(nv.slice(start, start + len));\n    }\n\n    return chunks;\n  }\n});\nexport const T_Tuple = cos => ({ ...CBR.BT_Tuple(cos),\n  netSize: cos.reduce((acc, co) => acc + co.netSize, 0),\n  toNet: bv => {\n    const val = cos.map((co, i) => co.toNet(bv[i]));\n    return ethers.utils.concat(val);\n  },\n  // TODO: share more code w/ T_Array.fromNet\n  fromNet: nv => {\n    const chunks = new Array(cos.length).fill(null);\n    let rest = nv;\n\n    for (const i in cos) {\n      const co = cos[i];\n      chunks[i] = co.fromNet(rest.slice(0, co.netSize));\n      rest = rest.slice(co.netSize);\n    }\n\n    return chunks;\n  }\n});\nexport const T_Struct = cos => ({ ...CBR.BT_Struct(cos),\n  netSize: cos.reduce((acc, co) => acc + co[1].netSize, 0),\n  toNet: bv => {\n    const val = cos.map(([k, co]) => co.toNet(bv[k]));\n    return ethers.utils.concat(val);\n  },\n  // TODO: share more code w/ T_Array.fromNet\n  fromNet: nv => {\n    const obj = {};\n    let rest = nv;\n\n    for (const i in cos) {\n      const [k, co] = cos[i];\n      obj[k] = co.fromNet(rest.slice(0, co.netSize));\n      rest = rest.slice(co.netSize);\n    }\n\n    return obj;\n  }\n});\nexport const T_Object = coMap => {\n  const cos = Object.values(coMap);\n  const netSize = cos.reduce((acc, co) => acc + co.netSize, 0);\n  const {\n    ascLabels\n  } = labelMaps(coMap);\n  return { ...CBR.BT_Object(coMap),\n    netSize,\n    toNet: bv => {\n      const chunks = ascLabels.map(label => coMap[label].toNet(bv[label]));\n      return ethers.utils.concat(chunks);\n    },\n    // TODO: share more code w/ T_Array.fromNet and T_Tuple.fromNet\n    fromNet: nv => {\n      const obj = {};\n      let rest = nv;\n\n      for (const iStr in ascLabels) {\n        const i = parseInt(iStr);\n        const label = ascLabels[i];\n        const co = coMap[label];\n        obj[label] = co.fromNet(rest.slice(0, co.netSize));\n        rest = rest.slice(co.netSize);\n      }\n\n      return obj;\n    }\n  };\n}; // 1 byte for the label\n// the rest right-padded with zeroes\n// up to the size of the largest variant\n\nexport const T_Data = coMap => {\n  const cos = Object.values(coMap);\n  const valSize = Math.max(...cos.map(co => co.netSize));\n  const netSize = valSize + 1;\n  const {\n    ascLabels,\n    labelMap\n  } = labelMaps(coMap);\n  return { ...CBR.BT_Data(coMap),\n    netSize,\n    toNet: ([label, val]) => {\n      const i = labelMap[label];\n      const lab_nv = new Uint8Array([i]);\n      const val_co = coMap[label];\n      const val_nv = val_co.toNet(val);\n      const padding = new Uint8Array(valSize - val_nv.length);\n      return ethers.utils.concat([lab_nv, val_nv, padding]);\n    },\n    fromNet: nv => {\n      const i = nv[0];\n      const label = ascLabels[i];\n      const val_co = coMap[label];\n      const rest = nv.slice(1);\n      const sliceTo = val_co.netSize;\n      const val = val_co.fromNet(rest.slice(0, sliceTo));\n      return [label, val];\n    }\n  };\n};\nexport const addressEq = shared.mkAddressEq(T_Address);\nconst T_Token = T_UInt;\nexport const tokenEq = (x, y) => x.eq(y);\nexport const typeDefs = {\n  T_Null,\n  T_Bool,\n  T_UInt,\n  T_Bytes,\n  T_Address,\n  T_Digest,\n  T_Token,\n  T_Object,\n  T_Data,\n  T_Array,\n  T_Tuple,\n  T_Struct\n};\nexport const stdlib = { ...shared,\n  ...typeDefs,\n  addressEq,\n  tokenEq,\n  digest,\n  UInt_max\n};","map":{"version":3,"sources":["/home/x/reach/kick/app/reach-react-template/node_modules/@reach-sh/stdlib/ALGO_compiled.mjs"],"names":["shared","algosdk","buffer","ethers","CBR","labelMaps","BigNumber","Buffer","UInt_max","from","pow","sub","digest","makeDigest","t","v","toNet","T_Null","BT_Null","netSize","bv","Uint8Array","fromNet","nv","T_Bool","BT_Bool","T_UInt","BT_UInt","utils","zeroPad","arrayify","stringyNet","toUtf8Bytes","toUtf8String","bytestringyNet","hexlify","T_Bytes","len","BT_Bytes","T_Digest","BT_Digest","addressToHex","x","decodeAddress","publicKey","toString","addressUnwrapper","addr","networkAccount","undefined","T_Address","BT_Address","canonicalize","uv","val","T_Array","co","size","BT_Array","concat","map","chunks","Array","fill","i","start","slice","T_Tuple","cos","BT_Tuple","reduce","acc","length","rest","T_Struct","BT_Struct","k","obj","T_Object","coMap","Object","values","ascLabels","BT_Object","label","iStr","parseInt","T_Data","valSize","Math","max","labelMap","BT_Data","lab_nv","val_co","val_nv","padding","sliceTo","addressEq","mkAddressEq","T_Token","tokenEq","y","eq","typeDefs","stdlib"],"mappings":"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","sourcesContent":["// ****************************************************************************\n// standard library needed at runtime by compiled Reach programs\n// ****************************************************************************\nimport * as shared from './shared.mjs';\nimport algosdk from 'algosdk';\nimport buffer from 'buffer';\nimport ethers from 'ethers';\nimport * as CBR from './CBR.mjs';\nimport { labelMaps } from './shared_impl.mjs';\nconst BigNumber = ethers.BigNumber;\nconst Buffer = buffer.Buffer;\nexport const UInt_max = BigNumber.from(2).pow(64).sub(1);\nexport const digest = shared.makeDigest((t, v) => t.toNet(v));\nexport const T_Null = {\n  ...CBR.BT_Null,\n  netSize: 0,\n  toNet: (bv) => (void(bv), new Uint8Array([])),\n  fromNet: (nv) => (void(nv), null),\n};\nexport const T_Bool = {\n  ...CBR.BT_Bool,\n  netSize: 1,\n  toNet: (bv) => new Uint8Array([bv ? 1 : 0]),\n  fromNet: (nv) => nv[0] == 1,\n};\nexport const T_UInt = {\n  ...CBR.BT_UInt,\n  netSize: 8,\n  toNet: (bv) => (ethers.utils.zeroPad(ethers.utils.arrayify(bv), 8)),\n  fromNet: (nv) => {\n    // debug(`fromNet: UInt`);\n    // if (getDEBUG()) console.log(nv);\n    return ethers.BigNumber.from(nv);\n  },\n};\n/** @description For arbitrary utf8 strings */\nconst stringyNet = {\n  toNet: (bv) => (ethers.utils.toUtf8Bytes(bv)),\n  fromNet: (nv) => (ethers.utils.toUtf8String(nv)),\n};\n/** @description For hex strings representing bytes */\nconst bytestringyNet = {\n  toNet: (bv) => (ethers.utils.arrayify(bv)),\n  fromNet: (nv) => (ethers.utils.hexlify(nv)),\n};\nexport const T_Bytes = (len) => ({\n  ...CBR.BT_Bytes(len),\n  ...stringyNet,\n  netSize: len,\n});\nexport const T_Digest = {\n  ...CBR.BT_Digest,\n  ...bytestringyNet,\n  netSize: 32,\n};\nexport const addressToHex = (x) => '0x' + Buffer.from(algosdk.decodeAddress(x).publicKey).toString('hex');\n\nfunction addressUnwrapper(x) {\n  const addr = x && x.networkAccount && x.networkAccount.addr ||\n    x && x.addr;\n  return (addr != undefined) ?\n    addressToHex(addr) :\n    x;\n}\nexport const T_Address = {\n  ...CBR.BT_Address,\n  ...bytestringyNet,\n  netSize: 32,\n  canonicalize: (uv) => {\n    const val = addressUnwrapper(uv);\n    return CBR.BT_Address.canonicalize(val || uv);\n  },\n};\nexport const T_Array = (co, size) => ({\n  ...CBR.BT_Array(co, size),\n  netSize: size * co.netSize,\n  toNet: (bv) => {\n    return ethers.utils.concat(bv.map((v) => co.toNet(v)));\n  },\n  fromNet: (nv) => {\n    // TODO: assert nv.size = len * size\n    const len = co.netSize;\n    const chunks = new Array(size).fill(null);\n    for (let i = 0; i < size; i++) {\n      const start = i * len;\n      chunks[i] = co.fromNet(nv.slice(start, start + len));\n    }\n    return chunks;\n  },\n});\nexport const T_Tuple = (cos) => ({\n  ...CBR.BT_Tuple(cos),\n  netSize: (cos.reduce((acc, co) => acc + co.netSize, 0)),\n  toNet: (bv) => {\n    const val = cos.map((co, i) => co.toNet(bv[i]));\n    return ethers.utils.concat(val);\n  },\n  // TODO: share more code w/ T_Array.fromNet\n  fromNet: (nv) => {\n    const chunks = new Array(cos.length).fill(null);\n    let rest = nv;\n    for (const i in cos) {\n      const co = cos[i];\n      chunks[i] = co.fromNet(rest.slice(0, co.netSize));\n      rest = rest.slice(co.netSize);\n    }\n    return chunks;\n  },\n});\nexport const T_Struct = (cos) => ({\n  ...CBR.BT_Struct(cos),\n  netSize: (cos.reduce((acc, co) => acc + co[1].netSize, 0)),\n  toNet: (bv) => {\n    const val = cos.map(([k, co]) => co.toNet(bv[k]));\n    return ethers.utils.concat(val);\n  },\n  // TODO: share more code w/ T_Array.fromNet\n  fromNet: (nv) => {\n    const obj = {};\n    let rest = nv;\n    for (const i in cos) {\n      const [k, co] = cos[i];\n      obj[k] = co.fromNet(rest.slice(0, co.netSize));\n      rest = rest.slice(co.netSize);\n    }\n    return obj;\n  },\n});\nexport const T_Object = (coMap) => {\n  const cos = Object.values(coMap);\n  const netSize = cos.reduce((acc, co) => acc + co.netSize, 0);\n  const { ascLabels } = labelMaps(coMap);\n  return {\n    ...CBR.BT_Object(coMap),\n    netSize,\n    toNet: (bv) => {\n      const chunks = ascLabels.map((label) => coMap[label].toNet(bv[label]));\n      return ethers.utils.concat(chunks);\n    },\n    // TODO: share more code w/ T_Array.fromNet and T_Tuple.fromNet\n    fromNet: (nv) => {\n      const obj = {};\n      let rest = nv;\n      for (const iStr in ascLabels) {\n        const i = parseInt(iStr);\n        const label = ascLabels[i];\n        const co = coMap[label];\n        obj[label] = co.fromNet(rest.slice(0, co.netSize));\n        rest = rest.slice(co.netSize);\n      }\n      return obj;\n    },\n  };\n};\n// 1 byte for the label\n// the rest right-padded with zeroes\n// up to the size of the largest variant\nexport const T_Data = (coMap) => {\n  const cos = Object.values(coMap);\n  const valSize = Math.max(...cos.map((co) => co.netSize));\n  const netSize = valSize + 1;\n  const { ascLabels, labelMap } = labelMaps(coMap);\n  return {\n    ...CBR.BT_Data(coMap),\n    netSize,\n    toNet: ([label, val]) => {\n      const i = labelMap[label];\n      const lab_nv = new Uint8Array([i]);\n      const val_co = coMap[label];\n      const val_nv = val_co.toNet(val);\n      const padding = new Uint8Array(valSize - val_nv.length);\n      return ethers.utils.concat([lab_nv, val_nv, padding]);\n    },\n    fromNet: (nv) => {\n      const i = nv[0];\n      const label = ascLabels[i];\n      const val_co = coMap[label];\n      const rest = nv.slice(1);\n      const sliceTo = val_co.netSize;\n      const val = val_co.fromNet(rest.slice(0, sliceTo));\n      return [label, val];\n    },\n  };\n};\nexport const addressEq = shared.mkAddressEq(T_Address);\nconst T_Token = T_UInt;\nexport const tokenEq = (x, y) => x.eq(y);\nexport const typeDefs = {\n  T_Null,\n  T_Bool,\n  T_UInt,\n  T_Bytes,\n  T_Address,\n  T_Digest,\n  T_Token,\n  T_Object,\n  T_Data,\n  T_Array,\n  T_Tuple,\n  T_Struct,\n};\nexport const stdlib = {\n  ...shared,\n  ...typeDefs,\n  addressEq,\n  tokenEq,\n  digest,\n  UInt_max,\n};\n"]},"metadata":{},"sourceType":"module"}